const { parse, NodeType } = require('node-html-parser');
const axios = require('axios');
const path = require('path');
const fs = require('fs');
const fsPromises = fs.promises;
const util = require('util');

const baseUrl = 'https://docs.oracle.com/en/java/javase/17/docs/api';
const cacheFolder = 'java_sdk_cache';
const outFilePath = path.join(__dirname, '..', 'parse', 'builtins.go');

function toCachedPath(url) {
  if (!url.startsWith(baseUrl)) {
    throw new Error(`url doesn't start with baseUrl: ${url}`);
  }

  const trimmed = url.substring(baseUrl.length);
  return path.join(__dirname, cacheFolder, trimmed);
}

function stripNewlines(text) {
  // the html parser puts a bunch of unnecessary newlines in
  text = text.replaceAll('\n', '');

  // '\xa0' is non-breaking space
  text = text.replaceAll('\xa0', ' ');

  return text;
}

async function getData(url) {
  const cachedPath = toCachedPath(url);
  if (fs.existsSync(cachedPath)) {
    return (await fsPromises.readFile(cachedPath)).toString();
  }

  const result = await axios.get(url);
  if (result.status !== 200) {
    throw new Error(`Non-200 status code: ${result.status}`)
  }

  // write to cache
  console.log(`Caching contents of ${url}`)
  await fsPromises.mkdir(path.dirname(cachedPath), { recursive: true });
  await fsPromises.writeFile(cachedPath, result.data);

  return result.data;
}

async function genType(url) {
  const htmlStr = await getData(url);
  const root = parse(htmlStr);

  const data = {};

  const title = root.querySelector('h1.title').textContent;
  if (!title.startsWith('Class ')) {
    throw new Error(`title doesn't start with 'Class '! title: ${title}`);
  }
  data.className = title.substring('Class '.length);

  const subtitles = root.querySelectorAll('.header > .sub-title');
  for (const st of subtitles) {
    const label = st.querySelector('span').textContent;
    const content = st.querySelector('a').textContent;

    switch (label.toLowerCase()) {
      case 'package':
        data.package = content;
        break;
      case 'module':
        data.module = content;
        break;
    }
  }

  data.fields = parseThreeColumnTable(root, '.field-summary .summary-table > div');
  data.methods = parseThreeColumnTable(root, '.method-summary .summary-table > div.method-summary-table').map(parseArgs);
  data.constructors = parseTwoColumnTable(root, '.constructor-summary .summary-table > div').map(parseArgs);

  console.log(util.inspect(data, {depth: 99}));

  return data;
}

function parseThreeColumnTable(root, selector) {
  const tableChildren = root.querySelectorAll(selector);
  
  const items = [];
  for (let i = 3; i < tableChildren.length - 2; i += 3) {
    const modifierAndType = stripNewlines(tableChildren[i].text);
    // modifierAndType could look like "static final String", in which case we want
    // modifiers to be ["static", "final"] and type to be "string"
    const modifiers = modifierAndType.split(' ');
    const [ type ] = modifiers.splice(-1);

    const name = stripNewlines(tableChildren[i+1].text);
    const description = stripNewlines(tableChildren[i+2].text)

    items.push({
      name, modifiers, type, description
    })
  }

  return items;
}

function parseTwoColumnTable(root, selector) {
  const tableChildren = root.querySelectorAll(selector);
  
  const items = [];
  for (let i = 2; i < tableChildren.length - 1; i += 2) {
    items.push({
      name: stripNewlines(tableChildren[i].text),
      description: stripNewlines(tableChildren[i+1].text),
    })
  }

  return items;
}

function parseArgs(item) {
  const { name } = item;

  const matches = /(.*)\((.*)\)/.exec(name);
  if (!matches) {
    console.log(`Can't parse args, method formatted wrong: ${item}`);
    return item;
  }

  const baseName = matches[1];
  let args = matches[2];

  if (args === '') {
    args = [];
  } else {
    args = args.split(',')
      .map(a => {
        const split = a.trim().split(' ');
        return {
          type: split[0],
          name: split[1]
        };
      });
  }

  item.name = baseName;
  item.args = args;

  return item;
}

// Takes in a potentially generic type like "Comparator<String>"
// and returns the un-generic version like "Comparator"
function getUngenericType(typeName) {
  const matches = /(\w+)<.*>/.exec(typeName);
  if (!matches) {
    return typeName;
  }

  return matches[1];
}

function writeTypes(types) {
  const outFile = fs.openSync(outFilePath, 'w');

  // 1st section: top-level type declarations

  fs.writeSync(outFile, `// File generated by docs_parser script. DO NOT EDIT!

package parse

var BuiltinTypes = map[string]*JavaType{`);
  for (const t of types) {
    writeType(outFile, t);
  }
  fs.writeSync(outFile, '\n}\n');

  // 2nd section: init fields, methods, and constructors that may refer to other types

  fs.writeSync(outFile, `
func init() {
`);

  for (const t of types) {
    writeMembers(outFile, t);
  }

  fs.writeSync(outFile, '\n}\n');

  fs.closeSync(outFile);
}

function writeType(outFile, type) {
  fs.writeSync(outFile, `
    "${type.className}": {
        Name: "${type.className}",
        PackageName: "${type.package}",
        Visibility: VisibilityPublic,
    },`);
}

function writeMembers(outFile, type) {
  fs.writeSync(outFile, `
    BuiltinTypes["${type.className}"].Fields = []*JavaField{`);

  for (const field of type.fields) {
    writeField(outFile, field);
  }

  fs.writeSync(outFile, `
    }

    BuiltinTypes["${type.className}"].Methods = []*JavaMethod{`);

  for (const method of type.methods) {
    writeMethod(outFile, method);
  }

  fs.writeSync(outFile, `
    }`);
}

function writeField(outFile, field) {
  fs.writeSync(outFile, `
        {
            Name: "${field.name}",
            Visibility: VisibilityPublic,
            Type: getOrCreateBuiltinType("${getUngenericType(field.type)}"),
            IsStatic: ${field.modifiers.includes('static')},
            IsFinal: ${field.modifiers.includes('final')},
        },`)
}

function writeMethod(outFile, method) {
  fs.writeSync(outFile, `
        {
            Name: "${method.name}",
            Visibility: VisibilityPublic,
            ReturnType: getOrCreateBuiltinType("${getUngenericType(method.type)}"),
            Arguments: []*JavaArgument{`);

  for (const arg of method.args) {
    fs.writeSync(outFile, `
                {
                    Name: "${arg.name}",
                    Type: getOrCreateBuiltinType("${getUngenericType(arg.type)}"),
                },`)
  }

  fs.writeSync(outFile, `
            },
        },`)
}

async function main() {
  const StringType = await genType('https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/String.html')
  writeTypes([StringType]);
}

main().catch(console.error)
