// Code generated from JavaParser.g4 by ANTLR 4.10.1. DO NOT EDIT.

package parser // JavaParser

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type JavaParser struct {
	*antlr.BaseParser
}

var javaparserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	literalNames           []string
	symbolicNames          []string
	ruleNames              []string
	predictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func javaparserParserInit() {
	staticData := &javaparserParserStaticData
	staticData.literalNames = []string{
		"", "'abstract'", "'assert'", "'boolean'", "'break'", "'byte'", "'case'",
		"'catch'", "'char'", "'class'", "'const'", "'continue'", "'default'",
		"'do'", "'double'", "'else'", "'enum'", "'extends'", "'final'", "'finally'",
		"'float'", "'for'", "'if'", "'goto'", "'implements'", "'import'", "'instanceof'",
		"'int'", "'interface'", "'long'", "'native'", "'new'", "'package'",
		"'private'", "'protected'", "'public'", "'return'", "'short'", "'static'",
		"'strictfp'", "'super'", "'switch'", "'synchronized'", "'this'", "'throw'",
		"'throws'", "'transient'", "'try'", "'void'", "'volatile'", "'while'",
		"'module'", "'open'", "'requires'", "'exports'", "'opens'", "'to'",
		"'uses'", "'provides'", "'with'", "'transitive'", "'var'", "'yield'",
		"'record'", "'sealed'", "'permits'", "'non-sealed'", "", "", "", "",
		"", "", "", "", "", "", "'null'", "'('", "')'", "'{'", "'}'", "'['",
		"']'", "';'", "','", "'.'", "'='", "'>'", "'<'", "'!'", "'~'", "'?'",
		"':'", "'=='", "'<='", "'>='", "'!='", "'&&'", "'||'", "'++'", "'--'",
		"'+'", "'-'", "'*'", "'/'", "'&'", "'|'", "'^'", "'%'", "'+='", "'-='",
		"'*='", "'/='", "'&='", "'|='", "'^='", "'%='", "'<<='", "'>>='", "'>>>='",
		"'->'", "'::'", "'@'", "'...'",
	}
	staticData.symbolicNames = []string{
		"", "ABSTRACT", "ASSERT", "BOOLEAN", "BREAK", "BYTE", "CASE", "CATCH",
		"CHAR", "CLASS", "CONST", "CONTINUE", "DEFAULT", "DO", "DOUBLE", "ELSE",
		"ENUM", "EXTENDS", "FINAL", "FINALLY", "FLOAT", "FOR", "IF", "GOTO",
		"IMPLEMENTS", "IMPORT", "INSTANCEOF", "INT", "INTERFACE", "LONG", "NATIVE",
		"NEW", "PACKAGE", "PRIVATE", "PROTECTED", "PUBLIC", "RETURN", "SHORT",
		"STATIC", "STRICTFP", "SUPER", "SWITCH", "SYNCHRONIZED", "THIS", "THROW",
		"THROWS", "TRANSIENT", "TRY", "VOID", "VOLATILE", "WHILE", "MODULE",
		"OPEN", "REQUIRES", "EXPORTS", "OPENS", "TO", "USES", "PROVIDES", "WITH",
		"TRANSITIVE", "VAR", "YIELD", "RECORD", "SEALED", "PERMITS", "NON_SEALED",
		"DECIMAL_LITERAL", "HEX_LITERAL", "OCT_LITERAL", "BINARY_LITERAL", "FLOAT_LITERAL",
		"HEX_FLOAT_LITERAL", "BOOL_LITERAL", "CHAR_LITERAL", "STRING_LITERAL",
		"TEXT_BLOCK", "NULL_LITERAL", "LPAREN", "RPAREN", "LBRACE", "RBRACE",
		"LBRACK", "RBRACK", "SEMI", "COMMA", "DOT", "ASSIGN", "GT", "LT", "BANG",
		"TILDE", "QUESTION", "COLON", "EQUAL", "LE", "GE", "NOTEQUAL", "AND",
		"OR", "INC", "DEC", "ADD", "SUB", "MUL", "DIV", "BITAND", "BITOR", "CARET",
		"MOD", "ADD_ASSIGN", "SUB_ASSIGN", "MUL_ASSIGN", "DIV_ASSIGN", "AND_ASSIGN",
		"OR_ASSIGN", "XOR_ASSIGN", "MOD_ASSIGN", "LSHIFT_ASSIGN", "RSHIFT_ASSIGN",
		"URSHIFT_ASSIGN", "ARROW", "COLONCOLON", "AT", "ELLIPSIS", "WS", "COMMENT",
		"LINE_COMMENT", "IDENTIFIER",
	}
	staticData.ruleNames = []string{
		"compilationUnit", "packageDeclaration", "importDeclaration", "typeDeclaration",
		"modifier", "classOrInterfaceModifier", "variableModifier", "classDeclaration",
		"classDeclarationExtends", "classDeclarationImplements", "classDeclarationPermits",
		"typeParameters", "typeParameter", "typeBound", "enumDeclaration", "enumConstants",
		"enumConstant", "enumBodyDeclarations", "interfaceDeclaration", "classBody",
		"interfaceBody", "classBodyDeclaration", "memberDeclaration", "methodDeclaration",
		"methodBody", "typeTypeOrVoid", "genericMethodDeclaration", "genericConstructorDeclaration",
		"constructorDeclaration", "fieldDeclaration", "interfaceBodyDeclaration",
		"interfaceMemberDeclaration", "constDeclaration", "constantDeclarator",
		"interfaceMethodDeclaration", "interfaceMethodModifier", "genericInterfaceMethodDeclaration",
		"interfaceCommonBodyDeclaration", "variableDeclarators", "variableDeclarator",
		"variableDeclaratorId", "variableInitializer", "arrayInitializer", "classOrInterfaceType",
		"typeArgument", "qualifiedNameList", "formalParameters", "receiverParameter",
		"formalParameterList", "formalParameter", "lastFormalParameter", "lambdaLVTIList",
		"lambdaLVTIParameter", "qualifiedName", "literal", "integerLiteral",
		"floatLiteral", "altAnnotationQualifiedName", "annotation", "elementValuePairs",
		"elementValuePair", "elementValue", "elementValueArrayInitializer",
		"annotationTypeDeclaration", "annotationTypeBody", "annotationTypeElementDeclaration",
		"annotationTypeElementRest", "annotationMethodOrConstantRest", "annotationMethodRest",
		"annotationConstantRest", "defaultValue", "moduleDeclaration", "moduleBody",
		"moduleDirective", "requiresModifier", "recordDeclaration", "recordHeader",
		"recordComponentList", "recordComponent", "recordBody", "block", "blockStatement",
		"localVariableDeclaration", "identifier", "localTypeDeclaration", "statement",
		"catchClause", "catchType", "finallyBlock", "resourceSpecification",
		"resources", "resource", "switchBlockStatementGroup", "switchLabel",
		"forControl", "forInit", "enhancedForControl", "parExpression", "expressionList",
		"methodCall", "expression", "pattern", "lambdaExpression", "lambdaParameters",
		"lambdaBody", "primary", "switchExpression", "switchLabeledRule", "guardedPattern",
		"switchRuleOutcome", "classType", "creator", "createdName", "innerCreator",
		"arrayCreatorRest", "classCreatorRest", "explicitGenericInvocation",
		"typeArgumentsOrDiamond", "nonWildcardTypeArgumentsOrDiamond", "nonWildcardTypeArguments",
		"typeList", "typeType", "primitiveType", "typeArguments", "superSuffix",
		"explicitGenericInvocationSuffix", "arguments",
	}
	staticData.predictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 128, 1776, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 1, 0, 3, 0, 256, 8, 0, 1, 0, 5, 0, 259, 8, 0, 10, 0, 12, 0, 262, 9,
		0, 1, 0, 5, 0, 265, 8, 0, 10, 0, 12, 0, 268, 9, 0, 1, 0, 1, 0, 1, 0, 3,
		0, 273, 8, 0, 1, 1, 5, 1, 276, 8, 1, 10, 1, 12, 1, 279, 9, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 2, 1, 2, 3, 2, 287, 8, 2, 1, 2, 1, 2, 1, 2, 3, 2, 292,
		8, 2, 1, 2, 1, 2, 1, 3, 5, 3, 297, 8, 3, 10, 3, 12, 3, 300, 9, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 3, 3, 307, 8, 3, 1, 3, 3, 3, 310, 8, 3, 1, 4, 1,
		4, 1, 4, 1, 4, 1, 4, 3, 4, 317, 8, 4, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1,
		5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 329, 8, 5, 1, 6, 1, 6, 3, 6, 333, 8, 6,
		1, 7, 1, 7, 1, 7, 3, 7, 338, 8, 7, 1, 7, 3, 7, 341, 8, 7, 1, 7, 3, 7, 344,
		8, 7, 1, 7, 3, 7, 347, 8, 7, 1, 7, 1, 7, 1, 8, 1, 8, 1, 8, 1, 9, 1, 9,
		1, 9, 1, 10, 1, 10, 1, 10, 1, 11, 1, 11, 1, 11, 1, 11, 5, 11, 364, 8, 11,
		10, 11, 12, 11, 367, 9, 11, 1, 11, 1, 11, 1, 12, 5, 12, 372, 8, 12, 10,
		12, 12, 12, 375, 9, 12, 1, 12, 1, 12, 1, 12, 5, 12, 380, 8, 12, 10, 12,
		12, 12, 383, 9, 12, 1, 12, 3, 12, 386, 8, 12, 1, 13, 1, 13, 1, 13, 5, 13,
		391, 8, 13, 10, 13, 12, 13, 394, 9, 13, 1, 14, 1, 14, 1, 14, 1, 14, 3,
		14, 400, 8, 14, 1, 14, 1, 14, 3, 14, 404, 8, 14, 1, 14, 3, 14, 407, 8,
		14, 1, 14, 3, 14, 410, 8, 14, 1, 14, 1, 14, 1, 15, 1, 15, 1, 15, 5, 15,
		417, 8, 15, 10, 15, 12, 15, 420, 9, 15, 1, 16, 5, 16, 423, 8, 16, 10, 16,
		12, 16, 426, 9, 16, 1, 16, 1, 16, 3, 16, 430, 8, 16, 1, 16, 3, 16, 433,
		8, 16, 1, 17, 1, 17, 5, 17, 437, 8, 17, 10, 17, 12, 17, 440, 9, 17, 1,
		18, 1, 18, 1, 18, 3, 18, 445, 8, 18, 1, 18, 1, 18, 3, 18, 449, 8, 18, 1,
		18, 1, 18, 3, 18, 453, 8, 18, 1, 18, 1, 18, 1, 19, 1, 19, 5, 19, 459, 8,
		19, 10, 19, 12, 19, 462, 9, 19, 1, 19, 1, 19, 1, 20, 1, 20, 5, 20, 468,
		8, 20, 10, 20, 12, 20, 471, 9, 20, 1, 20, 1, 20, 1, 21, 1, 21, 3, 21, 477,
		8, 21, 1, 21, 1, 21, 5, 21, 481, 8, 21, 10, 21, 12, 21, 484, 9, 21, 1,
		21, 3, 21, 487, 8, 21, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22,
		1, 22, 1, 22, 1, 22, 3, 22, 499, 8, 22, 1, 23, 1, 23, 1, 23, 1, 23, 1,
		23, 5, 23, 506, 8, 23, 10, 23, 12, 23, 509, 9, 23, 1, 23, 1, 23, 3, 23,
		513, 8, 23, 1, 23, 1, 23, 1, 24, 1, 24, 3, 24, 519, 8, 24, 1, 25, 1, 25,
		3, 25, 523, 8, 25, 1, 26, 1, 26, 1, 26, 1, 27, 1, 27, 1, 27, 1, 28, 1,
		28, 1, 28, 1, 28, 3, 28, 535, 8, 28, 1, 28, 1, 28, 1, 29, 1, 29, 1, 29,
		1, 29, 1, 30, 5, 30, 544, 8, 30, 10, 30, 12, 30, 547, 9, 30, 1, 30, 1,
		30, 3, 30, 551, 8, 30, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31,
		1, 31, 3, 31, 561, 8, 31, 1, 32, 1, 32, 1, 32, 1, 32, 5, 32, 567, 8, 32,
		10, 32, 12, 32, 570, 9, 32, 1, 32, 1, 32, 1, 33, 1, 33, 1, 33, 5, 33, 577,
		8, 33, 10, 33, 12, 33, 580, 9, 33, 1, 33, 1, 33, 1, 33, 1, 34, 5, 34, 586,
		8, 34, 10, 34, 12, 34, 589, 9, 34, 1, 34, 1, 34, 1, 35, 1, 35, 1, 35, 1,
		35, 1, 35, 1, 35, 3, 35, 599, 8, 35, 1, 36, 5, 36, 602, 8, 36, 10, 36,
		12, 36, 605, 9, 36, 1, 36, 1, 36, 1, 36, 1, 37, 5, 37, 611, 8, 37, 10,
		37, 12, 37, 614, 9, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 5, 37, 621,
		8, 37, 10, 37, 12, 37, 624, 9, 37, 1, 37, 1, 37, 3, 37, 628, 8, 37, 1,
		37, 1, 37, 1, 38, 1, 38, 1, 38, 5, 38, 635, 8, 38, 10, 38, 12, 38, 638,
		9, 38, 1, 39, 1, 39, 1, 39, 3, 39, 643, 8, 39, 1, 40, 1, 40, 1, 40, 5,
		40, 648, 8, 40, 10, 40, 12, 40, 651, 9, 40, 1, 41, 1, 41, 3, 41, 655, 8,
		41, 1, 42, 1, 42, 1, 42, 1, 42, 5, 42, 661, 8, 42, 10, 42, 12, 42, 664,
		9, 42, 1, 42, 3, 42, 667, 8, 42, 3, 42, 669, 8, 42, 1, 42, 1, 42, 1, 43,
		1, 43, 3, 43, 675, 8, 43, 1, 43, 1, 43, 1, 43, 3, 43, 680, 8, 43, 5, 43,
		682, 8, 43, 10, 43, 12, 43, 685, 9, 43, 1, 44, 1, 44, 5, 44, 689, 8, 44,
		10, 44, 12, 44, 692, 9, 44, 1, 44, 1, 44, 1, 44, 3, 44, 697, 8, 44, 3,
		44, 699, 8, 44, 1, 45, 1, 45, 1, 45, 5, 45, 704, 8, 45, 10, 45, 12, 45,
		707, 9, 45, 1, 46, 1, 46, 3, 46, 711, 8, 46, 1, 46, 1, 46, 1, 46, 3, 46,
		716, 8, 46, 1, 46, 3, 46, 719, 8, 46, 3, 46, 721, 8, 46, 1, 46, 1, 46,
		1, 47, 1, 47, 1, 47, 1, 47, 5, 47, 729, 8, 47, 10, 47, 12, 47, 732, 9,
		47, 1, 47, 1, 47, 1, 48, 1, 48, 1, 48, 5, 48, 739, 8, 48, 10, 48, 12, 48,
		742, 9, 48, 1, 48, 1, 48, 3, 48, 746, 8, 48, 1, 48, 3, 48, 749, 8, 48,
		1, 49, 5, 49, 752, 8, 49, 10, 49, 12, 49, 755, 9, 49, 1, 49, 1, 49, 1,
		49, 1, 50, 5, 50, 761, 8, 50, 10, 50, 12, 50, 764, 9, 50, 1, 50, 1, 50,
		5, 50, 768, 8, 50, 10, 50, 12, 50, 771, 9, 50, 1, 50, 1, 50, 1, 50, 1,
		51, 1, 51, 1, 51, 5, 51, 779, 8, 51, 10, 51, 12, 51, 782, 9, 51, 1, 52,
		5, 52, 785, 8, 52, 10, 52, 12, 52, 788, 9, 52, 1, 52, 1, 52, 1, 52, 1,
		53, 1, 53, 1, 53, 5, 53, 796, 8, 53, 10, 53, 12, 53, 799, 9, 53, 1, 54,
		1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 3, 54, 808, 8, 54, 1, 55, 1,
		55, 1, 56, 1, 56, 1, 57, 1, 57, 1, 57, 5, 57, 817, 8, 57, 10, 57, 12, 57,
		820, 9, 57, 1, 57, 1, 57, 1, 57, 1, 58, 1, 58, 1, 58, 3, 58, 828, 8, 58,
		1, 58, 1, 58, 1, 58, 3, 58, 833, 8, 58, 1, 58, 3, 58, 836, 8, 58, 1, 59,
		1, 59, 1, 59, 5, 59, 841, 8, 59, 10, 59, 12, 59, 844, 9, 59, 1, 60, 1,
		60, 1, 60, 1, 60, 1, 61, 1, 61, 1, 61, 3, 61, 853, 8, 61, 1, 62, 1, 62,
		1, 62, 1, 62, 5, 62, 859, 8, 62, 10, 62, 12, 62, 862, 9, 62, 3, 62, 864,
		8, 62, 1, 62, 3, 62, 867, 8, 62, 1, 62, 1, 62, 1, 63, 1, 63, 1, 63, 1,
		63, 1, 63, 1, 64, 1, 64, 5, 64, 878, 8, 64, 10, 64, 12, 64, 881, 9, 64,
		1, 64, 1, 64, 1, 65, 5, 65, 886, 8, 65, 10, 65, 12, 65, 889, 9, 65, 1,
		65, 1, 65, 3, 65, 893, 8, 65, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66,
		3, 66, 901, 8, 66, 1, 66, 1, 66, 3, 66, 905, 8, 66, 1, 66, 1, 66, 3, 66,
		909, 8, 66, 1, 66, 1, 66, 3, 66, 913, 8, 66, 1, 66, 1, 66, 3, 66, 917,
		8, 66, 3, 66, 919, 8, 66, 1, 67, 1, 67, 3, 67, 923, 8, 67, 1, 68, 1, 68,
		1, 68, 1, 68, 3, 68, 929, 8, 68, 1, 69, 1, 69, 1, 70, 1, 70, 1, 70, 1,
		71, 3, 71, 937, 8, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 72, 1, 72, 5, 72,
		945, 8, 72, 10, 72, 12, 72, 948, 9, 72, 1, 72, 1, 72, 1, 73, 1, 73, 5,
		73, 954, 8, 73, 10, 73, 12, 73, 957, 9, 73, 1, 73, 1, 73, 1, 73, 1, 73,
		1, 73, 1, 73, 1, 73, 3, 73, 966, 8, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1,
		73, 1, 73, 3, 73, 974, 8, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73,
		1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 3, 73, 988, 8, 73, 1, 74, 1,
		74, 1, 75, 1, 75, 1, 75, 3, 75, 995, 8, 75, 1, 75, 1, 75, 1, 75, 3, 75,
		1000, 8, 75, 1, 75, 1, 75, 1, 76, 1, 76, 3, 76, 1006, 8, 76, 1, 76, 1,
		76, 1, 77, 1, 77, 1, 77, 5, 77, 1013, 8, 77, 10, 77, 12, 77, 1016, 9, 77,
		1, 78, 1, 78, 1, 78, 1, 79, 1, 79, 5, 79, 1023, 8, 79, 10, 79, 12, 79,
		1026, 9, 79, 1, 79, 1, 79, 1, 80, 1, 80, 5, 80, 1032, 8, 80, 10, 80, 12,
		80, 1035, 9, 80, 1, 80, 1, 80, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 3, 81,
		1044, 8, 81, 1, 82, 5, 82, 1047, 8, 82, 10, 82, 12, 82, 1050, 9, 82, 1,
		82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 3, 82, 1060, 8, 82,
		1, 83, 1, 83, 1, 84, 5, 84, 1065, 8, 84, 10, 84, 12, 84, 1068, 9, 84, 1,
		84, 1, 84, 1, 84, 3, 84, 1073, 8, 84, 1, 84, 3, 84, 1076, 8, 84, 1, 85,
		1, 85, 1, 85, 1, 85, 1, 85, 3, 85, 1083, 8, 85, 1, 85, 1, 85, 1, 85, 1,
		85, 1, 85, 1, 85, 1, 85, 3, 85, 1092, 8, 85, 1, 85, 1, 85, 1, 85, 1, 85,
		1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1,
		85, 1, 85, 1, 85, 1, 85, 1, 85, 4, 85, 1113, 8, 85, 11, 85, 12, 85, 1114,
		1, 85, 3, 85, 1118, 8, 85, 1, 85, 3, 85, 1121, 8, 85, 1, 85, 1, 85, 1,
		85, 1, 85, 5, 85, 1127, 8, 85, 10, 85, 12, 85, 1130, 9, 85, 1, 85, 3, 85,
		1133, 8, 85, 1, 85, 1, 85, 1, 85, 1, 85, 5, 85, 1139, 8, 85, 10, 85, 12,
		85, 1142, 9, 85, 1, 85, 5, 85, 1145, 8, 85, 10, 85, 12, 85, 1148, 9, 85,
		1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 3, 85, 1158, 8,
		85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 3, 85, 1167, 8, 85,
		1, 85, 1, 85, 1, 85, 3, 85, 1172, 8, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1,
		85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 3, 85, 1185, 8, 85, 1, 85,
		1, 85, 1, 85, 1, 85, 3, 85, 1191, 8, 85, 1, 86, 1, 86, 1, 86, 5, 86, 1196,
		8, 86, 10, 86, 12, 86, 1199, 9, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86,
		1, 87, 1, 87, 1, 87, 5, 87, 1209, 8, 87, 10, 87, 12, 87, 1212, 9, 87, 1,
		88, 1, 88, 1, 88, 1, 89, 1, 89, 1, 89, 3, 89, 1220, 8, 89, 1, 89, 1, 89,
		1, 90, 1, 90, 1, 90, 5, 90, 1227, 8, 90, 10, 90, 12, 90, 1230, 9, 90, 1,
		91, 5, 91, 1233, 8, 91, 10, 91, 12, 91, 1236, 9, 91, 1, 91, 1, 91, 1, 91,
		1, 91, 1, 91, 3, 91, 1243, 8, 91, 1, 91, 1, 91, 1, 91, 1, 91, 3, 91, 1249,
		8, 91, 1, 92, 4, 92, 1252, 8, 92, 11, 92, 12, 92, 1253, 1, 92, 4, 92, 1257,
		8, 92, 11, 92, 12, 92, 1258, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93,
		3, 93, 1267, 8, 93, 1, 93, 1, 93, 1, 93, 3, 93, 1272, 8, 93, 1, 94, 1,
		94, 3, 94, 1276, 8, 94, 1, 94, 1, 94, 3, 94, 1280, 8, 94, 1, 94, 1, 94,
		3, 94, 1284, 8, 94, 3, 94, 1286, 8, 94, 1, 95, 1, 95, 3, 95, 1290, 8, 95,
		1, 96, 5, 96, 1293, 8, 96, 10, 96, 12, 96, 1296, 9, 96, 1, 96, 1, 96, 3,
		96, 1300, 8, 96, 1, 96, 1, 96, 1, 96, 1, 96, 1, 97, 1, 97, 1, 97, 1, 97,
		1, 98, 1, 98, 1, 98, 5, 98, 1313, 8, 98, 10, 98, 12, 98, 1316, 9, 98, 1,
		99, 1, 99, 1, 99, 3, 99, 1321, 8, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99,
		3, 99, 1328, 8, 99, 1, 99, 1, 99, 1, 99, 1, 99, 3, 99, 1334, 8, 99, 1,
		99, 3, 99, 1337, 8, 99, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100,
		1, 100, 5, 100, 1346, 8, 100, 10, 100, 12, 100, 1349, 9, 100, 1, 100, 1,
		100, 1, 100, 5, 100, 1354, 8, 100, 10, 100, 12, 100, 1357, 9, 100, 1, 100,
		1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100,
		1, 100, 1, 100, 3, 100, 1371, 8, 100, 1, 100, 1, 100, 3, 100, 1375, 8,
		100, 1, 100, 1, 100, 1, 100, 3, 100, 1380, 8, 100, 1, 100, 1, 100, 3, 100,
		1384, 8, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1,
		100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 3, 100, 1400, 8, 100,
		1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100,
		1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100,
		1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100,
		1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100,
		1, 100, 1, 100, 3, 100, 1440, 8, 100, 1, 100, 1, 100, 1, 100, 1, 100, 3,
		100, 1446, 8, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100,
		1, 100, 1, 100, 1, 100, 1, 100, 3, 100, 1459, 8, 100, 1, 100, 1, 100, 1,
		100, 3, 100, 1464, 8, 100, 1, 100, 5, 100, 1467, 8, 100, 10, 100, 12, 100,
		1470, 9, 100, 1, 101, 5, 101, 1473, 8, 101, 10, 101, 12, 101, 1476, 9,
		101, 1, 101, 1, 101, 5, 101, 1480, 8, 101, 10, 101, 12, 101, 1483, 9, 101,
		1, 101, 1, 101, 1, 102, 1, 102, 1, 102, 1, 102, 1, 103, 1, 103, 1, 103,
		3, 103, 1494, 8, 103, 1, 103, 1, 103, 1, 103, 1, 103, 1, 103, 5, 103, 1501,
		8, 103, 10, 103, 12, 103, 1504, 9, 103, 1, 103, 1, 103, 1, 103, 1, 103,
		3, 103, 1510, 8, 103, 1, 103, 3, 103, 1513, 8, 103, 1, 104, 1, 104, 3,
		104, 1517, 8, 104, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105,
		1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105,
		3, 105, 1535, 8, 105, 3, 105, 1537, 8, 105, 1, 106, 1, 106, 1, 106, 1,
		106, 5, 106, 1543, 8, 106, 10, 106, 12, 106, 1546, 9, 106, 1, 106, 1, 106,
		1, 107, 1, 107, 1, 107, 1, 107, 3, 107, 1554, 8, 107, 1, 107, 1, 107, 1,
		107, 1, 107, 1, 107, 3, 107, 1561, 8, 107, 1, 108, 1, 108, 1, 108, 1, 108,
		1, 108, 1, 108, 5, 108, 1569, 8, 108, 10, 108, 12, 108, 1572, 9, 108, 1,
		108, 1, 108, 5, 108, 1576, 8, 108, 10, 108, 12, 108, 1579, 9, 108, 1, 108,
		1, 108, 1, 108, 5, 108, 1584, 8, 108, 10, 108, 12, 108, 1587, 9, 108, 3,
		108, 1589, 8, 108, 1, 108, 1, 108, 1, 108, 5, 108, 1594, 8, 108, 10, 108,
		12, 108, 1597, 9, 108, 1, 109, 1, 109, 5, 109, 1601, 8, 109, 10, 109, 12,
		109, 1604, 9, 109, 3, 109, 1606, 8, 109, 1, 110, 1, 110, 1, 110, 3, 110,
		1611, 8, 110, 1, 110, 5, 110, 1614, 8, 110, 10, 110, 12, 110, 1617, 9,
		110, 1, 110, 1, 110, 3, 110, 1621, 8, 110, 1, 111, 1, 111, 1, 111, 1, 111,
		1, 111, 1, 111, 1, 111, 3, 111, 1630, 8, 111, 3, 111, 1632, 8, 111, 1,
		112, 1, 112, 3, 112, 1636, 8, 112, 1, 112, 1, 112, 1, 112, 3, 112, 1641,
		8, 112, 5, 112, 1643, 8, 112, 10, 112, 12, 112, 1646, 9, 112, 1, 112, 3,
		112, 1649, 8, 112, 1, 113, 1, 113, 3, 113, 1653, 8, 113, 1, 113, 1, 113,
		1, 114, 1, 114, 1, 114, 1, 114, 5, 114, 1661, 8, 114, 10, 114, 12, 114,
		1664, 9, 114, 1, 114, 1, 114, 1, 114, 1, 114, 1, 114, 1, 114, 1, 114, 5,
		114, 1673, 8, 114, 10, 114, 12, 114, 1676, 9, 114, 1, 114, 1, 114, 5, 114,
		1680, 8, 114, 10, 114, 12, 114, 1683, 9, 114, 3, 114, 1685, 8, 114, 1,
		115, 1, 115, 3, 115, 1689, 8, 115, 1, 116, 1, 116, 1, 116, 1, 117, 1, 117,
		1, 117, 3, 117, 1697, 8, 117, 1, 118, 1, 118, 1, 118, 3, 118, 1702, 8,
		118, 1, 119, 1, 119, 1, 119, 1, 119, 1, 120, 1, 120, 1, 120, 5, 120, 1711,
		8, 120, 10, 120, 12, 120, 1714, 9, 120, 1, 121, 5, 121, 1717, 8, 121, 10,
		121, 12, 121, 1720, 9, 121, 1, 121, 1, 121, 3, 121, 1724, 8, 121, 1, 121,
		5, 121, 1727, 8, 121, 10, 121, 12, 121, 1730, 9, 121, 1, 121, 1, 121, 5,
		121, 1734, 8, 121, 10, 121, 12, 121, 1737, 9, 121, 1, 122, 1, 122, 1, 123,
		1, 123, 1, 123, 1, 123, 5, 123, 1745, 8, 123, 10, 123, 12, 123, 1748, 9,
		123, 1, 123, 1, 123, 1, 124, 1, 124, 1, 124, 3, 124, 1755, 8, 124, 1, 124,
		1, 124, 3, 124, 1759, 8, 124, 3, 124, 1761, 8, 124, 1, 125, 1, 125, 1,
		125, 1, 125, 1, 125, 3, 125, 1768, 8, 125, 1, 126, 1, 126, 3, 126, 1772,
		8, 126, 1, 126, 1, 126, 1, 126, 0, 2, 200, 216, 127, 0, 2, 4, 6, 8, 10,
		12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46,
		48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82,
		84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114,
		116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144,
		146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174,
		176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204,
		206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234,
		236, 238, 240, 242, 244, 246, 248, 250, 252, 0, 15, 2, 0, 17, 17, 40, 40,
		1, 0, 67, 70, 1, 0, 71, 72, 2, 0, 38, 38, 60, 60, 2, 0, 51, 65, 128, 128,
		1, 0, 100, 103, 1, 0, 90, 91, 2, 0, 104, 105, 109, 109, 1, 0, 102, 103,
		2, 0, 88, 89, 95, 96, 2, 0, 94, 94, 97, 97, 2, 0, 87, 87, 110, 120, 1,
		0, 100, 101, 2, 0, 93, 93, 121, 121, 8, 0, 3, 3, 5, 5, 8, 8, 14, 14, 20,
		20, 27, 27, 29, 29, 37, 37, 1973, 0, 272, 1, 0, 0, 0, 2, 277, 1, 0, 0,
		0, 4, 284, 1, 0, 0, 0, 6, 309, 1, 0, 0, 0, 8, 316, 1, 0, 0, 0, 10, 328,
		1, 0, 0, 0, 12, 332, 1, 0, 0, 0, 14, 334, 1, 0, 0, 0, 16, 350, 1, 0, 0,
		0, 18, 353, 1, 0, 0, 0, 20, 356, 1, 0, 0, 0, 22, 359, 1, 0, 0, 0, 24, 373,
		1, 0, 0, 0, 26, 387, 1, 0, 0, 0, 28, 395, 1, 0, 0, 0, 30, 413, 1, 0, 0,
		0, 32, 424, 1, 0, 0, 0, 34, 434, 1, 0, 0, 0, 36, 441, 1, 0, 0, 0, 38, 456,
		1, 0, 0, 0, 40, 465, 1, 0, 0, 0, 42, 486, 1, 0, 0, 0, 44, 498, 1, 0, 0,
		0, 46, 500, 1, 0, 0, 0, 48, 518, 1, 0, 0, 0, 50, 522, 1, 0, 0, 0, 52, 524,
		1, 0, 0, 0, 54, 527, 1, 0, 0, 0, 56, 530, 1, 0, 0, 0, 58, 538, 1, 0, 0,
		0, 60, 550, 1, 0, 0, 0, 62, 560, 1, 0, 0, 0, 64, 562, 1, 0, 0, 0, 66, 573,
		1, 0, 0, 0, 68, 587, 1, 0, 0, 0, 70, 598, 1, 0, 0, 0, 72, 603, 1, 0, 0,
		0, 74, 612, 1, 0, 0, 0, 76, 631, 1, 0, 0, 0, 78, 639, 1, 0, 0, 0, 80, 644,
		1, 0, 0, 0, 82, 654, 1, 0, 0, 0, 84, 656, 1, 0, 0, 0, 86, 672, 1, 0, 0,
		0, 88, 698, 1, 0, 0, 0, 90, 700, 1, 0, 0, 0, 92, 708, 1, 0, 0, 0, 94, 724,
		1, 0, 0, 0, 96, 748, 1, 0, 0, 0, 98, 753, 1, 0, 0, 0, 100, 762, 1, 0, 0,
		0, 102, 775, 1, 0, 0, 0, 104, 786, 1, 0, 0, 0, 106, 792, 1, 0, 0, 0, 108,
		807, 1, 0, 0, 0, 110, 809, 1, 0, 0, 0, 112, 811, 1, 0, 0, 0, 114, 818,
		1, 0, 0, 0, 116, 827, 1, 0, 0, 0, 118, 837, 1, 0, 0, 0, 120, 845, 1, 0,
		0, 0, 122, 852, 1, 0, 0, 0, 124, 854, 1, 0, 0, 0, 126, 870, 1, 0, 0, 0,
		128, 875, 1, 0, 0, 0, 130, 892, 1, 0, 0, 0, 132, 918, 1, 0, 0, 0, 134,
		922, 1, 0, 0, 0, 136, 924, 1, 0, 0, 0, 138, 930, 1, 0, 0, 0, 140, 932,
		1, 0, 0, 0, 142, 936, 1, 0, 0, 0, 144, 942, 1, 0, 0, 0, 146, 987, 1, 0,
		0, 0, 148, 989, 1, 0, 0, 0, 150, 991, 1, 0, 0, 0, 152, 1003, 1, 0, 0, 0,
		154, 1009, 1, 0, 0, 0, 156, 1017, 1, 0, 0, 0, 158, 1020, 1, 0, 0, 0, 160,
		1029, 1, 0, 0, 0, 162, 1043, 1, 0, 0, 0, 164, 1048, 1, 0, 0, 0, 166, 1061,
		1, 0, 0, 0, 168, 1075, 1, 0, 0, 0, 170, 1190, 1, 0, 0, 0, 172, 1192, 1,
		0, 0, 0, 174, 1205, 1, 0, 0, 0, 176, 1213, 1, 0, 0, 0, 178, 1216, 1, 0,
		0, 0, 180, 1223, 1, 0, 0, 0, 182, 1248, 1, 0, 0, 0, 184, 1251, 1, 0, 0,
		0, 186, 1271, 1, 0, 0, 0, 188, 1285, 1, 0, 0, 0, 190, 1289, 1, 0, 0, 0,
		192, 1294, 1, 0, 0, 0, 194, 1305, 1, 0, 0, 0, 196, 1309, 1, 0, 0, 0, 198,
		1336, 1, 0, 0, 0, 200, 1383, 1, 0, 0, 0, 202, 1474, 1, 0, 0, 0, 204, 1486,
		1, 0, 0, 0, 206, 1512, 1, 0, 0, 0, 208, 1516, 1, 0, 0, 0, 210, 1536, 1,
		0, 0, 0, 212, 1538, 1, 0, 0, 0, 214, 1560, 1, 0, 0, 0, 216, 1588, 1, 0,
		0, 0, 218, 1605, 1, 0, 0, 0, 220, 1610, 1, 0, 0, 0, 222, 1631, 1, 0, 0,
		0, 224, 1648, 1, 0, 0, 0, 226, 1650, 1, 0, 0, 0, 228, 1656, 1, 0, 0, 0,
		230, 1686, 1, 0, 0, 0, 232, 1690, 1, 0, 0, 0, 234, 1696, 1, 0, 0, 0, 236,
		1701, 1, 0, 0, 0, 238, 1703, 1, 0, 0, 0, 240, 1707, 1, 0, 0, 0, 242, 1718,
		1, 0, 0, 0, 244, 1738, 1, 0, 0, 0, 246, 1740, 1, 0, 0, 0, 248, 1760, 1,
		0, 0, 0, 250, 1767, 1, 0, 0, 0, 252, 1769, 1, 0, 0, 0, 254, 256, 3, 2,
		1, 0, 255, 254, 1, 0, 0, 0, 255, 256, 1, 0, 0, 0, 256, 260, 1, 0, 0, 0,
		257, 259, 3, 4, 2, 0, 258, 257, 1, 0, 0, 0, 259, 262, 1, 0, 0, 0, 260,
		258, 1, 0, 0, 0, 260, 261, 1, 0, 0, 0, 261, 266, 1, 0, 0, 0, 262, 260,
		1, 0, 0, 0, 263, 265, 3, 6, 3, 0, 264, 263, 1, 0, 0, 0, 265, 268, 1, 0,
		0, 0, 266, 264, 1, 0, 0, 0, 266, 267, 1, 0, 0, 0, 267, 273, 1, 0, 0, 0,
		268, 266, 1, 0, 0, 0, 269, 270, 3, 142, 71, 0, 270, 271, 5, 0, 0, 1, 271,
		273, 1, 0, 0, 0, 272, 255, 1, 0, 0, 0, 272, 269, 1, 0, 0, 0, 273, 1, 1,
		0, 0, 0, 274, 276, 3, 116, 58, 0, 275, 274, 1, 0, 0, 0, 276, 279, 1, 0,
		0, 0, 277, 275, 1, 0, 0, 0, 277, 278, 1, 0, 0, 0, 278, 280, 1, 0, 0, 0,
		279, 277, 1, 0, 0, 0, 280, 281, 5, 32, 0, 0, 281, 282, 3, 106, 53, 0, 282,
		283, 5, 84, 0, 0, 283, 3, 1, 0, 0, 0, 284, 286, 5, 25, 0, 0, 285, 287,
		5, 38, 0, 0, 286, 285, 1, 0, 0, 0, 286, 287, 1, 0, 0, 0, 287, 288, 1, 0,
		0, 0, 288, 291, 3, 106, 53, 0, 289, 290, 5, 86, 0, 0, 290, 292, 5, 104,
		0, 0, 291, 289, 1, 0, 0, 0, 291, 292, 1, 0, 0, 0, 292, 293, 1, 0, 0, 0,
		293, 294, 5, 84, 0, 0, 294, 5, 1, 0, 0, 0, 295, 297, 3, 10, 5, 0, 296,
		295, 1, 0, 0, 0, 297, 300, 1, 0, 0, 0, 298, 296, 1, 0, 0, 0, 298, 299,
		1, 0, 0, 0, 299, 306, 1, 0, 0, 0, 300, 298, 1, 0, 0, 0, 301, 307, 3, 14,
		7, 0, 302, 307, 3, 28, 14, 0, 303, 307, 3, 36, 18, 0, 304, 307, 3, 126,
		63, 0, 305, 307, 3, 150, 75, 0, 306, 301, 1, 0, 0, 0, 306, 302, 1, 0, 0,
		0, 306, 303, 1, 0, 0, 0, 306, 304, 1, 0, 0, 0, 306, 305, 1, 0, 0, 0, 307,
		310, 1, 0, 0, 0, 308, 310, 5, 84, 0, 0, 309, 298, 1, 0, 0, 0, 309, 308,
		1, 0, 0, 0, 310, 7, 1, 0, 0, 0, 311, 317, 3, 10, 5, 0, 312, 317, 5, 30,
		0, 0, 313, 317, 5, 42, 0, 0, 314, 317, 5, 46, 0, 0, 315, 317, 5, 49, 0,
		0, 316, 311, 1, 0, 0, 0, 316, 312, 1, 0, 0, 0, 316, 313, 1, 0, 0, 0, 316,
		314, 1, 0, 0, 0, 316, 315, 1, 0, 0, 0, 317, 9, 1, 0, 0, 0, 318, 329, 3,
		116, 58, 0, 319, 329, 5, 35, 0, 0, 320, 329, 5, 34, 0, 0, 321, 329, 5,
		33, 0, 0, 322, 329, 5, 38, 0, 0, 323, 329, 5, 1, 0, 0, 324, 329, 5, 18,
		0, 0, 325, 329, 5, 39, 0, 0, 326, 329, 5, 64, 0, 0, 327, 329, 5, 66, 0,
		0, 328, 318, 1, 0, 0, 0, 328, 319, 1, 0, 0, 0, 328, 320, 1, 0, 0, 0, 328,
		321, 1, 0, 0, 0, 328, 322, 1, 0, 0, 0, 328, 323, 1, 0, 0, 0, 328, 324,
		1, 0, 0, 0, 328, 325, 1, 0, 0, 0, 328, 326, 1, 0, 0, 0, 328, 327, 1, 0,
		0, 0, 329, 11, 1, 0, 0, 0, 330, 333, 5, 18, 0, 0, 331, 333, 3, 116, 58,
		0, 332, 330, 1, 0, 0, 0, 332, 331, 1, 0, 0, 0, 333, 13, 1, 0, 0, 0, 334,
		335, 5, 9, 0, 0, 335, 337, 3, 166, 83, 0, 336, 338, 3, 22, 11, 0, 337,
		336, 1, 0, 0, 0, 337, 338, 1, 0, 0, 0, 338, 340, 1, 0, 0, 0, 339, 341,
		3, 16, 8, 0, 340, 339, 1, 0, 0, 0, 340, 341, 1, 0, 0, 0, 341, 343, 1, 0,
		0, 0, 342, 344, 3, 18, 9, 0, 343, 342, 1, 0, 0, 0, 343, 344, 1, 0, 0, 0,
		344, 346, 1, 0, 0, 0, 345, 347, 3, 20, 10, 0, 346, 345, 1, 0, 0, 0, 346,
		347, 1, 0, 0, 0, 347, 348, 1, 0, 0, 0, 348, 349, 3, 38, 19, 0, 349, 15,
		1, 0, 0, 0, 350, 351, 5, 17, 0, 0, 351, 352, 3, 242, 121, 0, 352, 17, 1,
		0, 0, 0, 353, 354, 5, 24, 0, 0, 354, 355, 3, 240, 120, 0, 355, 19, 1, 0,
		0, 0, 356, 357, 5, 65, 0, 0, 357, 358, 3, 240, 120, 0, 358, 21, 1, 0, 0,
		0, 359, 360, 5, 89, 0, 0, 360, 365, 3, 24, 12, 0, 361, 362, 5, 85, 0, 0,
		362, 364, 3, 24, 12, 0, 363, 361, 1, 0, 0, 0, 364, 367, 1, 0, 0, 0, 365,
		363, 1, 0, 0, 0, 365, 366, 1, 0, 0, 0, 366, 368, 1, 0, 0, 0, 367, 365,
		1, 0, 0, 0, 368, 369, 5, 88, 0, 0, 369, 23, 1, 0, 0, 0, 370, 372, 3, 116,
		58, 0, 371, 370, 1, 0, 0, 0, 372, 375, 1, 0, 0, 0, 373, 371, 1, 0, 0, 0,
		373, 374, 1, 0, 0, 0, 374, 376, 1, 0, 0, 0, 375, 373, 1, 0, 0, 0, 376,
		385, 3, 166, 83, 0, 377, 381, 5, 17, 0, 0, 378, 380, 3, 116, 58, 0, 379,
		378, 1, 0, 0, 0, 380, 383, 1, 0, 0, 0, 381, 379, 1, 0, 0, 0, 381, 382,
		1, 0, 0, 0, 382, 384, 1, 0, 0, 0, 383, 381, 1, 0, 0, 0, 384, 386, 3, 26,
		13, 0, 385, 377, 1, 0, 0, 0, 385, 386, 1, 0, 0, 0, 386, 25, 1, 0, 0, 0,
		387, 392, 3, 242, 121, 0, 388, 389, 5, 106, 0, 0, 389, 391, 3, 242, 121,
		0, 390, 388, 1, 0, 0, 0, 391, 394, 1, 0, 0, 0, 392, 390, 1, 0, 0, 0, 392,
		393, 1, 0, 0, 0, 393, 27, 1, 0, 0, 0, 394, 392, 1, 0, 0, 0, 395, 396, 5,
		16, 0, 0, 396, 399, 3, 166, 83, 0, 397, 398, 5, 24, 0, 0, 398, 400, 3,
		240, 120, 0, 399, 397, 1, 0, 0, 0, 399, 400, 1, 0, 0, 0, 400, 401, 1, 0,
		0, 0, 401, 403, 5, 80, 0, 0, 402, 404, 3, 30, 15, 0, 403, 402, 1, 0, 0,
		0, 403, 404, 1, 0, 0, 0, 404, 406, 1, 0, 0, 0, 405, 407, 5, 85, 0, 0, 406,
		405, 1, 0, 0, 0, 406, 407, 1, 0, 0, 0, 407, 409, 1, 0, 0, 0, 408, 410,
		3, 34, 17, 0, 409, 408, 1, 0, 0, 0, 409, 410, 1, 0, 0, 0, 410, 411, 1,
		0, 0, 0, 411, 412, 5, 81, 0, 0, 412, 29, 1, 0, 0, 0, 413, 418, 3, 32, 16,
		0, 414, 415, 5, 85, 0, 0, 415, 417, 3, 32, 16, 0, 416, 414, 1, 0, 0, 0,
		417, 420, 1, 0, 0, 0, 418, 416, 1, 0, 0, 0, 418, 419, 1, 0, 0, 0, 419,
		31, 1, 0, 0, 0, 420, 418, 1, 0, 0, 0, 421, 423, 3, 116, 58, 0, 422, 421,
		1, 0, 0, 0, 423, 426, 1, 0, 0, 0, 424, 422, 1, 0, 0, 0, 424, 425, 1, 0,
		0, 0, 425, 427, 1, 0, 0, 0, 426, 424, 1, 0, 0, 0, 427, 429, 3, 166, 83,
		0, 428, 430, 3, 252, 126, 0, 429, 428, 1, 0, 0, 0, 429, 430, 1, 0, 0, 0,
		430, 432, 1, 0, 0, 0, 431, 433, 3, 38, 19, 0, 432, 431, 1, 0, 0, 0, 432,
		433, 1, 0, 0, 0, 433, 33, 1, 0, 0, 0, 434, 438, 5, 84, 0, 0, 435, 437,
		3, 42, 21, 0, 436, 435, 1, 0, 0, 0, 437, 440, 1, 0, 0, 0, 438, 436, 1,
		0, 0, 0, 438, 439, 1, 0, 0, 0, 439, 35, 1, 0, 0, 0, 440, 438, 1, 0, 0,
		0, 441, 442, 5, 28, 0, 0, 442, 444, 3, 166, 83, 0, 443, 445, 3, 22, 11,
		0, 444, 443, 1, 0, 0, 0, 444, 445, 1, 0, 0, 0, 445, 448, 1, 0, 0, 0, 446,
		447, 5, 17, 0, 0, 447, 449, 3, 240, 120, 0, 448, 446, 1, 0, 0, 0, 448,
		449, 1, 0, 0, 0, 449, 452, 1, 0, 0, 0, 450, 451, 5, 65, 0, 0, 451, 453,
		3, 240, 120, 0, 452, 450, 1, 0, 0, 0, 452, 453, 1, 0, 0, 0, 453, 454, 1,
		0, 0, 0, 454, 455, 3, 40, 20, 0, 455, 37, 1, 0, 0, 0, 456, 460, 5, 80,
		0, 0, 457, 459, 3, 42, 21, 0, 458, 457, 1, 0, 0, 0, 459, 462, 1, 0, 0,
		0, 460, 458, 1, 0, 0, 0, 460, 461, 1, 0, 0, 0, 461, 463, 1, 0, 0, 0, 462,
		460, 1, 0, 0, 0, 463, 464, 5, 81, 0, 0, 464, 39, 1, 0, 0, 0, 465, 469,
		5, 80, 0, 0, 466, 468, 3, 60, 30, 0, 467, 466, 1, 0, 0, 0, 468, 471, 1,
		0, 0, 0, 469, 467, 1, 0, 0, 0, 469, 470, 1, 0, 0, 0, 470, 472, 1, 0, 0,
		0, 471, 469, 1, 0, 0, 0, 472, 473, 5, 81, 0, 0, 473, 41, 1, 0, 0, 0, 474,
		487, 5, 84, 0, 0, 475, 477, 5, 38, 0, 0, 476, 475, 1, 0, 0, 0, 476, 477,
		1, 0, 0, 0, 477, 478, 1, 0, 0, 0, 478, 487, 3, 160, 80, 0, 479, 481, 3,
		8, 4, 0, 480, 479, 1, 0, 0, 0, 481, 484, 1, 0, 0, 0, 482, 480, 1, 0, 0,
		0, 482, 483, 1, 0, 0, 0, 483, 485, 1, 0, 0, 0, 484, 482, 1, 0, 0, 0, 485,
		487, 3, 44, 22, 0, 486, 474, 1, 0, 0, 0, 486, 476, 1, 0, 0, 0, 486, 482,
		1, 0, 0, 0, 487, 43, 1, 0, 0, 0, 488, 499, 3, 46, 23, 0, 489, 499, 3, 52,
		26, 0, 490, 499, 3, 58, 29, 0, 491, 499, 3, 56, 28, 0, 492, 499, 3, 54,
		27, 0, 493, 499, 3, 36, 18, 0, 494, 499, 3, 126, 63, 0, 495, 499, 3, 14,
		7, 0, 496, 499, 3, 28, 14, 0, 497, 499, 3, 150, 75, 0, 498, 488, 1, 0,
		0, 0, 498, 489, 1, 0, 0, 0, 498, 490, 1, 0, 0, 0, 498, 491, 1, 0, 0, 0,
		498, 492, 1, 0, 0, 0, 498, 493, 1, 0, 0, 0, 498, 494, 1, 0, 0, 0, 498,
		495, 1, 0, 0, 0, 498, 496, 1, 0, 0, 0, 498, 497, 1, 0, 0, 0, 499, 45, 1,
		0, 0, 0, 500, 501, 3, 50, 25, 0, 501, 502, 3, 166, 83, 0, 502, 507, 3,
		92, 46, 0, 503, 504, 5, 82, 0, 0, 504, 506, 5, 83, 0, 0, 505, 503, 1, 0,
		0, 0, 506, 509, 1, 0, 0, 0, 507, 505, 1, 0, 0, 0, 507, 508, 1, 0, 0, 0,
		508, 512, 1, 0, 0, 0, 509, 507, 1, 0, 0, 0, 510, 511, 5, 45, 0, 0, 511,
		513, 3, 90, 45, 0, 512, 510, 1, 0, 0, 0, 512, 513, 1, 0, 0, 0, 513, 514,
		1, 0, 0, 0, 514, 515, 3, 48, 24, 0, 515, 47, 1, 0, 0, 0, 516, 519, 3, 160,
		80, 0, 517, 519, 5, 84, 0, 0, 518, 516, 1, 0, 0, 0, 518, 517, 1, 0, 0,
		0, 519, 49, 1, 0, 0, 0, 520, 523, 3, 242, 121, 0, 521, 523, 5, 48, 0, 0,
		522, 520, 1, 0, 0, 0, 522, 521, 1, 0, 0, 0, 523, 51, 1, 0, 0, 0, 524, 525,
		3, 22, 11, 0, 525, 526, 3, 46, 23, 0, 526, 53, 1, 0, 0, 0, 527, 528, 3,
		22, 11, 0, 528, 529, 3, 56, 28, 0, 529, 55, 1, 0, 0, 0, 530, 531, 3, 166,
		83, 0, 531, 534, 3, 92, 46, 0, 532, 533, 5, 45, 0, 0, 533, 535, 3, 90,
		45, 0, 534, 532, 1, 0, 0, 0, 534, 535, 1, 0, 0, 0, 535, 536, 1, 0, 0, 0,
		536, 537, 3, 160, 80, 0, 537, 57, 1, 0, 0, 0, 538, 539, 3, 242, 121, 0,
		539, 540, 3, 76, 38, 0, 540, 541, 5, 84, 0, 0, 541, 59, 1, 0, 0, 0, 542,
		544, 3, 8, 4, 0, 543, 542, 1, 0, 0, 0, 544, 547, 1, 0, 0, 0, 545, 543,
		1, 0, 0, 0, 545, 546, 1, 0, 0, 0, 546, 548, 1, 0, 0, 0, 547, 545, 1, 0,
		0, 0, 548, 551, 3, 62, 31, 0, 549, 551, 5, 84, 0, 0, 550, 545, 1, 0, 0,
		0, 550, 549, 1, 0, 0, 0, 551, 61, 1, 0, 0, 0, 552, 561, 3, 64, 32, 0, 553,
		561, 3, 68, 34, 0, 554, 561, 3, 72, 36, 0, 555, 561, 3, 36, 18, 0, 556,
		561, 3, 126, 63, 0, 557, 561, 3, 14, 7, 0, 558, 561, 3, 28, 14, 0, 559,
		561, 3, 150, 75, 0, 560, 552, 1, 0, 0, 0, 560, 553, 1, 0, 0, 0, 560, 554,
		1, 0, 0, 0, 560, 555, 1, 0, 0, 0, 560, 556, 1, 0, 0, 0, 560, 557, 1, 0,
		0, 0, 560, 558, 1, 0, 0, 0, 560, 559, 1, 0, 0, 0, 561, 63, 1, 0, 0, 0,
		562, 563, 3, 242, 121, 0, 563, 568, 3, 66, 33, 0, 564, 565, 5, 85, 0, 0,
		565, 567, 3, 66, 33, 0, 566, 564, 1, 0, 0, 0, 567, 570, 1, 0, 0, 0, 568,
		566, 1, 0, 0, 0, 568, 569, 1, 0, 0, 0, 569, 571, 1, 0, 0, 0, 570, 568,
		1, 0, 0, 0, 571, 572, 5, 84, 0, 0, 572, 65, 1, 0, 0, 0, 573, 578, 3, 166,
		83, 0, 574, 575, 5, 82, 0, 0, 575, 577, 5, 83, 0, 0, 576, 574, 1, 0, 0,
		0, 577, 580, 1, 0, 0, 0, 578, 576, 1, 0, 0, 0, 578, 579, 1, 0, 0, 0, 579,
		581, 1, 0, 0, 0, 580, 578, 1, 0, 0, 0, 581, 582, 5, 87, 0, 0, 582, 583,
		3, 82, 41, 0, 583, 67, 1, 0, 0, 0, 584, 586, 3, 70, 35, 0, 585, 584, 1,
		0, 0, 0, 586, 589, 1, 0, 0, 0, 587, 585, 1, 0, 0, 0, 587, 588, 1, 0, 0,
		0, 588, 590, 1, 0, 0, 0, 589, 587, 1, 0, 0, 0, 590, 591, 3, 74, 37, 0,
		591, 69, 1, 0, 0, 0, 592, 599, 3, 116, 58, 0, 593, 599, 5, 35, 0, 0, 594,
		599, 5, 1, 0, 0, 595, 599, 5, 12, 0, 0, 596, 599, 5, 38, 0, 0, 597, 599,
		5, 39, 0, 0, 598, 592, 1, 0, 0, 0, 598, 593, 1, 0, 0, 0, 598, 594, 1, 0,
		0, 0, 598, 595, 1, 0, 0, 0, 598, 596, 1, 0, 0, 0, 598, 597, 1, 0, 0, 0,
		599, 71, 1, 0, 0, 0, 600, 602, 3, 70, 35, 0, 601, 600, 1, 0, 0, 0, 602,
		605, 1, 0, 0, 0, 603, 601, 1, 0, 0, 0, 603, 604, 1, 0, 0, 0, 604, 606,
		1, 0, 0, 0, 605, 603, 1, 0, 0, 0, 606, 607, 3, 22, 11, 0, 607, 608, 3,
		74, 37, 0, 608, 73, 1, 0, 0, 0, 609, 611, 3, 116, 58, 0, 610, 609, 1, 0,
		0, 0, 611, 614, 1, 0, 0, 0, 612, 610, 1, 0, 0, 0, 612, 613, 1, 0, 0, 0,
		613, 615, 1, 0, 0, 0, 614, 612, 1, 0, 0, 0, 615, 616, 3, 50, 25, 0, 616,
		617, 3, 166, 83, 0, 617, 622, 3, 92, 46, 0, 618, 619, 5, 82, 0, 0, 619,
		621, 5, 83, 0, 0, 620, 618, 1, 0, 0, 0, 621, 624, 1, 0, 0, 0, 622, 620,
		1, 0, 0, 0, 622, 623, 1, 0, 0, 0, 623, 627, 1, 0, 0, 0, 624, 622, 1, 0,
		0, 0, 625, 626, 5, 45, 0, 0, 626, 628, 3, 90, 45, 0, 627, 625, 1, 0, 0,
		0, 627, 628, 1, 0, 0, 0, 628, 629, 1, 0, 0, 0, 629, 630, 3, 48, 24, 0,
		630, 75, 1, 0, 0, 0, 631, 636, 3, 78, 39, 0, 632, 633, 5, 85, 0, 0, 633,
		635, 3, 78, 39, 0, 634, 632, 1, 0, 0, 0, 635, 638, 1, 0, 0, 0, 636, 634,
		1, 0, 0, 0, 636, 637, 1, 0, 0, 0, 637, 77, 1, 0, 0, 0, 638, 636, 1, 0,
		0, 0, 639, 642, 3, 80, 40, 0, 640, 641, 5, 87, 0, 0, 641, 643, 3, 82, 41,
		0, 642, 640, 1, 0, 0, 0, 642, 643, 1, 0, 0, 0, 643, 79, 1, 0, 0, 0, 644,
		649, 3, 166, 83, 0, 645, 646, 5, 82, 0, 0, 646, 648, 5, 83, 0, 0, 647,
		645, 1, 0, 0, 0, 648, 651, 1, 0, 0, 0, 649, 647, 1, 0, 0, 0, 649, 650,
		1, 0, 0, 0, 650, 81, 1, 0, 0, 0, 651, 649, 1, 0, 0, 0, 652, 655, 3, 84,
		42, 0, 653, 655, 3, 200, 100, 0, 654, 652, 1, 0, 0, 0, 654, 653, 1, 0,
		0, 0, 655, 83, 1, 0, 0, 0, 656, 668, 5, 80, 0, 0, 657, 662, 3, 82, 41,
		0, 658, 659, 5, 85, 0, 0, 659, 661, 3, 82, 41, 0, 660, 658, 1, 0, 0, 0,
		661, 664, 1, 0, 0, 0, 662, 660, 1, 0, 0, 0, 662, 663, 1, 0, 0, 0, 663,
		666, 1, 0, 0, 0, 664, 662, 1, 0, 0, 0, 665, 667, 5, 85, 0, 0, 666, 665,
		1, 0, 0, 0, 666, 667, 1, 0, 0, 0, 667, 669, 1, 0, 0, 0, 668, 657, 1, 0,
		0, 0, 668, 669, 1, 0, 0, 0, 669, 670, 1, 0, 0, 0, 670, 671, 5, 81, 0, 0,
		671, 85, 1, 0, 0, 0, 672, 674, 3, 166, 83, 0, 673, 675, 3, 246, 123, 0,
		674, 673, 1, 0, 0, 0, 674, 675, 1, 0, 0, 0, 675, 683, 1, 0, 0, 0, 676,
		677, 5, 86, 0, 0, 677, 679, 3, 166, 83, 0, 678, 680, 3, 246, 123, 0, 679,
		678, 1, 0, 0, 0, 679, 680, 1, 0, 0, 0, 680, 682, 1, 0, 0, 0, 681, 676,
		1, 0, 0, 0, 682, 685, 1, 0, 0, 0, 683, 681, 1, 0, 0, 0, 683, 684, 1, 0,
		0, 0, 684, 87, 1, 0, 0, 0, 685, 683, 1, 0, 0, 0, 686, 699, 3, 242, 121,
		0, 687, 689, 3, 116, 58, 0, 688, 687, 1, 0, 0, 0, 689, 692, 1, 0, 0, 0,
		690, 688, 1, 0, 0, 0, 690, 691, 1, 0, 0, 0, 691, 693, 1, 0, 0, 0, 692,
		690, 1, 0, 0, 0, 693, 696, 5, 92, 0, 0, 694, 695, 7, 0, 0, 0, 695, 697,
		3, 242, 121, 0, 696, 694, 1, 0, 0, 0, 696, 697, 1, 0, 0, 0, 697, 699, 1,
		0, 0, 0, 698, 686, 1, 0, 0, 0, 698, 690, 1, 0, 0, 0, 699, 89, 1, 0, 0,
		0, 700, 705, 3, 106, 53, 0, 701, 702, 5, 85, 0, 0, 702, 704, 3, 106, 53,
		0, 703, 701, 1, 0, 0, 0, 704, 707, 1, 0, 0, 0, 705, 703, 1, 0, 0, 0, 705,
		706, 1, 0, 0, 0, 706, 91, 1, 0, 0, 0, 707, 705, 1, 0, 0, 0, 708, 720, 5,
		78, 0, 0, 709, 711, 3, 94, 47, 0, 710, 709, 1, 0, 0, 0, 710, 711, 1, 0,
		0, 0, 711, 721, 1, 0, 0, 0, 712, 715, 3, 94, 47, 0, 713, 714, 5, 85, 0,
		0, 714, 716, 3, 96, 48, 0, 715, 713, 1, 0, 0, 0, 715, 716, 1, 0, 0, 0,
		716, 721, 1, 0, 0, 0, 717, 719, 3, 96, 48, 0, 718, 717, 1, 0, 0, 0, 718,
		719, 1, 0, 0, 0, 719, 721, 1, 0, 0, 0, 720, 710, 1, 0, 0, 0, 720, 712,
		1, 0, 0, 0, 720, 718, 1, 0, 0, 0, 721, 722, 1, 0, 0, 0, 722, 723, 5, 79,
		0, 0, 723, 93, 1, 0, 0, 0, 724, 730, 3, 242, 121, 0, 725, 726, 3, 166,
		83, 0, 726, 727, 5, 86, 0, 0, 727, 729, 1, 0, 0, 0, 728, 725, 1, 0, 0,
		0, 729, 732, 1, 0, 0, 0, 730, 728, 1, 0, 0, 0, 730, 731, 1, 0, 0, 0, 731,
		733, 1, 0, 0, 0, 732, 730, 1, 0, 0, 0, 733, 734, 5, 43, 0, 0, 734, 95,
		1, 0, 0, 0, 735, 740, 3, 98, 49, 0, 736, 737, 5, 85, 0, 0, 737, 739, 3,
		98, 49, 0, 738, 736, 1, 0, 0, 0, 739, 742, 1, 0, 0, 0, 740, 738, 1, 0,
		0, 0, 740, 741, 1, 0, 0, 0, 741, 745, 1, 0, 0, 0, 742, 740, 1, 0, 0, 0,
		743, 744, 5, 85, 0, 0, 744, 746, 3, 100, 50, 0, 745, 743, 1, 0, 0, 0, 745,
		746, 1, 0, 0, 0, 746, 749, 1, 0, 0, 0, 747, 749, 3, 100, 50, 0, 748, 735,
		1, 0, 0, 0, 748, 747, 1, 0, 0, 0, 749, 97, 1, 0, 0, 0, 750, 752, 3, 12,
		6, 0, 751, 750, 1, 0, 0, 0, 752, 755, 1, 0, 0, 0, 753, 751, 1, 0, 0, 0,
		753, 754, 1, 0, 0, 0, 754, 756, 1, 0, 0, 0, 755, 753, 1, 0, 0, 0, 756,
		757, 3, 242, 121, 0, 757, 758, 3, 80, 40, 0, 758, 99, 1, 0, 0, 0, 759,
		761, 3, 12, 6, 0, 760, 759, 1, 0, 0, 0, 761, 764, 1, 0, 0, 0, 762, 760,
		1, 0, 0, 0, 762, 763, 1, 0, 0, 0, 763, 765, 1, 0, 0, 0, 764, 762, 1, 0,
		0, 0, 765, 769, 3, 242, 121, 0, 766, 768, 3, 116, 58, 0, 767, 766, 1, 0,
		0, 0, 768, 771, 1, 0, 0, 0, 769, 767, 1, 0, 0, 0, 769, 770, 1, 0, 0, 0,
		770, 772, 1, 0, 0, 0, 771, 769, 1, 0, 0, 0, 772, 773, 5, 124, 0, 0, 773,
		774, 3, 80, 40, 0, 774, 101, 1, 0, 0, 0, 775, 780, 3, 104, 52, 0, 776,
		777, 5, 85, 0, 0, 777, 779, 3, 104, 52, 0, 778, 776, 1, 0, 0, 0, 779, 782,
		1, 0, 0, 0, 780, 778, 1, 0, 0, 0, 780, 781, 1, 0, 0, 0, 781, 103, 1, 0,
		0, 0, 782, 780, 1, 0, 0, 0, 783, 785, 3, 12, 6, 0, 784, 783, 1, 0, 0, 0,
		785, 788, 1, 0, 0, 0, 786, 784, 1, 0, 0, 0, 786, 787, 1, 0, 0, 0, 787,
		789, 1, 0, 0, 0, 788, 786, 1, 0, 0, 0, 789, 790, 5, 61, 0, 0, 790, 791,
		3, 166, 83, 0, 791, 105, 1, 0, 0, 0, 792, 797, 3, 166, 83, 0, 793, 794,
		5, 86, 0, 0, 794, 796, 3, 166, 83, 0, 795, 793, 1, 0, 0, 0, 796, 799, 1,
		0, 0, 0, 797, 795, 1, 0, 0, 0, 797, 798, 1, 0, 0, 0, 798, 107, 1, 0, 0,
		0, 799, 797, 1, 0, 0, 0, 800, 808, 3, 110, 55, 0, 801, 808, 3, 112, 56,
		0, 802, 808, 5, 74, 0, 0, 803, 808, 5, 75, 0, 0, 804, 808, 5, 73, 0, 0,
		805, 808, 5, 77, 0, 0, 806, 808, 5, 76, 0, 0, 807, 800, 1, 0, 0, 0, 807,
		801, 1, 0, 0, 0, 807, 802, 1, 0, 0, 0, 807, 803, 1, 0, 0, 0, 807, 804,
		1, 0, 0, 0, 807, 805, 1, 0, 0, 0, 807, 806, 1, 0, 0, 0, 808, 109, 1, 0,
		0, 0, 809, 810, 7, 1, 0, 0, 810, 111, 1, 0, 0, 0, 811, 812, 7, 2, 0, 0,
		812, 113, 1, 0, 0, 0, 813, 814, 3, 166, 83, 0, 814, 815, 5, 86, 0, 0, 815,
		817, 1, 0, 0, 0, 816, 813, 1, 0, 0, 0, 817, 820, 1, 0, 0, 0, 818, 816,
		1, 0, 0, 0, 818, 819, 1, 0, 0, 0, 819, 821, 1, 0, 0, 0, 820, 818, 1, 0,
		0, 0, 821, 822, 5, 123, 0, 0, 822, 823, 3, 166, 83, 0, 823, 115, 1, 0,
		0, 0, 824, 825, 5, 123, 0, 0, 825, 828, 3, 106, 53, 0, 826, 828, 3, 114,
		57, 0, 827, 824, 1, 0, 0, 0, 827, 826, 1, 0, 0, 0, 828, 835, 1, 0, 0, 0,
		829, 832, 5, 78, 0, 0, 830, 833, 3, 118, 59, 0, 831, 833, 3, 122, 61, 0,
		832, 830, 1, 0, 0, 0, 832, 831, 1, 0, 0, 0, 832, 833, 1, 0, 0, 0, 833,
		834, 1, 0, 0, 0, 834, 836, 5, 79, 0, 0, 835, 829, 1, 0, 0, 0, 835, 836,
		1, 0, 0, 0, 836, 117, 1, 0, 0, 0, 837, 842, 3, 120, 60, 0, 838, 839, 5,
		85, 0, 0, 839, 841, 3, 120, 60, 0, 840, 838, 1, 0, 0, 0, 841, 844, 1, 0,
		0, 0, 842, 840, 1, 0, 0, 0, 842, 843, 1, 0, 0, 0, 843, 119, 1, 0, 0, 0,
		844, 842, 1, 0, 0, 0, 845, 846, 3, 166, 83, 0, 846, 847, 5, 87, 0, 0, 847,
		848, 3, 122, 61, 0, 848, 121, 1, 0, 0, 0, 849, 853, 3, 200, 100, 0, 850,
		853, 3, 116, 58, 0, 851, 853, 3, 124, 62, 0, 852, 849, 1, 0, 0, 0, 852,
		850, 1, 0, 0, 0, 852, 851, 1, 0, 0, 0, 853, 123, 1, 0, 0, 0, 854, 863,
		5, 80, 0, 0, 855, 860, 3, 122, 61, 0, 856, 857, 5, 85, 0, 0, 857, 859,
		3, 122, 61, 0, 858, 856, 1, 0, 0, 0, 859, 862, 1, 0, 0, 0, 860, 858, 1,
		0, 0, 0, 860, 861, 1, 0, 0, 0, 861, 864, 1, 0, 0, 0, 862, 860, 1, 0, 0,
		0, 863, 855, 1, 0, 0, 0, 863, 864, 1, 0, 0, 0, 864, 866, 1, 0, 0, 0, 865,
		867, 5, 85, 0, 0, 866, 865, 1, 0, 0, 0, 866, 867, 1, 0, 0, 0, 867, 868,
		1, 0, 0, 0, 868, 869, 5, 81, 0, 0, 869, 125, 1, 0, 0, 0, 870, 871, 5, 123,
		0, 0, 871, 872, 5, 28, 0, 0, 872, 873, 3, 166, 83, 0, 873, 874, 3, 128,
		64, 0, 874, 127, 1, 0, 0, 0, 875, 879, 5, 80, 0, 0, 876, 878, 3, 130, 65,
		0, 877, 876, 1, 0, 0, 0, 878, 881, 1, 0, 0, 0, 879, 877, 1, 0, 0, 0, 879,
		880, 1, 0, 0, 0, 880, 882, 1, 0, 0, 0, 881, 879, 1, 0, 0, 0, 882, 883,
		5, 81, 0, 0, 883, 129, 1, 0, 0, 0, 884, 886, 3, 8, 4, 0, 885, 884, 1, 0,
		0, 0, 886, 889, 1, 0, 0, 0, 887, 885, 1, 0, 0, 0, 887, 888, 1, 0, 0, 0,
		888, 890, 1, 0, 0, 0, 889, 887, 1, 0, 0, 0, 890, 893, 3, 132, 66, 0, 891,
		893, 5, 84, 0, 0, 892, 887, 1, 0, 0, 0, 892, 891, 1, 0, 0, 0, 893, 131,
		1, 0, 0, 0, 894, 895, 3, 242, 121, 0, 895, 896, 3, 134, 67, 0, 896, 897,
		5, 84, 0, 0, 897, 919, 1, 0, 0, 0, 898, 900, 3, 14, 7, 0, 899, 901, 5,
		84, 0, 0, 900, 899, 1, 0, 0, 0, 900, 901, 1, 0, 0, 0, 901, 919, 1, 0, 0,
		0, 902, 904, 3, 36, 18, 0, 903, 905, 5, 84, 0, 0, 904, 903, 1, 0, 0, 0,
		904, 905, 1, 0, 0, 0, 905, 919, 1, 0, 0, 0, 906, 908, 3, 28, 14, 0, 907,
		909, 5, 84, 0, 0, 908, 907, 1, 0, 0, 0, 908, 909, 1, 0, 0, 0, 909, 919,
		1, 0, 0, 0, 910, 912, 3, 126, 63, 0, 911, 913, 5, 84, 0, 0, 912, 911, 1,
		0, 0, 0, 912, 913, 1, 0, 0, 0, 913, 919, 1, 0, 0, 0, 914, 916, 3, 150,
		75, 0, 915, 917, 5, 84, 0, 0, 916, 915, 1, 0, 0, 0, 916, 917, 1, 0, 0,
		0, 917, 919, 1, 0, 0, 0, 918, 894, 1, 0, 0, 0, 918, 898, 1, 0, 0, 0, 918,
		902, 1, 0, 0, 0, 918, 906, 1, 0, 0, 0, 918, 910, 1, 0, 0, 0, 918, 914,
		1, 0, 0, 0, 919, 133, 1, 0, 0, 0, 920, 923, 3, 136, 68, 0, 921, 923, 3,
		138, 69, 0, 922, 920, 1, 0, 0, 0, 922, 921, 1, 0, 0, 0, 923, 135, 1, 0,
		0, 0, 924, 925, 3, 166, 83, 0, 925, 926, 5, 78, 0, 0, 926, 928, 5, 79,
		0, 0, 927, 929, 3, 140, 70, 0, 928, 927, 1, 0, 0, 0, 928, 929, 1, 0, 0,
		0, 929, 137, 1, 0, 0, 0, 930, 931, 3, 76, 38, 0, 931, 139, 1, 0, 0, 0,
		932, 933, 5, 12, 0, 0, 933, 934, 3, 122, 61, 0, 934, 141, 1, 0, 0, 0, 935,
		937, 5, 52, 0, 0, 936, 935, 1, 0, 0, 0, 936, 937, 1, 0, 0, 0, 937, 938,
		1, 0, 0, 0, 938, 939, 5, 51, 0, 0, 939, 940, 3, 106, 53, 0, 940, 941, 3,
		144, 72, 0, 941, 143, 1, 0, 0, 0, 942, 946, 5, 80, 0, 0, 943, 945, 3, 146,
		73, 0, 944, 943, 1, 0, 0, 0, 945, 948, 1, 0, 0, 0, 946, 944, 1, 0, 0, 0,
		946, 947, 1, 0, 0, 0, 947, 949, 1, 0, 0, 0, 948, 946, 1, 0, 0, 0, 949,
		950, 5, 81, 0, 0, 950, 145, 1, 0, 0, 0, 951, 955, 5, 53, 0, 0, 952, 954,
		3, 148, 74, 0, 953, 952, 1, 0, 0, 0, 954, 957, 1, 0, 0, 0, 955, 953, 1,
		0, 0, 0, 955, 956, 1, 0, 0, 0, 956, 958, 1, 0, 0, 0, 957, 955, 1, 0, 0,
		0, 958, 959, 3, 106, 53, 0, 959, 960, 5, 84, 0, 0, 960, 988, 1, 0, 0, 0,
		961, 962, 5, 54, 0, 0, 962, 965, 3, 106, 53, 0, 963, 964, 5, 56, 0, 0,
		964, 966, 3, 106, 53, 0, 965, 963, 1, 0, 0, 0, 965, 966, 1, 0, 0, 0, 966,
		967, 1, 0, 0, 0, 967, 968, 5, 84, 0, 0, 968, 988, 1, 0, 0, 0, 969, 970,
		5, 55, 0, 0, 970, 973, 3, 106, 53, 0, 971, 972, 5, 56, 0, 0, 972, 974,
		3, 106, 53, 0, 973, 971, 1, 0, 0, 0, 973, 974, 1, 0, 0, 0, 974, 975, 1,
		0, 0, 0, 975, 976, 5, 84, 0, 0, 976, 988, 1, 0, 0, 0, 977, 978, 5, 57,
		0, 0, 978, 979, 3, 106, 53, 0, 979, 980, 5, 84, 0, 0, 980, 988, 1, 0, 0,
		0, 981, 982, 5, 58, 0, 0, 982, 983, 3, 106, 53, 0, 983, 984, 5, 59, 0,
		0, 984, 985, 3, 106, 53, 0, 985, 986, 5, 84, 0, 0, 986, 988, 1, 0, 0, 0,
		987, 951, 1, 0, 0, 0, 987, 961, 1, 0, 0, 0, 987, 969, 1, 0, 0, 0, 987,
		977, 1, 0, 0, 0, 987, 981, 1, 0, 0, 0, 988, 147, 1, 0, 0, 0, 989, 990,
		7, 3, 0, 0, 990, 149, 1, 0, 0, 0, 991, 992, 5, 63, 0, 0, 992, 994, 3, 166,
		83, 0, 993, 995, 3, 22, 11, 0, 994, 993, 1, 0, 0, 0, 994, 995, 1, 0, 0,
		0, 995, 996, 1, 0, 0, 0, 996, 999, 3, 152, 76, 0, 997, 998, 5, 24, 0, 0,
		998, 1000, 3, 240, 120, 0, 999, 997, 1, 0, 0, 0, 999, 1000, 1, 0, 0, 0,
		1000, 1001, 1, 0, 0, 0, 1001, 1002, 3, 158, 79, 0, 1002, 151, 1, 0, 0,
		0, 1003, 1005, 5, 78, 0, 0, 1004, 1006, 3, 154, 77, 0, 1005, 1004, 1, 0,
		0, 0, 1005, 1006, 1, 0, 0, 0, 1006, 1007, 1, 0, 0, 0, 1007, 1008, 5, 79,
		0, 0, 1008, 153, 1, 0, 0, 0, 1009, 1014, 3, 156, 78, 0, 1010, 1011, 5,
		85, 0, 0, 1011, 1013, 3, 156, 78, 0, 1012, 1010, 1, 0, 0, 0, 1013, 1016,
		1, 0, 0, 0, 1014, 1012, 1, 0, 0, 0, 1014, 1015, 1, 0, 0, 0, 1015, 155,
		1, 0, 0, 0, 1016, 1014, 1, 0, 0, 0, 1017, 1018, 3, 242, 121, 0, 1018, 1019,
		3, 166, 83, 0, 1019, 157, 1, 0, 0, 0, 1020, 1024, 5, 80, 0, 0, 1021, 1023,
		3, 42, 21, 0, 1022, 1021, 1, 0, 0, 0, 1023, 1026, 1, 0, 0, 0, 1024, 1022,
		1, 0, 0, 0, 1024, 1025, 1, 0, 0, 0, 1025, 1027, 1, 0, 0, 0, 1026, 1024,
		1, 0, 0, 0, 1027, 1028, 5, 81, 0, 0, 1028, 159, 1, 0, 0, 0, 1029, 1033,
		5, 80, 0, 0, 1030, 1032, 3, 162, 81, 0, 1031, 1030, 1, 0, 0, 0, 1032, 1035,
		1, 0, 0, 0, 1033, 1031, 1, 0, 0, 0, 1033, 1034, 1, 0, 0, 0, 1034, 1036,
		1, 0, 0, 0, 1035, 1033, 1, 0, 0, 0, 1036, 1037, 5, 81, 0, 0, 1037, 161,
		1, 0, 0, 0, 1038, 1039, 3, 164, 82, 0, 1039, 1040, 5, 84, 0, 0, 1040, 1044,
		1, 0, 0, 0, 1041, 1044, 3, 170, 85, 0, 1042, 1044, 3, 168, 84, 0, 1043,
		1038, 1, 0, 0, 0, 1043, 1041, 1, 0, 0, 0, 1043, 1042, 1, 0, 0, 0, 1044,
		163, 1, 0, 0, 0, 1045, 1047, 3, 12, 6, 0, 1046, 1045, 1, 0, 0, 0, 1047,
		1050, 1, 0, 0, 0, 1048, 1046, 1, 0, 0, 0, 1048, 1049, 1, 0, 0, 0, 1049,
		1059, 1, 0, 0, 0, 1050, 1048, 1, 0, 0, 0, 1051, 1052, 3, 242, 121, 0, 1052,
		1053, 3, 76, 38, 0, 1053, 1060, 1, 0, 0, 0, 1054, 1055, 5, 61, 0, 0, 1055,
		1056, 3, 166, 83, 0, 1056, 1057, 5, 87, 0, 0, 1057, 1058, 3, 200, 100,
		0, 1058, 1060, 1, 0, 0, 0, 1059, 1051, 1, 0, 0, 0, 1059, 1054, 1, 0, 0,
		0, 1060, 165, 1, 0, 0, 0, 1061, 1062, 7, 4, 0, 0, 1062, 167, 1, 0, 0, 0,
		1063, 1065, 3, 10, 5, 0, 1064, 1063, 1, 0, 0, 0, 1065, 1068, 1, 0, 0, 0,
		1066, 1064, 1, 0, 0, 0, 1066, 1067, 1, 0, 0, 0, 1067, 1072, 1, 0, 0, 0,
		1068, 1066, 1, 0, 0, 0, 1069, 1073, 3, 14, 7, 0, 1070, 1073, 3, 36, 18,
		0, 1071, 1073, 3, 150, 75, 0, 1072, 1069, 1, 0, 0, 0, 1072, 1070, 1, 0,
		0, 0, 1072, 1071, 1, 0, 0, 0, 1073, 1076, 1, 0, 0, 0, 1074, 1076, 5, 84,
		0, 0, 1075, 1066, 1, 0, 0, 0, 1075, 1074, 1, 0, 0, 0, 1076, 169, 1, 0,
		0, 0, 1077, 1191, 3, 160, 80, 0, 1078, 1079, 5, 2, 0, 0, 1079, 1082, 3,
		200, 100, 0, 1080, 1081, 5, 93, 0, 0, 1081, 1083, 3, 200, 100, 0, 1082,
		1080, 1, 0, 0, 0, 1082, 1083, 1, 0, 0, 0, 1083, 1084, 1, 0, 0, 0, 1084,
		1085, 5, 84, 0, 0, 1085, 1191, 1, 0, 0, 0, 1086, 1087, 5, 22, 0, 0, 1087,
		1088, 3, 194, 97, 0, 1088, 1091, 3, 170, 85, 0, 1089, 1090, 5, 15, 0, 0,
		1090, 1092, 3, 170, 85, 0, 1091, 1089, 1, 0, 0, 0, 1091, 1092, 1, 0, 0,
		0, 1092, 1191, 1, 0, 0, 0, 1093, 1094, 5, 21, 0, 0, 1094, 1095, 5, 78,
		0, 0, 1095, 1096, 3, 188, 94, 0, 1096, 1097, 5, 79, 0, 0, 1097, 1098, 3,
		170, 85, 0, 1098, 1191, 1, 0, 0, 0, 1099, 1100, 5, 50, 0, 0, 1100, 1101,
		3, 194, 97, 0, 1101, 1102, 3, 170, 85, 0, 1102, 1191, 1, 0, 0, 0, 1103,
		1104, 5, 13, 0, 0, 1104, 1105, 3, 170, 85, 0, 1105, 1106, 5, 50, 0, 0,
		1106, 1107, 3, 194, 97, 0, 1107, 1108, 5, 84, 0, 0, 1108, 1191, 1, 0, 0,
		0, 1109, 1110, 5, 47, 0, 0, 1110, 1120, 3, 160, 80, 0, 1111, 1113, 3, 172,
		86, 0, 1112, 1111, 1, 0, 0, 0, 1113, 1114, 1, 0, 0, 0, 1114, 1112, 1, 0,
		0, 0, 1114, 1115, 1, 0, 0, 0, 1115, 1117, 1, 0, 0, 0, 1116, 1118, 3, 176,
		88, 0, 1117, 1116, 1, 0, 0, 0, 1117, 1118, 1, 0, 0, 0, 1118, 1121, 1, 0,
		0, 0, 1119, 1121, 3, 176, 88, 0, 1120, 1112, 1, 0, 0, 0, 1120, 1119, 1,
		0, 0, 0, 1121, 1191, 1, 0, 0, 0, 1122, 1123, 5, 47, 0, 0, 1123, 1124, 3,
		178, 89, 0, 1124, 1128, 3, 160, 80, 0, 1125, 1127, 3, 172, 86, 0, 1126,
		1125, 1, 0, 0, 0, 1127, 1130, 1, 0, 0, 0, 1128, 1126, 1, 0, 0, 0, 1128,
		1129, 1, 0, 0, 0, 1129, 1132, 1, 0, 0, 0, 1130, 1128, 1, 0, 0, 0, 1131,
		1133, 3, 176, 88, 0, 1132, 1131, 1, 0, 0, 0, 1132, 1133, 1, 0, 0, 0, 1133,
		1191, 1, 0, 0, 0, 1134, 1135, 5, 41, 0, 0, 1135, 1136, 3, 194, 97, 0, 1136,
		1140, 5, 80, 0, 0, 1137, 1139, 3, 184, 92, 0, 1138, 1137, 1, 0, 0, 0, 1139,
		1142, 1, 0, 0, 0, 1140, 1138, 1, 0, 0, 0, 1140, 1141, 1, 0, 0, 0, 1141,
		1146, 1, 0, 0, 0, 1142, 1140, 1, 0, 0, 0, 1143, 1145, 3, 186, 93, 0, 1144,
		1143, 1, 0, 0, 0, 1145, 1148, 1, 0, 0, 0, 1146, 1144, 1, 0, 0, 0, 1146,
		1147, 1, 0, 0, 0, 1147, 1149, 1, 0, 0, 0, 1148, 1146, 1, 0, 0, 0, 1149,
		1150, 5, 81, 0, 0, 1150, 1191, 1, 0, 0, 0, 1151, 1152, 5, 42, 0, 0, 1152,
		1153, 3, 194, 97, 0, 1153, 1154, 3, 160, 80, 0, 1154, 1191, 1, 0, 0, 0,
		1155, 1157, 5, 36, 0, 0, 1156, 1158, 3, 200, 100, 0, 1157, 1156, 1, 0,
		0, 0, 1157, 1158, 1, 0, 0, 0, 1158, 1159, 1, 0, 0, 0, 1159, 1191, 5, 84,
		0, 0, 1160, 1161, 5, 44, 0, 0, 1161, 1162, 3, 200, 100, 0, 1162, 1163,
		5, 84, 0, 0, 1163, 1191, 1, 0, 0, 0, 1164, 1166, 5, 4, 0, 0, 1165, 1167,
		3, 166, 83, 0, 1166, 1165, 1, 0, 0, 0, 1166, 1167, 1, 0, 0, 0, 1167, 1168,
		1, 0, 0, 0, 1168, 1191, 5, 84, 0, 0, 1169, 1171, 5, 11, 0, 0, 1170, 1172,
		3, 166, 83, 0, 1171, 1170, 1, 0, 0, 0, 1171, 1172, 1, 0, 0, 0, 1172, 1173,
		1, 0, 0, 0, 1173, 1191, 5, 84, 0, 0, 1174, 1175, 5, 62, 0, 0, 1175, 1176,
		3, 200, 100, 0, 1176, 1177, 5, 84, 0, 0, 1177, 1191, 1, 0, 0, 0, 1178,
		1191, 5, 84, 0, 0, 1179, 1180, 3, 200, 100, 0, 1180, 1181, 5, 84, 0, 0,
		1181, 1191, 1, 0, 0, 0, 1182, 1184, 3, 212, 106, 0, 1183, 1185, 5, 84,
		0, 0, 1184, 1183, 1, 0, 0, 0, 1184, 1185, 1, 0, 0, 0, 1185, 1191, 1, 0,
		0, 0, 1186, 1187, 3, 166, 83, 0, 1187, 1188, 5, 93, 0, 0, 1188, 1189, 3,
		170, 85, 0, 1189, 1191, 1, 0, 0, 0, 1190, 1077, 1, 0, 0, 0, 1190, 1078,
		1, 0, 0, 0, 1190, 1086, 1, 0, 0, 0, 1190, 1093, 1, 0, 0, 0, 1190, 1099,
		1, 0, 0, 0, 1190, 1103, 1, 0, 0, 0, 1190, 1109, 1, 0, 0, 0, 1190, 1122,
		1, 0, 0, 0, 1190, 1134, 1, 0, 0, 0, 1190, 1151, 1, 0, 0, 0, 1190, 1155,
		1, 0, 0, 0, 1190, 1160, 1, 0, 0, 0, 1190, 1164, 1, 0, 0, 0, 1190, 1169,
		1, 0, 0, 0, 1190, 1174, 1, 0, 0, 0, 1190, 1178, 1, 0, 0, 0, 1190, 1179,
		1, 0, 0, 0, 1190, 1182, 1, 0, 0, 0, 1190, 1186, 1, 0, 0, 0, 1191, 171,
		1, 0, 0, 0, 1192, 1193, 5, 7, 0, 0, 1193, 1197, 5, 78, 0, 0, 1194, 1196,
		3, 12, 6, 0, 1195, 1194, 1, 0, 0, 0, 1196, 1199, 1, 0, 0, 0, 1197, 1195,
		1, 0, 0, 0, 1197, 1198, 1, 0, 0, 0, 1198, 1200, 1, 0, 0, 0, 1199, 1197,
		1, 0, 0, 0, 1200, 1201, 3, 174, 87, 0, 1201, 1202, 3, 166, 83, 0, 1202,
		1203, 5, 79, 0, 0, 1203, 1204, 3, 160, 80, 0, 1204, 173, 1, 0, 0, 0, 1205,
		1210, 3, 106, 53, 0, 1206, 1207, 5, 107, 0, 0, 1207, 1209, 3, 106, 53,
		0, 1208, 1206, 1, 0, 0, 0, 1209, 1212, 1, 0, 0, 0, 1210, 1208, 1, 0, 0,
		0, 1210, 1211, 1, 0, 0, 0, 1211, 175, 1, 0, 0, 0, 1212, 1210, 1, 0, 0,
		0, 1213, 1214, 5, 19, 0, 0, 1214, 1215, 3, 160, 80, 0, 1215, 177, 1, 0,
		0, 0, 1216, 1217, 5, 78, 0, 0, 1217, 1219, 3, 180, 90, 0, 1218, 1220, 5,
		84, 0, 0, 1219, 1218, 1, 0, 0, 0, 1219, 1220, 1, 0, 0, 0, 1220, 1221, 1,
		0, 0, 0, 1221, 1222, 5, 79, 0, 0, 1222, 179, 1, 0, 0, 0, 1223, 1228, 3,
		182, 91, 0, 1224, 1225, 5, 84, 0, 0, 1225, 1227, 3, 182, 91, 0, 1226, 1224,
		1, 0, 0, 0, 1227, 1230, 1, 0, 0, 0, 1228, 1226, 1, 0, 0, 0, 1228, 1229,
		1, 0, 0, 0, 1229, 181, 1, 0, 0, 0, 1230, 1228, 1, 0, 0, 0, 1231, 1233,
		3, 12, 6, 0, 1232, 1231, 1, 0, 0, 0, 1233, 1236, 1, 0, 0, 0, 1234, 1232,
		1, 0, 0, 0, 1234, 1235, 1, 0, 0, 0, 1235, 1242, 1, 0, 0, 0, 1236, 1234,
		1, 0, 0, 0, 1237, 1238, 3, 86, 43, 0, 1238, 1239, 3, 80, 40, 0, 1239, 1243,
		1, 0, 0, 0, 1240, 1241, 5, 61, 0, 0, 1241, 1243, 3, 166, 83, 0, 1242, 1237,
		1, 0, 0, 0, 1242, 1240, 1, 0, 0, 0, 1243, 1244, 1, 0, 0, 0, 1244, 1245,
		5, 87, 0, 0, 1245, 1246, 3, 200, 100, 0, 1246, 1249, 1, 0, 0, 0, 1247,
		1249, 3, 166, 83, 0, 1248, 1234, 1, 0, 0, 0, 1248, 1247, 1, 0, 0, 0, 1249,
		183, 1, 0, 0, 0, 1250, 1252, 3, 186, 93, 0, 1251, 1250, 1, 0, 0, 0, 1252,
		1253, 1, 0, 0, 0, 1253, 1251, 1, 0, 0, 0, 1253, 1254, 1, 0, 0, 0, 1254,
		1256, 1, 0, 0, 0, 1255, 1257, 3, 162, 81, 0, 1256, 1255, 1, 0, 0, 0, 1257,
		1258, 1, 0, 0, 0, 1258, 1256, 1, 0, 0, 0, 1258, 1259, 1, 0, 0, 0, 1259,
		185, 1, 0, 0, 0, 1260, 1266, 5, 6, 0, 0, 1261, 1267, 3, 200, 100, 0, 1262,
		1267, 5, 128, 0, 0, 1263, 1264, 3, 242, 121, 0, 1264, 1265, 3, 166, 83,
		0, 1265, 1267, 1, 0, 0, 0, 1266, 1261, 1, 0, 0, 0, 1266, 1262, 1, 0, 0,
		0, 1266, 1263, 1, 0, 0, 0, 1267, 1268, 1, 0, 0, 0, 1268, 1272, 5, 93, 0,
		0, 1269, 1270, 5, 12, 0, 0, 1270, 1272, 5, 93, 0, 0, 1271, 1260, 1, 0,
		0, 0, 1271, 1269, 1, 0, 0, 0, 1272, 187, 1, 0, 0, 0, 1273, 1286, 3, 192,
		96, 0, 1274, 1276, 3, 190, 95, 0, 1275, 1274, 1, 0, 0, 0, 1275, 1276, 1,
		0, 0, 0, 1276, 1277, 1, 0, 0, 0, 1277, 1279, 5, 84, 0, 0, 1278, 1280, 3,
		200, 100, 0, 1279, 1278, 1, 0, 0, 0, 1279, 1280, 1, 0, 0, 0, 1280, 1281,
		1, 0, 0, 0, 1281, 1283, 5, 84, 0, 0, 1282, 1284, 3, 196, 98, 0, 1283, 1282,
		1, 0, 0, 0, 1283, 1284, 1, 0, 0, 0, 1284, 1286, 1, 0, 0, 0, 1285, 1273,
		1, 0, 0, 0, 1285, 1275, 1, 0, 0, 0, 1286, 189, 1, 0, 0, 0, 1287, 1290,
		3, 164, 82, 0, 1288, 1290, 3, 196, 98, 0, 1289, 1287, 1, 0, 0, 0, 1289,
		1288, 1, 0, 0, 0, 1290, 191, 1, 0, 0, 0, 1291, 1293, 3, 12, 6, 0, 1292,
		1291, 1, 0, 0, 0, 1293, 1296, 1, 0, 0, 0, 1294, 1292, 1, 0, 0, 0, 1294,
		1295, 1, 0, 0, 0, 1295, 1299, 1, 0, 0, 0, 1296, 1294, 1, 0, 0, 0, 1297,
		1300, 3, 242, 121, 0, 1298, 1300, 5, 61, 0, 0, 1299, 1297, 1, 0, 0, 0,
		1299, 1298, 1, 0, 0, 0, 1300, 1301, 1, 0, 0, 0, 1301, 1302, 3, 80, 40,
		0, 1302, 1303, 5, 93, 0, 0, 1303, 1304, 3, 200, 100, 0, 1304, 193, 1, 0,
		0, 0, 1305, 1306, 5, 78, 0, 0, 1306, 1307, 3, 200, 100, 0, 1307, 1308,
		5, 79, 0, 0, 1308, 195, 1, 0, 0, 0, 1309, 1314, 3, 200, 100, 0, 1310, 1311,
		5, 85, 0, 0, 1311, 1313, 3, 200, 100, 0, 1312, 1310, 1, 0, 0, 0, 1313,
		1316, 1, 0, 0, 0, 1314, 1312, 1, 0, 0, 0, 1314, 1315, 1, 0, 0, 0, 1315,
		197, 1, 0, 0, 0, 1316, 1314, 1, 0, 0, 0, 1317, 1318, 3, 166, 83, 0, 1318,
		1320, 5, 78, 0, 0, 1319, 1321, 3, 196, 98, 0, 1320, 1319, 1, 0, 0, 0, 1320,
		1321, 1, 0, 0, 0, 1321, 1322, 1, 0, 0, 0, 1322, 1323, 5, 79, 0, 0, 1323,
		1337, 1, 0, 0, 0, 1324, 1325, 5, 43, 0, 0, 1325, 1327, 5, 78, 0, 0, 1326,
		1328, 3, 196, 98, 0, 1327, 1326, 1, 0, 0, 0, 1327, 1328, 1, 0, 0, 0, 1328,
		1329, 1, 0, 0, 0, 1329, 1337, 5, 79, 0, 0, 1330, 1331, 5, 40, 0, 0, 1331,
		1333, 5, 78, 0, 0, 1332, 1334, 3, 196, 98, 0, 1333, 1332, 1, 0, 0, 0, 1333,
		1334, 1, 0, 0, 0, 1334, 1335, 1, 0, 0, 0, 1335, 1337, 5, 79, 0, 0, 1336,
		1317, 1, 0, 0, 0, 1336, 1324, 1, 0, 0, 0, 1336, 1330, 1, 0, 0, 0, 1337,
		199, 1, 0, 0, 0, 1338, 1339, 6, 100, -1, 0, 1339, 1384, 3, 210, 105, 0,
		1340, 1384, 3, 198, 99, 0, 1341, 1342, 5, 31, 0, 0, 1342, 1384, 3, 222,
		111, 0, 1343, 1347, 5, 78, 0, 0, 1344, 1346, 3, 116, 58, 0, 1345, 1344,
		1, 0, 0, 0, 1346, 1349, 1, 0, 0, 0, 1347, 1345, 1, 0, 0, 0, 1347, 1348,
		1, 0, 0, 0, 1348, 1350, 1, 0, 0, 0, 1349, 1347, 1, 0, 0, 0, 1350, 1355,
		3, 242, 121, 0, 1351, 1352, 5, 106, 0, 0, 1352, 1354, 3, 242, 121, 0, 1353,
		1351, 1, 0, 0, 0, 1354, 1357, 1, 0, 0, 0, 1355, 1353, 1, 0, 0, 0, 1355,
		1356, 1, 0, 0, 0, 1356, 1358, 1, 0, 0, 0, 1357, 1355, 1, 0, 0, 0, 1358,
		1359, 5, 79, 0, 0, 1359, 1360, 3, 200, 100, 22, 1360, 1384, 1, 0, 0, 0,
		1361, 1362, 7, 5, 0, 0, 1362, 1384, 3, 200, 100, 20, 1363, 1364, 7, 6,
		0, 0, 1364, 1384, 3, 200, 100, 19, 1365, 1384, 3, 204, 102, 0, 1366, 1384,
		3, 212, 106, 0, 1367, 1368, 3, 242, 121, 0, 1368, 1374, 5, 122, 0, 0, 1369,
		1371, 3, 246, 123, 0, 1370, 1369, 1, 0, 0, 0, 1370, 1371, 1, 0, 0, 0, 1371,
		1372, 1, 0, 0, 0, 1372, 1375, 3, 166, 83, 0, 1373, 1375, 5, 31, 0, 0, 1374,
		1370, 1, 0, 0, 0, 1374, 1373, 1, 0, 0, 0, 1375, 1384, 1, 0, 0, 0, 1376,
		1377, 3, 220, 110, 0, 1377, 1379, 5, 122, 0, 0, 1378, 1380, 3, 246, 123,
		0, 1379, 1378, 1, 0, 0, 0, 1379, 1380, 1, 0, 0, 0, 1380, 1381, 1, 0, 0,
		0, 1381, 1382, 5, 31, 0, 0, 1382, 1384, 1, 0, 0, 0, 1383, 1338, 1, 0, 0,
		0, 1383, 1340, 1, 0, 0, 0, 1383, 1341, 1, 0, 0, 0, 1383, 1343, 1, 0, 0,
		0, 1383, 1361, 1, 0, 0, 0, 1383, 1363, 1, 0, 0, 0, 1383, 1365, 1, 0, 0,
		0, 1383, 1366, 1, 0, 0, 0, 1383, 1367, 1, 0, 0, 0, 1383, 1376, 1, 0, 0,
		0, 1384, 1468, 1, 0, 0, 0, 1385, 1386, 10, 18, 0, 0, 1386, 1387, 7, 7,
		0, 0, 1387, 1467, 3, 200, 100, 19, 1388, 1389, 10, 17, 0, 0, 1389, 1390,
		7, 8, 0, 0, 1390, 1467, 3, 200, 100, 18, 1391, 1399, 10, 16, 0, 0, 1392,
		1393, 5, 89, 0, 0, 1393, 1400, 5, 89, 0, 0, 1394, 1395, 5, 88, 0, 0, 1395,
		1396, 5, 88, 0, 0, 1396, 1400, 5, 88, 0, 0, 1397, 1398, 5, 88, 0, 0, 1398,
		1400, 5, 88, 0, 0, 1399, 1392, 1, 0, 0, 0, 1399, 1394, 1, 0, 0, 0, 1399,
		1397, 1, 0, 0, 0, 1400, 1401, 1, 0, 0, 0, 1401, 1467, 3, 200, 100, 17,
		1402, 1403, 10, 15, 0, 0, 1403, 1404, 7, 9, 0, 0, 1404, 1467, 3, 200, 100,
		16, 1405, 1406, 10, 13, 0, 0, 1406, 1407, 7, 10, 0, 0, 1407, 1467, 3, 200,
		100, 14, 1408, 1409, 10, 12, 0, 0, 1409, 1410, 5, 106, 0, 0, 1410, 1467,
		3, 200, 100, 13, 1411, 1412, 10, 11, 0, 0, 1412, 1413, 5, 108, 0, 0, 1413,
		1467, 3, 200, 100, 12, 1414, 1415, 10, 10, 0, 0, 1415, 1416, 5, 107, 0,
		0, 1416, 1467, 3, 200, 100, 11, 1417, 1418, 10, 9, 0, 0, 1418, 1419, 5,
		98, 0, 0, 1419, 1467, 3, 200, 100, 10, 1420, 1421, 10, 8, 0, 0, 1421, 1422,
		5, 99, 0, 0, 1422, 1467, 3, 200, 100, 9, 1423, 1424, 10, 7, 0, 0, 1424,
		1425, 5, 92, 0, 0, 1425, 1426, 3, 200, 100, 0, 1426, 1427, 5, 93, 0, 0,
		1427, 1428, 3, 200, 100, 7, 1428, 1467, 1, 0, 0, 0, 1429, 1430, 10, 6,
		0, 0, 1430, 1431, 7, 11, 0, 0, 1431, 1467, 3, 200, 100, 6, 1432, 1433,
		10, 26, 0, 0, 1433, 1445, 5, 86, 0, 0, 1434, 1446, 3, 166, 83, 0, 1435,
		1446, 3, 198, 99, 0, 1436, 1446, 5, 43, 0, 0, 1437, 1439, 5, 31, 0, 0,
		1438, 1440, 3, 238, 119, 0, 1439, 1438, 1, 0, 0, 0, 1439, 1440, 1, 0, 0,
		0, 1440, 1441, 1, 0, 0, 0, 1441, 1446, 3, 226, 113, 0, 1442, 1443, 5, 40,
		0, 0, 1443, 1446, 3, 248, 124, 0, 1444, 1446, 3, 232, 116, 0, 1445, 1434,
		1, 0, 0, 0, 1445, 1435, 1, 0, 0, 0, 1445, 1436, 1, 0, 0, 0, 1445, 1437,
		1, 0, 0, 0, 1445, 1442, 1, 0, 0, 0, 1445, 1444, 1, 0, 0, 0, 1446, 1467,
		1, 0, 0, 0, 1447, 1448, 10, 25, 0, 0, 1448, 1449, 5, 82, 0, 0, 1449, 1450,
		3, 200, 100, 0, 1450, 1451, 5, 83, 0, 0, 1451, 1467, 1, 0, 0, 0, 1452,
		1453, 10, 21, 0, 0, 1453, 1467, 7, 12, 0, 0, 1454, 1455, 10, 14, 0, 0,
		1455, 1458, 5, 26, 0, 0, 1456, 1459, 3, 242, 121, 0, 1457, 1459, 3, 202,
		101, 0, 1458, 1456, 1, 0, 0, 0, 1458, 1457, 1, 0, 0, 0, 1459, 1467, 1,
		0, 0, 0, 1460, 1461, 10, 3, 0, 0, 1461, 1463, 5, 122, 0, 0, 1462, 1464,
		3, 246, 123, 0, 1463, 1462, 1, 0, 0, 0, 1463, 1464, 1, 0, 0, 0, 1464, 1465,
		1, 0, 0, 0, 1465, 1467, 3, 166, 83, 0, 1466, 1385, 1, 0, 0, 0, 1466, 1388,
		1, 0, 0, 0, 1466, 1391, 1, 0, 0, 0, 1466, 1402, 1, 0, 0, 0, 1466, 1405,
		1, 0, 0, 0, 1466, 1408, 1, 0, 0, 0, 1466, 1411, 1, 0, 0, 0, 1466, 1414,
		1, 0, 0, 0, 1466, 1417, 1, 0, 0, 0, 1466, 1420, 1, 0, 0, 0, 1466, 1423,
		1, 0, 0, 0, 1466, 1429, 1, 0, 0, 0, 1466, 1432, 1, 0, 0, 0, 1466, 1447,
		1, 0, 0, 0, 1466, 1452, 1, 0, 0, 0, 1466, 1454, 1, 0, 0, 0, 1466, 1460,
		1, 0, 0, 0, 1467, 1470, 1, 0, 0, 0, 1468, 1466, 1, 0, 0, 0, 1468, 1469,
		1, 0, 0, 0, 1469, 201, 1, 0, 0, 0, 1470, 1468, 1, 0, 0, 0, 1471, 1473,
		3, 12, 6, 0, 1472, 1471, 1, 0, 0, 0, 1473, 1476, 1, 0, 0, 0, 1474, 1472,
		1, 0, 0, 0, 1474, 1475, 1, 0, 0, 0, 1475, 1477, 1, 0, 0, 0, 1476, 1474,
		1, 0, 0, 0, 1477, 1481, 3, 242, 121, 0, 1478, 1480, 3, 116, 58, 0, 1479,
		1478, 1, 0, 0, 0, 1480, 1483, 1, 0, 0, 0, 1481, 1479, 1, 0, 0, 0, 1481,
		1482, 1, 0, 0, 0, 1482, 1484, 1, 0, 0, 0, 1483, 1481, 1, 0, 0, 0, 1484,
		1485, 3, 166, 83, 0, 1485, 203, 1, 0, 0, 0, 1486, 1487, 3, 206, 103, 0,
		1487, 1488, 5, 121, 0, 0, 1488, 1489, 3, 208, 104, 0, 1489, 205, 1, 0,
		0, 0, 1490, 1513, 3, 166, 83, 0, 1491, 1493, 5, 78, 0, 0, 1492, 1494, 3,
		96, 48, 0, 1493, 1492, 1, 0, 0, 0, 1493, 1494, 1, 0, 0, 0, 1494, 1495,
		1, 0, 0, 0, 1495, 1513, 5, 79, 0, 0, 1496, 1497, 5, 78, 0, 0, 1497, 1502,
		3, 166, 83, 0, 1498, 1499, 5, 85, 0, 0, 1499, 1501, 3, 166, 83, 0, 1500,
		1498, 1, 0, 0, 0, 1501, 1504, 1, 0, 0, 0, 1502, 1500, 1, 0, 0, 0, 1502,
		1503, 1, 0, 0, 0, 1503, 1505, 1, 0, 0, 0, 1504, 1502, 1, 0, 0, 0, 1505,
		1506, 5, 79, 0, 0, 1506, 1513, 1, 0, 0, 0, 1507, 1509, 5, 78, 0, 0, 1508,
		1510, 3, 102, 51, 0, 1509, 1508, 1, 0, 0, 0, 1509, 1510, 1, 0, 0, 0, 1510,
		1511, 1, 0, 0, 0, 1511, 1513, 5, 79, 0, 0, 1512, 1490, 1, 0, 0, 0, 1512,
		1491, 1, 0, 0, 0, 1512, 1496, 1, 0, 0, 0, 1512, 1507, 1, 0, 0, 0, 1513,
		207, 1, 0, 0, 0, 1514, 1517, 3, 200, 100, 0, 1515, 1517, 3, 160, 80, 0,
		1516, 1514, 1, 0, 0, 0, 1516, 1515, 1, 0, 0, 0, 1517, 209, 1, 0, 0, 0,
		1518, 1519, 5, 78, 0, 0, 1519, 1520, 3, 200, 100, 0, 1520, 1521, 5, 79,
		0, 0, 1521, 1537, 1, 0, 0, 0, 1522, 1537, 5, 43, 0, 0, 1523, 1537, 5, 40,
		0, 0, 1524, 1537, 3, 108, 54, 0, 1525, 1537, 3, 166, 83, 0, 1526, 1527,
		3, 50, 25, 0, 1527, 1528, 5, 86, 0, 0, 1528, 1529, 5, 9, 0, 0, 1529, 1537,
		1, 0, 0, 0, 1530, 1534, 3, 238, 119, 0, 1531, 1535, 3, 250, 125, 0, 1532,
		1533, 5, 43, 0, 0, 1533, 1535, 3, 252, 126, 0, 1534, 1531, 1, 0, 0, 0,
		1534, 1532, 1, 0, 0, 0, 1535, 1537, 1, 0, 0, 0, 1536, 1518, 1, 0, 0, 0,
		1536, 1522, 1, 0, 0, 0, 1536, 1523, 1, 0, 0, 0, 1536, 1524, 1, 0, 0, 0,
		1536, 1525, 1, 0, 0, 0, 1536, 1526, 1, 0, 0, 0, 1536, 1530, 1, 0, 0, 0,
		1537, 211, 1, 0, 0, 0, 1538, 1539, 5, 41, 0, 0, 1539, 1540, 3, 194, 97,
		0, 1540, 1544, 5, 80, 0, 0, 1541, 1543, 3, 214, 107, 0, 1542, 1541, 1,
		0, 0, 0, 1543, 1546, 1, 0, 0, 0, 1544, 1542, 1, 0, 0, 0, 1544, 1545, 1,
		0, 0, 0, 1545, 1547, 1, 0, 0, 0, 1546, 1544, 1, 0, 0, 0, 1547, 1548, 5,
		81, 0, 0, 1548, 213, 1, 0, 0, 0, 1549, 1553, 5, 6, 0, 0, 1550, 1554, 3,
		196, 98, 0, 1551, 1554, 5, 77, 0, 0, 1552, 1554, 3, 216, 108, 0, 1553,
		1550, 1, 0, 0, 0, 1553, 1551, 1, 0, 0, 0, 1553, 1552, 1, 0, 0, 0, 1554,
		1555, 1, 0, 0, 0, 1555, 1556, 7, 13, 0, 0, 1556, 1561, 3, 218, 109, 0,
		1557, 1558, 5, 12, 0, 0, 1558, 1559, 7, 13, 0, 0, 1559, 1561, 3, 218, 109,
		0, 1560, 1549, 1, 0, 0, 0, 1560, 1557, 1, 0, 0, 0, 1561, 215, 1, 0, 0,
		0, 1562, 1563, 6, 108, -1, 0, 1563, 1564, 5, 78, 0, 0, 1564, 1565, 3, 216,
		108, 0, 1565, 1566, 5, 79, 0, 0, 1566, 1589, 1, 0, 0, 0, 1567, 1569, 3,
		12, 6, 0, 1568, 1567, 1, 0, 0, 0, 1569, 1572, 1, 0, 0, 0, 1570, 1568, 1,
		0, 0, 0, 1570, 1571, 1, 0, 0, 0, 1571, 1573, 1, 0, 0, 0, 1572, 1570, 1,
		0, 0, 0, 1573, 1577, 3, 242, 121, 0, 1574, 1576, 3, 116, 58, 0, 1575, 1574,
		1, 0, 0, 0, 1576, 1579, 1, 0, 0, 0, 1577, 1575, 1, 0, 0, 0, 1577, 1578,
		1, 0, 0, 0, 1578, 1580, 1, 0, 0, 0, 1579, 1577, 1, 0, 0, 0, 1580, 1585,
		3, 166, 83, 0, 1581, 1582, 5, 98, 0, 0, 1582, 1584, 3, 200, 100, 0, 1583,
		1581, 1, 0, 0, 0, 1584, 1587, 1, 0, 0, 0, 1585, 1583, 1, 0, 0, 0, 1585,
		1586, 1, 0, 0, 0, 1586, 1589, 1, 0, 0, 0, 1587, 1585, 1, 0, 0, 0, 1588,
		1562, 1, 0, 0, 0, 1588, 1570, 1, 0, 0, 0, 1589, 1595, 1, 0, 0, 0, 1590,
		1591, 10, 1, 0, 0, 1591, 1592, 5, 98, 0, 0, 1592, 1594, 3, 200, 100, 0,
		1593, 1590, 1, 0, 0, 0, 1594, 1597, 1, 0, 0, 0, 1595, 1593, 1, 0, 0, 0,
		1595, 1596, 1, 0, 0, 0, 1596, 217, 1, 0, 0, 0, 1597, 1595, 1, 0, 0, 0,
		1598, 1606, 3, 160, 80, 0, 1599, 1601, 3, 162, 81, 0, 1600, 1599, 1, 0,
		0, 0, 1601, 1604, 1, 0, 0, 0, 1602, 1600, 1, 0, 0, 0, 1602, 1603, 1, 0,
		0, 0, 1603, 1606, 1, 0, 0, 0, 1604, 1602, 1, 0, 0, 0, 1605, 1598, 1, 0,
		0, 0, 1605, 1602, 1, 0, 0, 0, 1606, 219, 1, 0, 0, 0, 1607, 1608, 3, 86,
		43, 0, 1608, 1609, 5, 86, 0, 0, 1609, 1611, 1, 0, 0, 0, 1610, 1607, 1,
		0, 0, 0, 1610, 1611, 1, 0, 0, 0, 1611, 1615, 1, 0, 0, 0, 1612, 1614, 3,
		116, 58, 0, 1613, 1612, 1, 0, 0, 0, 1614, 1617, 1, 0, 0, 0, 1615, 1613,
		1, 0, 0, 0, 1615, 1616, 1, 0, 0, 0, 1616, 1618, 1, 0, 0, 0, 1617, 1615,
		1, 0, 0, 0, 1618, 1620, 3, 166, 83, 0, 1619, 1621, 3, 246, 123, 0, 1620,
		1619, 1, 0, 0, 0, 1620, 1621, 1, 0, 0, 0, 1621, 221, 1, 0, 0, 0, 1622,
		1623, 3, 238, 119, 0, 1623, 1624, 3, 224, 112, 0, 1624, 1625, 3, 230, 115,
		0, 1625, 1632, 1, 0, 0, 0, 1626, 1629, 3, 224, 112, 0, 1627, 1630, 3, 228,
		114, 0, 1628, 1630, 3, 230, 115, 0, 1629, 1627, 1, 0, 0, 0, 1629, 1628,
		1, 0, 0, 0, 1630, 1632, 1, 0, 0, 0, 1631, 1622, 1, 0, 0, 0, 1631, 1626,
		1, 0, 0, 0, 1632, 223, 1, 0, 0, 0, 1633, 1635, 3, 166, 83, 0, 1634, 1636,
		3, 234, 117, 0, 1635, 1634, 1, 0, 0, 0, 1635, 1636, 1, 0, 0, 0, 1636, 1644,
		1, 0, 0, 0, 1637, 1638, 5, 86, 0, 0, 1638, 1640, 3, 166, 83, 0, 1639, 1641,
		3, 234, 117, 0, 1640, 1639, 1, 0, 0, 0, 1640, 1641, 1, 0, 0, 0, 1641, 1643,
		1, 0, 0, 0, 1642, 1637, 1, 0, 0, 0, 1643, 1646, 1, 0, 0, 0, 1644, 1642,
		1, 0, 0, 0, 1644, 1645, 1, 0, 0, 0, 1645, 1649, 1, 0, 0, 0, 1646, 1644,
		1, 0, 0, 0, 1647, 1649, 3, 244, 122, 0, 1648, 1633, 1, 0, 0, 0, 1648, 1647,
		1, 0, 0, 0, 1649, 225, 1, 0, 0, 0, 1650, 1652, 3, 166, 83, 0, 1651, 1653,
		3, 236, 118, 0, 1652, 1651, 1, 0, 0, 0, 1652, 1653, 1, 0, 0, 0, 1653, 1654,
		1, 0, 0, 0, 1654, 1655, 3, 230, 115, 0, 1655, 227, 1, 0, 0, 0, 1656, 1684,
		5, 82, 0, 0, 1657, 1662, 5, 83, 0, 0, 1658, 1659, 5, 82, 0, 0, 1659, 1661,
		5, 83, 0, 0, 1660, 1658, 1, 0, 0, 0, 1661, 1664, 1, 0, 0, 0, 1662, 1660,
		1, 0, 0, 0, 1662, 1663, 1, 0, 0, 0, 1663, 1665, 1, 0, 0, 0, 1664, 1662,
		1, 0, 0, 0, 1665, 1685, 3, 84, 42, 0, 1666, 1667, 3, 200, 100, 0, 1667,
		1674, 5, 83, 0, 0, 1668, 1669, 5, 82, 0, 0, 1669, 1670, 3, 200, 100, 0,
		1670, 1671, 5, 83, 0, 0, 1671, 1673, 1, 0, 0, 0, 1672, 1668, 1, 0, 0, 0,
		1673, 1676, 1, 0, 0, 0, 1674, 1672, 1, 0, 0, 0, 1674, 1675, 1, 0, 0, 0,
		1675, 1681, 1, 0, 0, 0, 1676, 1674, 1, 0, 0, 0, 1677, 1678, 5, 82, 0, 0,
		1678, 1680, 5, 83, 0, 0, 1679, 1677, 1, 0, 0, 0, 1680, 1683, 1, 0, 0, 0,
		1681, 1679, 1, 0, 0, 0, 1681, 1682, 1, 0, 0, 0, 1682, 1685, 1, 0, 0, 0,
		1683, 1681, 1, 0, 0, 0, 1684, 1657, 1, 0, 0, 0, 1684, 1666, 1, 0, 0, 0,
		1685, 229, 1, 0, 0, 0, 1686, 1688, 3, 252, 126, 0, 1687, 1689, 3, 38, 19,
		0, 1688, 1687, 1, 0, 0, 0, 1688, 1689, 1, 0, 0, 0, 1689, 231, 1, 0, 0,
		0, 1690, 1691, 3, 238, 119, 0, 1691, 1692, 3, 250, 125, 0, 1692, 233, 1,
		0, 0, 0, 1693, 1694, 5, 89, 0, 0, 1694, 1697, 5, 88, 0, 0, 1695, 1697,
		3, 246, 123, 0, 1696, 1693, 1, 0, 0, 0, 1696, 1695, 1, 0, 0, 0, 1697, 235,
		1, 0, 0, 0, 1698, 1699, 5, 89, 0, 0, 1699, 1702, 5, 88, 0, 0, 1700, 1702,
		3, 238, 119, 0, 1701, 1698, 1, 0, 0, 0, 1701, 1700, 1, 0, 0, 0, 1702, 237,
		1, 0, 0, 0, 1703, 1704, 5, 89, 0, 0, 1704, 1705, 3, 240, 120, 0, 1705,
		1706, 5, 88, 0, 0, 1706, 239, 1, 0, 0, 0, 1707, 1712, 3, 242, 121, 0, 1708,
		1709, 5, 85, 0, 0, 1709, 1711, 3, 242, 121, 0, 1710, 1708, 1, 0, 0, 0,
		1711, 1714, 1, 0, 0, 0, 1712, 1710, 1, 0, 0, 0, 1712, 1713, 1, 0, 0, 0,
		1713, 241, 1, 0, 0, 0, 1714, 1712, 1, 0, 0, 0, 1715, 1717, 3, 116, 58,
		0, 1716, 1715, 1, 0, 0, 0, 1717, 1720, 1, 0, 0, 0, 1718, 1716, 1, 0, 0,
		0, 1718, 1719, 1, 0, 0, 0, 1719, 1723, 1, 0, 0, 0, 1720, 1718, 1, 0, 0,
		0, 1721, 1724, 3, 86, 43, 0, 1722, 1724, 3, 244, 122, 0, 1723, 1721, 1,
		0, 0, 0, 1723, 1722, 1, 0, 0, 0, 1724, 1735, 1, 0, 0, 0, 1725, 1727, 3,
		116, 58, 0, 1726, 1725, 1, 0, 0, 0, 1727, 1730, 1, 0, 0, 0, 1728, 1726,
		1, 0, 0, 0, 1728, 1729, 1, 0, 0, 0, 1729, 1731, 1, 0, 0, 0, 1730, 1728,
		1, 0, 0, 0, 1731, 1732, 5, 82, 0, 0, 1732, 1734, 5, 83, 0, 0, 1733, 1728,
		1, 0, 0, 0, 1734, 1737, 1, 0, 0, 0, 1735, 1733, 1, 0, 0, 0, 1735, 1736,
		1, 0, 0, 0, 1736, 243, 1, 0, 0, 0, 1737, 1735, 1, 0, 0, 0, 1738, 1739,
		7, 14, 0, 0, 1739, 245, 1, 0, 0, 0, 1740, 1741, 5, 89, 0, 0, 1741, 1746,
		3, 88, 44, 0, 1742, 1743, 5, 85, 0, 0, 1743, 1745, 3, 88, 44, 0, 1744,
		1742, 1, 0, 0, 0, 1745, 1748, 1, 0, 0, 0, 1746, 1744, 1, 0, 0, 0, 1746,
		1747, 1, 0, 0, 0, 1747, 1749, 1, 0, 0, 0, 1748, 1746, 1, 0, 0, 0, 1749,
		1750, 5, 88, 0, 0, 1750, 247, 1, 0, 0, 0, 1751, 1761, 3, 252, 126, 0, 1752,
		1754, 5, 86, 0, 0, 1753, 1755, 3, 246, 123, 0, 1754, 1753, 1, 0, 0, 0,
		1754, 1755, 1, 0, 0, 0, 1755, 1756, 1, 0, 0, 0, 1756, 1758, 3, 166, 83,
		0, 1757, 1759, 3, 252, 126, 0, 1758, 1757, 1, 0, 0, 0, 1758, 1759, 1, 0,
		0, 0, 1759, 1761, 1, 0, 0, 0, 1760, 1751, 1, 0, 0, 0, 1760, 1752, 1, 0,
		0, 0, 1761, 249, 1, 0, 0, 0, 1762, 1763, 5, 40, 0, 0, 1763, 1768, 3, 248,
		124, 0, 1764, 1765, 3, 166, 83, 0, 1765, 1766, 3, 252, 126, 0, 1766, 1768,
		1, 0, 0, 0, 1767, 1762, 1, 0, 0, 0, 1767, 1764, 1, 0, 0, 0, 1768, 251,
		1, 0, 0, 0, 1769, 1771, 5, 78, 0, 0, 1770, 1772, 3, 196, 98, 0, 1771, 1770,
		1, 0, 0, 0, 1771, 1772, 1, 0, 0, 0, 1772, 1773, 1, 0, 0, 0, 1773, 1774,
		5, 79, 0, 0, 1774, 253, 1, 0, 0, 0, 220, 255, 260, 266, 272, 277, 286,
		291, 298, 306, 309, 316, 328, 332, 337, 340, 343, 346, 365, 373, 381, 385,
		392, 399, 403, 406, 409, 418, 424, 429, 432, 438, 444, 448, 452, 460, 469,
		476, 482, 486, 498, 507, 512, 518, 522, 534, 545, 550, 560, 568, 578, 587,
		598, 603, 612, 622, 627, 636, 642, 649, 654, 662, 666, 668, 674, 679, 683,
		690, 696, 698, 705, 710, 715, 718, 720, 730, 740, 745, 748, 753, 762, 769,
		780, 786, 797, 807, 818, 827, 832, 835, 842, 852, 860, 863, 866, 879, 887,
		892, 900, 904, 908, 912, 916, 918, 922, 928, 936, 946, 955, 965, 973, 987,
		994, 999, 1005, 1014, 1024, 1033, 1043, 1048, 1059, 1066, 1072, 1075, 1082,
		1091, 1114, 1117, 1120, 1128, 1132, 1140, 1146, 1157, 1166, 1171, 1184,
		1190, 1197, 1210, 1219, 1228, 1234, 1242, 1248, 1253, 1258, 1266, 1271,
		1275, 1279, 1283, 1285, 1289, 1294, 1299, 1314, 1320, 1327, 1333, 1336,
		1347, 1355, 1370, 1374, 1379, 1383, 1399, 1439, 1445, 1458, 1463, 1466,
		1468, 1474, 1481, 1493, 1502, 1509, 1512, 1516, 1534, 1536, 1544, 1553,
		1560, 1570, 1577, 1585, 1588, 1595, 1602, 1605, 1610, 1615, 1620, 1629,
		1631, 1635, 1640, 1644, 1648, 1652, 1662, 1674, 1681, 1684, 1688, 1696,
		1701, 1712, 1718, 1723, 1728, 1735, 1746, 1754, 1758, 1760, 1767, 1771,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// JavaParserInit initializes any static state used to implement JavaParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewJavaParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func JavaParserInit() {
	staticData := &javaparserParserStaticData
	staticData.once.Do(javaparserParserInit)
}

// NewJavaParser produces a new parser instance for the optional input antlr.TokenStream.
func NewJavaParser(input antlr.TokenStream) *JavaParser {
	JavaParserInit()
	this := new(JavaParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &javaparserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.predictionContextCache)
	this.RuleNames = staticData.ruleNames
	this.LiteralNames = staticData.literalNames
	this.SymbolicNames = staticData.symbolicNames
	this.GrammarFileName = "JavaParser.g4"

	return this
}

// JavaParser tokens.
const (
	JavaParserEOF               = antlr.TokenEOF
	JavaParserABSTRACT          = 1
	JavaParserASSERT            = 2
	JavaParserBOOLEAN           = 3
	JavaParserBREAK             = 4
	JavaParserBYTE              = 5
	JavaParserCASE              = 6
	JavaParserCATCH             = 7
	JavaParserCHAR              = 8
	JavaParserCLASS             = 9
	JavaParserCONST             = 10
	JavaParserCONTINUE          = 11
	JavaParserDEFAULT           = 12
	JavaParserDO                = 13
	JavaParserDOUBLE            = 14
	JavaParserELSE              = 15
	JavaParserENUM              = 16
	JavaParserEXTENDS           = 17
	JavaParserFINAL             = 18
	JavaParserFINALLY           = 19
	JavaParserFLOAT             = 20
	JavaParserFOR               = 21
	JavaParserIF                = 22
	JavaParserGOTO              = 23
	JavaParserIMPLEMENTS        = 24
	JavaParserIMPORT            = 25
	JavaParserINSTANCEOF        = 26
	JavaParserINT               = 27
	JavaParserINTERFACE         = 28
	JavaParserLONG              = 29
	JavaParserNATIVE            = 30
	JavaParserNEW               = 31
	JavaParserPACKAGE           = 32
	JavaParserPRIVATE           = 33
	JavaParserPROTECTED         = 34
	JavaParserPUBLIC            = 35
	JavaParserRETURN            = 36
	JavaParserSHORT             = 37
	JavaParserSTATIC            = 38
	JavaParserSTRICTFP          = 39
	JavaParserSUPER             = 40
	JavaParserSWITCH            = 41
	JavaParserSYNCHRONIZED      = 42
	JavaParserTHIS              = 43
	JavaParserTHROW             = 44
	JavaParserTHROWS            = 45
	JavaParserTRANSIENT         = 46
	JavaParserTRY               = 47
	JavaParserVOID              = 48
	JavaParserVOLATILE          = 49
	JavaParserWHILE             = 50
	JavaParserMODULE            = 51
	JavaParserOPEN              = 52
	JavaParserREQUIRES          = 53
	JavaParserEXPORTS           = 54
	JavaParserOPENS             = 55
	JavaParserTO                = 56
	JavaParserUSES              = 57
	JavaParserPROVIDES          = 58
	JavaParserWITH              = 59
	JavaParserTRANSITIVE        = 60
	JavaParserVAR               = 61
	JavaParserYIELD             = 62
	JavaParserRECORD            = 63
	JavaParserSEALED            = 64
	JavaParserPERMITS           = 65
	JavaParserNON_SEALED        = 66
	JavaParserDECIMAL_LITERAL   = 67
	JavaParserHEX_LITERAL       = 68
	JavaParserOCT_LITERAL       = 69
	JavaParserBINARY_LITERAL    = 70
	JavaParserFLOAT_LITERAL     = 71
	JavaParserHEX_FLOAT_LITERAL = 72
	JavaParserBOOL_LITERAL      = 73
	JavaParserCHAR_LITERAL      = 74
	JavaParserSTRING_LITERAL    = 75
	JavaParserTEXT_BLOCK        = 76
	JavaParserNULL_LITERAL      = 77
	JavaParserLPAREN            = 78
	JavaParserRPAREN            = 79
	JavaParserLBRACE            = 80
	JavaParserRBRACE            = 81
	JavaParserLBRACK            = 82
	JavaParserRBRACK            = 83
	JavaParserSEMI              = 84
	JavaParserCOMMA             = 85
	JavaParserDOT               = 86
	JavaParserASSIGN            = 87
	JavaParserGT                = 88
	JavaParserLT                = 89
	JavaParserBANG              = 90
	JavaParserTILDE             = 91
	JavaParserQUESTION          = 92
	JavaParserCOLON             = 93
	JavaParserEQUAL             = 94
	JavaParserLE                = 95
	JavaParserGE                = 96
	JavaParserNOTEQUAL          = 97
	JavaParserAND               = 98
	JavaParserOR                = 99
	JavaParserINC               = 100
	JavaParserDEC               = 101
	JavaParserADD               = 102
	JavaParserSUB               = 103
	JavaParserMUL               = 104
	JavaParserDIV               = 105
	JavaParserBITAND            = 106
	JavaParserBITOR             = 107
	JavaParserCARET             = 108
	JavaParserMOD               = 109
	JavaParserADD_ASSIGN        = 110
	JavaParserSUB_ASSIGN        = 111
	JavaParserMUL_ASSIGN        = 112
	JavaParserDIV_ASSIGN        = 113
	JavaParserAND_ASSIGN        = 114
	JavaParserOR_ASSIGN         = 115
	JavaParserXOR_ASSIGN        = 116
	JavaParserMOD_ASSIGN        = 117
	JavaParserLSHIFT_ASSIGN     = 118
	JavaParserRSHIFT_ASSIGN     = 119
	JavaParserURSHIFT_ASSIGN    = 120
	JavaParserARROW             = 121
	JavaParserCOLONCOLON        = 122
	JavaParserAT                = 123
	JavaParserELLIPSIS          = 124
	JavaParserWS                = 125
	JavaParserCOMMENT           = 126
	JavaParserLINE_COMMENT      = 127
	JavaParserIDENTIFIER        = 128
)

// JavaParser rules.
const (
	JavaParserRULE_compilationUnit                   = 0
	JavaParserRULE_packageDeclaration                = 1
	JavaParserRULE_importDeclaration                 = 2
	JavaParserRULE_typeDeclaration                   = 3
	JavaParserRULE_modifier                          = 4
	JavaParserRULE_classOrInterfaceModifier          = 5
	JavaParserRULE_variableModifier                  = 6
	JavaParserRULE_classDeclaration                  = 7
	JavaParserRULE_classDeclarationExtends           = 8
	JavaParserRULE_classDeclarationImplements        = 9
	JavaParserRULE_classDeclarationPermits           = 10
	JavaParserRULE_typeParameters                    = 11
	JavaParserRULE_typeParameter                     = 12
	JavaParserRULE_typeBound                         = 13
	JavaParserRULE_enumDeclaration                   = 14
	JavaParserRULE_enumConstants                     = 15
	JavaParserRULE_enumConstant                      = 16
	JavaParserRULE_enumBodyDeclarations              = 17
	JavaParserRULE_interfaceDeclaration              = 18
	JavaParserRULE_classBody                         = 19
	JavaParserRULE_interfaceBody                     = 20
	JavaParserRULE_classBodyDeclaration              = 21
	JavaParserRULE_memberDeclaration                 = 22
	JavaParserRULE_methodDeclaration                 = 23
	JavaParserRULE_methodBody                        = 24
	JavaParserRULE_typeTypeOrVoid                    = 25
	JavaParserRULE_genericMethodDeclaration          = 26
	JavaParserRULE_genericConstructorDeclaration     = 27
	JavaParserRULE_constructorDeclaration            = 28
	JavaParserRULE_fieldDeclaration                  = 29
	JavaParserRULE_interfaceBodyDeclaration          = 30
	JavaParserRULE_interfaceMemberDeclaration        = 31
	JavaParserRULE_constDeclaration                  = 32
	JavaParserRULE_constantDeclarator                = 33
	JavaParserRULE_interfaceMethodDeclaration        = 34
	JavaParserRULE_interfaceMethodModifier           = 35
	JavaParserRULE_genericInterfaceMethodDeclaration = 36
	JavaParserRULE_interfaceCommonBodyDeclaration    = 37
	JavaParserRULE_variableDeclarators               = 38
	JavaParserRULE_variableDeclarator                = 39
	JavaParserRULE_variableDeclaratorId              = 40
	JavaParserRULE_variableInitializer               = 41
	JavaParserRULE_arrayInitializer                  = 42
	JavaParserRULE_classOrInterfaceType              = 43
	JavaParserRULE_typeArgument                      = 44
	JavaParserRULE_qualifiedNameList                 = 45
	JavaParserRULE_formalParameters                  = 46
	JavaParserRULE_receiverParameter                 = 47
	JavaParserRULE_formalParameterList               = 48
	JavaParserRULE_formalParameter                   = 49
	JavaParserRULE_lastFormalParameter               = 50
	JavaParserRULE_lambdaLVTIList                    = 51
	JavaParserRULE_lambdaLVTIParameter               = 52
	JavaParserRULE_qualifiedName                     = 53
	JavaParserRULE_literal                           = 54
	JavaParserRULE_integerLiteral                    = 55
	JavaParserRULE_floatLiteral                      = 56
	JavaParserRULE_altAnnotationQualifiedName        = 57
	JavaParserRULE_annotation                        = 58
	JavaParserRULE_elementValuePairs                 = 59
	JavaParserRULE_elementValuePair                  = 60
	JavaParserRULE_elementValue                      = 61
	JavaParserRULE_elementValueArrayInitializer      = 62
	JavaParserRULE_annotationTypeDeclaration         = 63
	JavaParserRULE_annotationTypeBody                = 64
	JavaParserRULE_annotationTypeElementDeclaration  = 65
	JavaParserRULE_annotationTypeElementRest         = 66
	JavaParserRULE_annotationMethodOrConstantRest    = 67
	JavaParserRULE_annotationMethodRest              = 68
	JavaParserRULE_annotationConstantRest            = 69
	JavaParserRULE_defaultValue                      = 70
	JavaParserRULE_moduleDeclaration                 = 71
	JavaParserRULE_moduleBody                        = 72
	JavaParserRULE_moduleDirective                   = 73
	JavaParserRULE_requiresModifier                  = 74
	JavaParserRULE_recordDeclaration                 = 75
	JavaParserRULE_recordHeader                      = 76
	JavaParserRULE_recordComponentList               = 77
	JavaParserRULE_recordComponent                   = 78
	JavaParserRULE_recordBody                        = 79
	JavaParserRULE_block                             = 80
	JavaParserRULE_blockStatement                    = 81
	JavaParserRULE_localVariableDeclaration          = 82
	JavaParserRULE_identifier                        = 83
	JavaParserRULE_localTypeDeclaration              = 84
	JavaParserRULE_statement                         = 85
	JavaParserRULE_catchClause                       = 86
	JavaParserRULE_catchType                         = 87
	JavaParserRULE_finallyBlock                      = 88
	JavaParserRULE_resourceSpecification             = 89
	JavaParserRULE_resources                         = 90
	JavaParserRULE_resource                          = 91
	JavaParserRULE_switchBlockStatementGroup         = 92
	JavaParserRULE_switchLabel                       = 93
	JavaParserRULE_forControl                        = 94
	JavaParserRULE_forInit                           = 95
	JavaParserRULE_enhancedForControl                = 96
	JavaParserRULE_parExpression                     = 97
	JavaParserRULE_expressionList                    = 98
	JavaParserRULE_methodCall                        = 99
	JavaParserRULE_expression                        = 100
	JavaParserRULE_pattern                           = 101
	JavaParserRULE_lambdaExpression                  = 102
	JavaParserRULE_lambdaParameters                  = 103
	JavaParserRULE_lambdaBody                        = 104
	JavaParserRULE_primary                           = 105
	JavaParserRULE_switchExpression                  = 106
	JavaParserRULE_switchLabeledRule                 = 107
	JavaParserRULE_guardedPattern                    = 108
	JavaParserRULE_switchRuleOutcome                 = 109
	JavaParserRULE_classType                         = 110
	JavaParserRULE_creator                           = 111
	JavaParserRULE_createdName                       = 112
	JavaParserRULE_innerCreator                      = 113
	JavaParserRULE_arrayCreatorRest                  = 114
	JavaParserRULE_classCreatorRest                  = 115
	JavaParserRULE_explicitGenericInvocation         = 116
	JavaParserRULE_typeArgumentsOrDiamond            = 117
	JavaParserRULE_nonWildcardTypeArgumentsOrDiamond = 118
	JavaParserRULE_nonWildcardTypeArguments          = 119
	JavaParserRULE_typeList                          = 120
	JavaParserRULE_typeType                          = 121
	JavaParserRULE_primitiveType                     = 122
	JavaParserRULE_typeArguments                     = 123
	JavaParserRULE_superSuffix                       = 124
	JavaParserRULE_explicitGenericInvocationSuffix   = 125
	JavaParserRULE_arguments                         = 126
)

// ICompilationUnitContext is an interface to support dynamic dispatch.
type ICompilationUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompilationUnitContext differentiates from other interfaces.
	IsCompilationUnitContext()
}

type CompilationUnitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompilationUnitContext() *CompilationUnitContext {
	var p = new(CompilationUnitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_compilationUnit
	return p
}

func (*CompilationUnitContext) IsCompilationUnitContext() {}

func NewCompilationUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompilationUnitContext {
	var p = new(CompilationUnitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_compilationUnit

	return p
}

func (s *CompilationUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *CompilationUnitContext) PackageDeclaration() IPackageDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPackageDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPackageDeclarationContext)
}

func (s *CompilationUnitContext) AllImportDeclaration() []IImportDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IImportDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IImportDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IImportDeclarationContext); ok {
			tst[i] = t.(IImportDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *CompilationUnitContext) ImportDeclaration(i int) IImportDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportDeclarationContext)
}

func (s *CompilationUnitContext) AllTypeDeclaration() []ITypeDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeDeclarationContext); ok {
			len++
		}
	}

	tst := make([]ITypeDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeDeclarationContext); ok {
			tst[i] = t.(ITypeDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *CompilationUnitContext) TypeDeclaration(i int) ITypeDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclarationContext)
}

func (s *CompilationUnitContext) ModuleDeclaration() IModuleDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModuleDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModuleDeclarationContext)
}

func (s *CompilationUnitContext) EOF() antlr.TerminalNode {
	return s.GetToken(JavaParserEOF, 0)
}

func (s *CompilationUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompilationUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompilationUnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterCompilationUnit(s)
	}
}

func (s *CompilationUnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitCompilationUnit(s)
	}
}

func (p *JavaParser) CompilationUnit() (localctx ICompilationUnitContext) {
	this := p
	_ = this

	localctx = NewCompilationUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, JavaParserRULE_compilationUnit)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(272)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(255)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 0, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(254)
				p.PackageDeclaration()
			}

		}
		p.SetState(260)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == JavaParserIMPORT {
			{
				p.SetState(257)
				p.ImportDeclaration()
			}

			p.SetState(262)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(266)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<JavaParserABSTRACT)|(1<<JavaParserCLASS)|(1<<JavaParserENUM)|(1<<JavaParserFINAL)|(1<<JavaParserINTERFACE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(JavaParserPRIVATE-33))|(1<<(JavaParserPROTECTED-33))|(1<<(JavaParserPUBLIC-33))|(1<<(JavaParserSTATIC-33))|(1<<(JavaParserSTRICTFP-33))|(1<<(JavaParserMODULE-33))|(1<<(JavaParserOPEN-33))|(1<<(JavaParserREQUIRES-33))|(1<<(JavaParserEXPORTS-33))|(1<<(JavaParserOPENS-33))|(1<<(JavaParserTO-33))|(1<<(JavaParserUSES-33))|(1<<(JavaParserPROVIDES-33))|(1<<(JavaParserWITH-33))|(1<<(JavaParserTRANSITIVE-33))|(1<<(JavaParserVAR-33))|(1<<(JavaParserYIELD-33))|(1<<(JavaParserRECORD-33))|(1<<(JavaParserSEALED-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(JavaParserPERMITS-65))|(1<<(JavaParserNON_SEALED-65))|(1<<(JavaParserSEMI-65)))) != 0) || _la == JavaParserAT || _la == JavaParserIDENTIFIER {
			{
				p.SetState(263)
				p.TypeDeclaration()
			}

			p.SetState(268)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(269)
			p.ModuleDeclaration()
		}
		{
			p.SetState(270)
			p.Match(JavaParserEOF)
		}

	}

	return localctx
}

// IPackageDeclarationContext is an interface to support dynamic dispatch.
type IPackageDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackageDeclarationContext differentiates from other interfaces.
	IsPackageDeclarationContext()
}

type PackageDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackageDeclarationContext() *PackageDeclarationContext {
	var p = new(PackageDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_packageDeclaration
	return p
}

func (*PackageDeclarationContext) IsPackageDeclarationContext() {}

func NewPackageDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PackageDeclarationContext {
	var p = new(PackageDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_packageDeclaration

	return p
}

func (s *PackageDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PackageDeclarationContext) PACKAGE() antlr.TerminalNode {
	return s.GetToken(JavaParserPACKAGE, 0)
}

func (s *PackageDeclarationContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *PackageDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(JavaParserSEMI, 0)
}

func (s *PackageDeclarationContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *PackageDeclarationContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *PackageDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PackageDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PackageDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterPackageDeclaration(s)
	}
}

func (s *PackageDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitPackageDeclaration(s)
	}
}

func (p *JavaParser) PackageDeclaration() (localctx IPackageDeclarationContext) {
	this := p
	_ = this

	localctx = NewPackageDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, JavaParserRULE_packageDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(277)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-51)&-(0x1f+1)) == 0 && ((1<<uint((_la-51)))&((1<<(JavaParserMODULE-51))|(1<<(JavaParserOPEN-51))|(1<<(JavaParserREQUIRES-51))|(1<<(JavaParserEXPORTS-51))|(1<<(JavaParserOPENS-51))|(1<<(JavaParserTO-51))|(1<<(JavaParserUSES-51))|(1<<(JavaParserPROVIDES-51))|(1<<(JavaParserWITH-51))|(1<<(JavaParserTRANSITIVE-51))|(1<<(JavaParserVAR-51))|(1<<(JavaParserYIELD-51))|(1<<(JavaParserRECORD-51))|(1<<(JavaParserSEALED-51))|(1<<(JavaParserPERMITS-51)))) != 0) || _la == JavaParserAT || _la == JavaParserIDENTIFIER {
		{
			p.SetState(274)
			p.Annotation()
		}

		p.SetState(279)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(280)
		p.Match(JavaParserPACKAGE)
	}
	{
		p.SetState(281)
		p.QualifiedName()
	}
	{
		p.SetState(282)
		p.Match(JavaParserSEMI)
	}

	return localctx
}

// IImportDeclarationContext is an interface to support dynamic dispatch.
type IImportDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImportDeclarationContext differentiates from other interfaces.
	IsImportDeclarationContext()
}

type ImportDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportDeclarationContext() *ImportDeclarationContext {
	var p = new(ImportDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_importDeclaration
	return p
}

func (*ImportDeclarationContext) IsImportDeclarationContext() {}

func NewImportDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportDeclarationContext {
	var p = new(ImportDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_importDeclaration

	return p
}

func (s *ImportDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportDeclarationContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(JavaParserIMPORT, 0)
}

func (s *ImportDeclarationContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ImportDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(JavaParserSEMI, 0)
}

func (s *ImportDeclarationContext) STATIC() antlr.TerminalNode {
	return s.GetToken(JavaParserSTATIC, 0)
}

func (s *ImportDeclarationContext) DOT() antlr.TerminalNode {
	return s.GetToken(JavaParserDOT, 0)
}

func (s *ImportDeclarationContext) MUL() antlr.TerminalNode {
	return s.GetToken(JavaParserMUL, 0)
}

func (s *ImportDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterImportDeclaration(s)
	}
}

func (s *ImportDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitImportDeclaration(s)
	}
}

func (p *JavaParser) ImportDeclaration() (localctx IImportDeclarationContext) {
	this := p
	_ = this

	localctx = NewImportDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, JavaParserRULE_importDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(284)
		p.Match(JavaParserIMPORT)
	}
	p.SetState(286)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserSTATIC {
		{
			p.SetState(285)
			p.Match(JavaParserSTATIC)
		}

	}
	{
		p.SetState(288)
		p.QualifiedName()
	}
	p.SetState(291)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserDOT {
		{
			p.SetState(289)
			p.Match(JavaParserDOT)
		}
		{
			p.SetState(290)
			p.Match(JavaParserMUL)
		}

	}
	{
		p.SetState(293)
		p.Match(JavaParserSEMI)
	}

	return localctx
}

// ITypeDeclarationContext is an interface to support dynamic dispatch.
type ITypeDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeDeclarationContext differentiates from other interfaces.
	IsTypeDeclarationContext()
}

type TypeDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDeclarationContext() *TypeDeclarationContext {
	var p = new(TypeDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_typeDeclaration
	return p
}

func (*TypeDeclarationContext) IsTypeDeclarationContext() {}

func NewTypeDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDeclarationContext {
	var p = new(TypeDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_typeDeclaration

	return p
}

func (s *TypeDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDeclarationContext) ClassDeclaration() IClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *TypeDeclarationContext) EnumDeclaration() IEnumDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumDeclarationContext)
}

func (s *TypeDeclarationContext) InterfaceDeclaration() IInterfaceDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclarationContext)
}

func (s *TypeDeclarationContext) AnnotationTypeDeclaration() IAnnotationTypeDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationTypeDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationTypeDeclarationContext)
}

func (s *TypeDeclarationContext) RecordDeclaration() IRecordDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordDeclarationContext)
}

func (s *TypeDeclarationContext) AllClassOrInterfaceModifier() []IClassOrInterfaceModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassOrInterfaceModifierContext); ok {
			len++
		}
	}

	tst := make([]IClassOrInterfaceModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassOrInterfaceModifierContext); ok {
			tst[i] = t.(IClassOrInterfaceModifierContext)
			i++
		}
	}

	return tst
}

func (s *TypeDeclarationContext) ClassOrInterfaceModifier(i int) IClassOrInterfaceModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOrInterfaceModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOrInterfaceModifierContext)
}

func (s *TypeDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(JavaParserSEMI, 0)
}

func (s *TypeDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterTypeDeclaration(s)
	}
}

func (s *TypeDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitTypeDeclaration(s)
	}
}

func (p *JavaParser) TypeDeclaration() (localctx ITypeDeclarationContext) {
	this := p
	_ = this

	localctx = NewTypeDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, JavaParserRULE_typeDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(309)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JavaParserABSTRACT, JavaParserCLASS, JavaParserENUM, JavaParserFINAL, JavaParserINTERFACE, JavaParserPRIVATE, JavaParserPROTECTED, JavaParserPUBLIC, JavaParserSTATIC, JavaParserSTRICTFP, JavaParserMODULE, JavaParserOPEN, JavaParserREQUIRES, JavaParserEXPORTS, JavaParserOPENS, JavaParserTO, JavaParserUSES, JavaParserPROVIDES, JavaParserWITH, JavaParserTRANSITIVE, JavaParserVAR, JavaParserYIELD, JavaParserRECORD, JavaParserSEALED, JavaParserPERMITS, JavaParserNON_SEALED, JavaParserAT, JavaParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(298)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 7, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(295)
					p.ClassOrInterfaceModifier()
				}

			}
			p.SetState(300)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 7, p.GetParserRuleContext())
		}
		p.SetState(306)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case JavaParserCLASS:
			{
				p.SetState(301)
				p.ClassDeclaration()
			}

		case JavaParserENUM:
			{
				p.SetState(302)
				p.EnumDeclaration()
			}

		case JavaParserINTERFACE:
			{
				p.SetState(303)
				p.InterfaceDeclaration()
			}

		case JavaParserAT:
			{
				p.SetState(304)
				p.AnnotationTypeDeclaration()
			}

		case JavaParserRECORD:
			{
				p.SetState(305)
				p.RecordDeclaration()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case JavaParserSEMI:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(308)
			p.Match(JavaParserSEMI)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IModifierContext is an interface to support dynamic dispatch.
type IModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModifierContext differentiates from other interfaces.
	IsModifierContext()
}

type ModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifierContext() *ModifierContext {
	var p = new(ModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_modifier
	return p
}

func (*ModifierContext) IsModifierContext() {}

func NewModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifierContext {
	var p = new(ModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_modifier

	return p
}

func (s *ModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifierContext) ClassOrInterfaceModifier() IClassOrInterfaceModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOrInterfaceModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOrInterfaceModifierContext)
}

func (s *ModifierContext) NATIVE() antlr.TerminalNode {
	return s.GetToken(JavaParserNATIVE, 0)
}

func (s *ModifierContext) SYNCHRONIZED() antlr.TerminalNode {
	return s.GetToken(JavaParserSYNCHRONIZED, 0)
}

func (s *ModifierContext) TRANSIENT() antlr.TerminalNode {
	return s.GetToken(JavaParserTRANSIENT, 0)
}

func (s *ModifierContext) VOLATILE() antlr.TerminalNode {
	return s.GetToken(JavaParserVOLATILE, 0)
}

func (s *ModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterModifier(s)
	}
}

func (s *ModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitModifier(s)
	}
}

func (p *JavaParser) Modifier() (localctx IModifierContext) {
	this := p
	_ = this

	localctx = NewModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, JavaParserRULE_modifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(316)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JavaParserABSTRACT, JavaParserFINAL, JavaParserPRIVATE, JavaParserPROTECTED, JavaParserPUBLIC, JavaParserSTATIC, JavaParserSTRICTFP, JavaParserMODULE, JavaParserOPEN, JavaParserREQUIRES, JavaParserEXPORTS, JavaParserOPENS, JavaParserTO, JavaParserUSES, JavaParserPROVIDES, JavaParserWITH, JavaParserTRANSITIVE, JavaParserVAR, JavaParserYIELD, JavaParserRECORD, JavaParserSEALED, JavaParserPERMITS, JavaParserNON_SEALED, JavaParserAT, JavaParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(311)
			p.ClassOrInterfaceModifier()
		}

	case JavaParserNATIVE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(312)
			p.Match(JavaParserNATIVE)
		}

	case JavaParserSYNCHRONIZED:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(313)
			p.Match(JavaParserSYNCHRONIZED)
		}

	case JavaParserTRANSIENT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(314)
			p.Match(JavaParserTRANSIENT)
		}

	case JavaParserVOLATILE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(315)
			p.Match(JavaParserVOLATILE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IClassOrInterfaceModifierContext is an interface to support dynamic dispatch.
type IClassOrInterfaceModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassOrInterfaceModifierContext differentiates from other interfaces.
	IsClassOrInterfaceModifierContext()
}

type ClassOrInterfaceModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassOrInterfaceModifierContext() *ClassOrInterfaceModifierContext {
	var p = new(ClassOrInterfaceModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_classOrInterfaceModifier
	return p
}

func (*ClassOrInterfaceModifierContext) IsClassOrInterfaceModifierContext() {}

func NewClassOrInterfaceModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassOrInterfaceModifierContext {
	var p = new(ClassOrInterfaceModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_classOrInterfaceModifier

	return p
}

func (s *ClassOrInterfaceModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassOrInterfaceModifierContext) Annotation() IAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ClassOrInterfaceModifierContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(JavaParserPUBLIC, 0)
}

func (s *ClassOrInterfaceModifierContext) PROTECTED() antlr.TerminalNode {
	return s.GetToken(JavaParserPROTECTED, 0)
}

func (s *ClassOrInterfaceModifierContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(JavaParserPRIVATE, 0)
}

func (s *ClassOrInterfaceModifierContext) STATIC() antlr.TerminalNode {
	return s.GetToken(JavaParserSTATIC, 0)
}

func (s *ClassOrInterfaceModifierContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(JavaParserABSTRACT, 0)
}

func (s *ClassOrInterfaceModifierContext) FINAL() antlr.TerminalNode {
	return s.GetToken(JavaParserFINAL, 0)
}

func (s *ClassOrInterfaceModifierContext) STRICTFP() antlr.TerminalNode {
	return s.GetToken(JavaParserSTRICTFP, 0)
}

func (s *ClassOrInterfaceModifierContext) SEALED() antlr.TerminalNode {
	return s.GetToken(JavaParserSEALED, 0)
}

func (s *ClassOrInterfaceModifierContext) NON_SEALED() antlr.TerminalNode {
	return s.GetToken(JavaParserNON_SEALED, 0)
}

func (s *ClassOrInterfaceModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassOrInterfaceModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassOrInterfaceModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterClassOrInterfaceModifier(s)
	}
}

func (s *ClassOrInterfaceModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitClassOrInterfaceModifier(s)
	}
}

func (p *JavaParser) ClassOrInterfaceModifier() (localctx IClassOrInterfaceModifierContext) {
	this := p
	_ = this

	localctx = NewClassOrInterfaceModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, JavaParserRULE_classOrInterfaceModifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(328)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 11, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(318)
			p.Annotation()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(319)
			p.Match(JavaParserPUBLIC)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(320)
			p.Match(JavaParserPROTECTED)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(321)
			p.Match(JavaParserPRIVATE)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(322)
			p.Match(JavaParserSTATIC)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(323)
			p.Match(JavaParserABSTRACT)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(324)
			p.Match(JavaParserFINAL)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(325)
			p.Match(JavaParserSTRICTFP)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(326)
			p.Match(JavaParserSEALED)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(327)
			p.Match(JavaParserNON_SEALED)
		}

	}

	return localctx
}

// IVariableModifierContext is an interface to support dynamic dispatch.
type IVariableModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableModifierContext differentiates from other interfaces.
	IsVariableModifierContext()
}

type VariableModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableModifierContext() *VariableModifierContext {
	var p = new(VariableModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_variableModifier
	return p
}

func (*VariableModifierContext) IsVariableModifierContext() {}

func NewVariableModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableModifierContext {
	var p = new(VariableModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_variableModifier

	return p
}

func (s *VariableModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableModifierContext) FINAL() antlr.TerminalNode {
	return s.GetToken(JavaParserFINAL, 0)
}

func (s *VariableModifierContext) Annotation() IAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *VariableModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterVariableModifier(s)
	}
}

func (s *VariableModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitVariableModifier(s)
	}
}

func (p *JavaParser) VariableModifier() (localctx IVariableModifierContext) {
	this := p
	_ = this

	localctx = NewVariableModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, JavaParserRULE_variableModifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(332)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JavaParserFINAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(330)
			p.Match(JavaParserFINAL)
		}

	case JavaParserMODULE, JavaParserOPEN, JavaParserREQUIRES, JavaParserEXPORTS, JavaParserOPENS, JavaParserTO, JavaParserUSES, JavaParserPROVIDES, JavaParserWITH, JavaParserTRANSITIVE, JavaParserVAR, JavaParserYIELD, JavaParserRECORD, JavaParserSEALED, JavaParserPERMITS, JavaParserAT, JavaParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(331)
			p.Annotation()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IClassDeclarationContext is an interface to support dynamic dispatch.
type IClassDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassDeclarationContext differentiates from other interfaces.
	IsClassDeclarationContext()
}

type ClassDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassDeclarationContext() *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_classDeclaration
	return p
}

func (*ClassDeclarationContext) IsClassDeclarationContext() {}

func NewClassDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_classDeclaration

	return p
}

func (s *ClassDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassDeclarationContext) CLASS() antlr.TerminalNode {
	return s.GetToken(JavaParserCLASS, 0)
}

func (s *ClassDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassDeclarationContext) ClassBody() IClassBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *ClassDeclarationContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *ClassDeclarationContext) ClassDeclarationExtends() IClassDeclarationExtendsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationExtendsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationExtendsContext)
}

func (s *ClassDeclarationContext) ClassDeclarationImplements() IClassDeclarationImplementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationImplementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationImplementsContext)
}

func (s *ClassDeclarationContext) ClassDeclarationPermits() IClassDeclarationPermitsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationPermitsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationPermitsContext)
}

func (s *ClassDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterClassDeclaration(s)
	}
}

func (s *ClassDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitClassDeclaration(s)
	}
}

func (p *JavaParser) ClassDeclaration() (localctx IClassDeclarationContext) {
	this := p
	_ = this

	localctx = NewClassDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, JavaParserRULE_classDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(334)
		p.Match(JavaParserCLASS)
	}
	{
		p.SetState(335)
		p.Identifier()
	}
	p.SetState(337)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserLT {
		{
			p.SetState(336)
			p.TypeParameters()
		}

	}
	p.SetState(340)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserEXTENDS {
		{
			p.SetState(339)
			p.ClassDeclarationExtends()
		}

	}
	p.SetState(343)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserIMPLEMENTS {
		{
			p.SetState(342)
			p.ClassDeclarationImplements()
		}

	}
	p.SetState(346)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserPERMITS {
		{
			p.SetState(345)
			p.ClassDeclarationPermits()
		}

	}
	{
		p.SetState(348)
		p.ClassBody()
	}

	return localctx
}

// IClassDeclarationExtendsContext is an interface to support dynamic dispatch.
type IClassDeclarationExtendsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassDeclarationExtendsContext differentiates from other interfaces.
	IsClassDeclarationExtendsContext()
}

type ClassDeclarationExtendsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassDeclarationExtendsContext() *ClassDeclarationExtendsContext {
	var p = new(ClassDeclarationExtendsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_classDeclarationExtends
	return p
}

func (*ClassDeclarationExtendsContext) IsClassDeclarationExtendsContext() {}

func NewClassDeclarationExtendsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassDeclarationExtendsContext {
	var p = new(ClassDeclarationExtendsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_classDeclarationExtends

	return p
}

func (s *ClassDeclarationExtendsContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassDeclarationExtendsContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(JavaParserEXTENDS, 0)
}

func (s *ClassDeclarationExtendsContext) TypeType() ITypeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *ClassDeclarationExtendsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassDeclarationExtendsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassDeclarationExtendsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterClassDeclarationExtends(s)
	}
}

func (s *ClassDeclarationExtendsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitClassDeclarationExtends(s)
	}
}

func (p *JavaParser) ClassDeclarationExtends() (localctx IClassDeclarationExtendsContext) {
	this := p
	_ = this

	localctx = NewClassDeclarationExtendsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, JavaParserRULE_classDeclarationExtends)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(350)
		p.Match(JavaParserEXTENDS)
	}
	{
		p.SetState(351)
		p.TypeType()
	}

	return localctx
}

// IClassDeclarationImplementsContext is an interface to support dynamic dispatch.
type IClassDeclarationImplementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassDeclarationImplementsContext differentiates from other interfaces.
	IsClassDeclarationImplementsContext()
}

type ClassDeclarationImplementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassDeclarationImplementsContext() *ClassDeclarationImplementsContext {
	var p = new(ClassDeclarationImplementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_classDeclarationImplements
	return p
}

func (*ClassDeclarationImplementsContext) IsClassDeclarationImplementsContext() {}

func NewClassDeclarationImplementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassDeclarationImplementsContext {
	var p = new(ClassDeclarationImplementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_classDeclarationImplements

	return p
}

func (s *ClassDeclarationImplementsContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassDeclarationImplementsContext) IMPLEMENTS() antlr.TerminalNode {
	return s.GetToken(JavaParserIMPLEMENTS, 0)
}

func (s *ClassDeclarationImplementsContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *ClassDeclarationImplementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassDeclarationImplementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassDeclarationImplementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterClassDeclarationImplements(s)
	}
}

func (s *ClassDeclarationImplementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitClassDeclarationImplements(s)
	}
}

func (p *JavaParser) ClassDeclarationImplements() (localctx IClassDeclarationImplementsContext) {
	this := p
	_ = this

	localctx = NewClassDeclarationImplementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, JavaParserRULE_classDeclarationImplements)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(353)
		p.Match(JavaParserIMPLEMENTS)
	}
	{
		p.SetState(354)
		p.TypeList()
	}

	return localctx
}

// IClassDeclarationPermitsContext is an interface to support dynamic dispatch.
type IClassDeclarationPermitsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassDeclarationPermitsContext differentiates from other interfaces.
	IsClassDeclarationPermitsContext()
}

type ClassDeclarationPermitsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassDeclarationPermitsContext() *ClassDeclarationPermitsContext {
	var p = new(ClassDeclarationPermitsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_classDeclarationPermits
	return p
}

func (*ClassDeclarationPermitsContext) IsClassDeclarationPermitsContext() {}

func NewClassDeclarationPermitsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassDeclarationPermitsContext {
	var p = new(ClassDeclarationPermitsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_classDeclarationPermits

	return p
}

func (s *ClassDeclarationPermitsContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassDeclarationPermitsContext) PERMITS() antlr.TerminalNode {
	return s.GetToken(JavaParserPERMITS, 0)
}

func (s *ClassDeclarationPermitsContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *ClassDeclarationPermitsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassDeclarationPermitsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassDeclarationPermitsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterClassDeclarationPermits(s)
	}
}

func (s *ClassDeclarationPermitsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitClassDeclarationPermits(s)
	}
}

func (p *JavaParser) ClassDeclarationPermits() (localctx IClassDeclarationPermitsContext) {
	this := p
	_ = this

	localctx = NewClassDeclarationPermitsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, JavaParserRULE_classDeclarationPermits)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(356)
		p.Match(JavaParserPERMITS)
	}
	{
		p.SetState(357)
		p.TypeList()
	}

	return localctx
}

// ITypeParametersContext is an interface to support dynamic dispatch.
type ITypeParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeParametersContext differentiates from other interfaces.
	IsTypeParametersContext()
}

type TypeParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParametersContext() *TypeParametersContext {
	var p = new(TypeParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_typeParameters
	return p
}

func (*TypeParametersContext) IsTypeParametersContext() {}

func NewTypeParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParametersContext {
	var p = new(TypeParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_typeParameters

	return p
}

func (s *TypeParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParametersContext) LT() antlr.TerminalNode {
	return s.GetToken(JavaParserLT, 0)
}

func (s *TypeParametersContext) AllTypeParameter() []ITypeParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeParameterContext); ok {
			len++
		}
	}

	tst := make([]ITypeParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeParameterContext); ok {
			tst[i] = t.(ITypeParameterContext)
			i++
		}
	}

	return tst
}

func (s *TypeParametersContext) TypeParameter(i int) ITypeParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParameterContext)
}

func (s *TypeParametersContext) GT() antlr.TerminalNode {
	return s.GetToken(JavaParserGT, 0)
}

func (s *TypeParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(JavaParserCOMMA)
}

func (s *TypeParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserCOMMA, i)
}

func (s *TypeParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterTypeParameters(s)
	}
}

func (s *TypeParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitTypeParameters(s)
	}
}

func (p *JavaParser) TypeParameters() (localctx ITypeParametersContext) {
	this := p
	_ = this

	localctx = NewTypeParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, JavaParserRULE_typeParameters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(359)
		p.Match(JavaParserLT)
	}
	{
		p.SetState(360)
		p.TypeParameter()
	}
	p.SetState(365)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == JavaParserCOMMA {
		{
			p.SetState(361)
			p.Match(JavaParserCOMMA)
		}
		{
			p.SetState(362)
			p.TypeParameter()
		}

		p.SetState(367)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(368)
		p.Match(JavaParserGT)
	}

	return localctx
}

// ITypeParameterContext is an interface to support dynamic dispatch.
type ITypeParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeParameterContext differentiates from other interfaces.
	IsTypeParameterContext()
}

type TypeParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterContext() *TypeParameterContext {
	var p = new(TypeParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_typeParameter
	return p
}

func (*TypeParameterContext) IsTypeParameterContext() {}

func NewTypeParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterContext {
	var p = new(TypeParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_typeParameter

	return p
}

func (s *TypeParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TypeParameterContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *TypeParameterContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *TypeParameterContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(JavaParserEXTENDS, 0)
}

func (s *TypeParameterContext) TypeBound() ITypeBoundContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeBoundContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeBoundContext)
}

func (s *TypeParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterTypeParameter(s)
	}
}

func (s *TypeParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitTypeParameter(s)
	}
}

func (p *JavaParser) TypeParameter() (localctx ITypeParameterContext) {
	this := p
	_ = this

	localctx = NewTypeParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, JavaParserRULE_typeParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(373)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(370)
				p.Annotation()
			}

		}
		p.SetState(375)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext())
	}
	{
		p.SetState(376)
		p.Identifier()
	}
	p.SetState(385)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserEXTENDS {
		{
			p.SetState(377)
			p.Match(JavaParserEXTENDS)
		}
		p.SetState(381)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(378)
					p.Annotation()
				}

			}
			p.SetState(383)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext())
		}
		{
			p.SetState(384)
			p.TypeBound()
		}

	}

	return localctx
}

// ITypeBoundContext is an interface to support dynamic dispatch.
type ITypeBoundContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeBoundContext differentiates from other interfaces.
	IsTypeBoundContext()
}

type TypeBoundContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeBoundContext() *TypeBoundContext {
	var p = new(TypeBoundContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_typeBound
	return p
}

func (*TypeBoundContext) IsTypeBoundContext() {}

func NewTypeBoundContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeBoundContext {
	var p = new(TypeBoundContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_typeBound

	return p
}

func (s *TypeBoundContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeBoundContext) AllTypeType() []ITypeTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeTypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeTypeContext); ok {
			tst[i] = t.(ITypeTypeContext)
			i++
		}
	}

	return tst
}

func (s *TypeBoundContext) TypeType(i int) ITypeTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *TypeBoundContext) AllBITAND() []antlr.TerminalNode {
	return s.GetTokens(JavaParserBITAND)
}

func (s *TypeBoundContext) BITAND(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserBITAND, i)
}

func (s *TypeBoundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeBoundContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeBoundContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterTypeBound(s)
	}
}

func (s *TypeBoundContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitTypeBound(s)
	}
}

func (p *JavaParser) TypeBound() (localctx ITypeBoundContext) {
	this := p
	_ = this

	localctx = NewTypeBoundContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, JavaParserRULE_typeBound)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(387)
		p.TypeType()
	}
	p.SetState(392)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == JavaParserBITAND {
		{
			p.SetState(388)
			p.Match(JavaParserBITAND)
		}
		{
			p.SetState(389)
			p.TypeType()
		}

		p.SetState(394)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IEnumDeclarationContext is an interface to support dynamic dispatch.
type IEnumDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumDeclarationContext differentiates from other interfaces.
	IsEnumDeclarationContext()
}

type EnumDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumDeclarationContext() *EnumDeclarationContext {
	var p = new(EnumDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_enumDeclaration
	return p
}

func (*EnumDeclarationContext) IsEnumDeclarationContext() {}

func NewEnumDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumDeclarationContext {
	var p = new(EnumDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_enumDeclaration

	return p
}

func (s *EnumDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumDeclarationContext) ENUM() antlr.TerminalNode {
	return s.GetToken(JavaParserENUM, 0)
}

func (s *EnumDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EnumDeclarationContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(JavaParserLBRACE, 0)
}

func (s *EnumDeclarationContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(JavaParserRBRACE, 0)
}

func (s *EnumDeclarationContext) IMPLEMENTS() antlr.TerminalNode {
	return s.GetToken(JavaParserIMPLEMENTS, 0)
}

func (s *EnumDeclarationContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *EnumDeclarationContext) EnumConstants() IEnumConstantsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumConstantsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumConstantsContext)
}

func (s *EnumDeclarationContext) COMMA() antlr.TerminalNode {
	return s.GetToken(JavaParserCOMMA, 0)
}

func (s *EnumDeclarationContext) EnumBodyDeclarations() IEnumBodyDeclarationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumBodyDeclarationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumBodyDeclarationsContext)
}

func (s *EnumDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterEnumDeclaration(s)
	}
}

func (s *EnumDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitEnumDeclaration(s)
	}
}

func (p *JavaParser) EnumDeclaration() (localctx IEnumDeclarationContext) {
	this := p
	_ = this

	localctx = NewEnumDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, JavaParserRULE_enumDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(395)
		p.Match(JavaParserENUM)
	}
	{
		p.SetState(396)
		p.Identifier()
	}
	p.SetState(399)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserIMPLEMENTS {
		{
			p.SetState(397)
			p.Match(JavaParserIMPLEMENTS)
		}
		{
			p.SetState(398)
			p.TypeList()
		}

	}
	{
		p.SetState(401)
		p.Match(JavaParserLBRACE)
	}
	p.SetState(403)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-51)&-(0x1f+1)) == 0 && ((1<<uint((_la-51)))&((1<<(JavaParserMODULE-51))|(1<<(JavaParserOPEN-51))|(1<<(JavaParserREQUIRES-51))|(1<<(JavaParserEXPORTS-51))|(1<<(JavaParserOPENS-51))|(1<<(JavaParserTO-51))|(1<<(JavaParserUSES-51))|(1<<(JavaParserPROVIDES-51))|(1<<(JavaParserWITH-51))|(1<<(JavaParserTRANSITIVE-51))|(1<<(JavaParserVAR-51))|(1<<(JavaParserYIELD-51))|(1<<(JavaParserRECORD-51))|(1<<(JavaParserSEALED-51))|(1<<(JavaParserPERMITS-51)))) != 0) || _la == JavaParserAT || _la == JavaParserIDENTIFIER {
		{
			p.SetState(402)
			p.EnumConstants()
		}

	}
	p.SetState(406)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserCOMMA {
		{
			p.SetState(405)
			p.Match(JavaParserCOMMA)
		}

	}
	p.SetState(409)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserSEMI {
		{
			p.SetState(408)
			p.EnumBodyDeclarations()
		}

	}
	{
		p.SetState(411)
		p.Match(JavaParserRBRACE)
	}

	return localctx
}

// IEnumConstantsContext is an interface to support dynamic dispatch.
type IEnumConstantsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumConstantsContext differentiates from other interfaces.
	IsEnumConstantsContext()
}

type EnumConstantsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumConstantsContext() *EnumConstantsContext {
	var p = new(EnumConstantsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_enumConstants
	return p
}

func (*EnumConstantsContext) IsEnumConstantsContext() {}

func NewEnumConstantsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumConstantsContext {
	var p = new(EnumConstantsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_enumConstants

	return p
}

func (s *EnumConstantsContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumConstantsContext) AllEnumConstant() []IEnumConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnumConstantContext); ok {
			len++
		}
	}

	tst := make([]IEnumConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnumConstantContext); ok {
			tst[i] = t.(IEnumConstantContext)
			i++
		}
	}

	return tst
}

func (s *EnumConstantsContext) EnumConstant(i int) IEnumConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumConstantContext)
}

func (s *EnumConstantsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(JavaParserCOMMA)
}

func (s *EnumConstantsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserCOMMA, i)
}

func (s *EnumConstantsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumConstantsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumConstantsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterEnumConstants(s)
	}
}

func (s *EnumConstantsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitEnumConstants(s)
	}
}

func (p *JavaParser) EnumConstants() (localctx IEnumConstantsContext) {
	this := p
	_ = this

	localctx = NewEnumConstantsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, JavaParserRULE_enumConstants)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(413)
		p.EnumConstant()
	}
	p.SetState(418)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(414)
				p.Match(JavaParserCOMMA)
			}
			{
				p.SetState(415)
				p.EnumConstant()
			}

		}
		p.SetState(420)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext())
	}

	return localctx
}

// IEnumConstantContext is an interface to support dynamic dispatch.
type IEnumConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumConstantContext differentiates from other interfaces.
	IsEnumConstantContext()
}

type EnumConstantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumConstantContext() *EnumConstantContext {
	var p = new(EnumConstantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_enumConstant
	return p
}

func (*EnumConstantContext) IsEnumConstantContext() {}

func NewEnumConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumConstantContext {
	var p = new(EnumConstantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_enumConstant

	return p
}

func (s *EnumConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumConstantContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EnumConstantContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *EnumConstantContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *EnumConstantContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *EnumConstantContext) ClassBody() IClassBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *EnumConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterEnumConstant(s)
	}
}

func (s *EnumConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitEnumConstant(s)
	}
}

func (p *JavaParser) EnumConstant() (localctx IEnumConstantContext) {
	this := p
	_ = this

	localctx = NewEnumConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, JavaParserRULE_enumConstant)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(424)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(421)
				p.Annotation()
			}

		}
		p.SetState(426)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext())
	}
	{
		p.SetState(427)
		p.Identifier()
	}
	p.SetState(429)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserLPAREN {
		{
			p.SetState(428)
			p.Arguments()
		}

	}
	p.SetState(432)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserLBRACE {
		{
			p.SetState(431)
			p.ClassBody()
		}

	}

	return localctx
}

// IEnumBodyDeclarationsContext is an interface to support dynamic dispatch.
type IEnumBodyDeclarationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumBodyDeclarationsContext differentiates from other interfaces.
	IsEnumBodyDeclarationsContext()
}

type EnumBodyDeclarationsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumBodyDeclarationsContext() *EnumBodyDeclarationsContext {
	var p = new(EnumBodyDeclarationsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_enumBodyDeclarations
	return p
}

func (*EnumBodyDeclarationsContext) IsEnumBodyDeclarationsContext() {}

func NewEnumBodyDeclarationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumBodyDeclarationsContext {
	var p = new(EnumBodyDeclarationsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_enumBodyDeclarations

	return p
}

func (s *EnumBodyDeclarationsContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumBodyDeclarationsContext) SEMI() antlr.TerminalNode {
	return s.GetToken(JavaParserSEMI, 0)
}

func (s *EnumBodyDeclarationsContext) AllClassBodyDeclaration() []IClassBodyDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassBodyDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IClassBodyDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassBodyDeclarationContext); ok {
			tst[i] = t.(IClassBodyDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *EnumBodyDeclarationsContext) ClassBodyDeclaration(i int) IClassBodyDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBodyDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBodyDeclarationContext)
}

func (s *EnumBodyDeclarationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumBodyDeclarationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumBodyDeclarationsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterEnumBodyDeclarations(s)
	}
}

func (s *EnumBodyDeclarationsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitEnumBodyDeclarations(s)
	}
}

func (p *JavaParser) EnumBodyDeclarations() (localctx IEnumBodyDeclarationsContext) {
	this := p
	_ = this

	localctx = NewEnumBodyDeclarationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, JavaParserRULE_enumBodyDeclarations)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(434)
		p.Match(JavaParserSEMI)
	}
	p.SetState(438)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<JavaParserABSTRACT)|(1<<JavaParserBOOLEAN)|(1<<JavaParserBYTE)|(1<<JavaParserCHAR)|(1<<JavaParserCLASS)|(1<<JavaParserDOUBLE)|(1<<JavaParserENUM)|(1<<JavaParserFINAL)|(1<<JavaParserFLOAT)|(1<<JavaParserINT)|(1<<JavaParserINTERFACE)|(1<<JavaParserLONG)|(1<<JavaParserNATIVE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(JavaParserPRIVATE-33))|(1<<(JavaParserPROTECTED-33))|(1<<(JavaParserPUBLIC-33))|(1<<(JavaParserSHORT-33))|(1<<(JavaParserSTATIC-33))|(1<<(JavaParserSTRICTFP-33))|(1<<(JavaParserSYNCHRONIZED-33))|(1<<(JavaParserTRANSIENT-33))|(1<<(JavaParserVOID-33))|(1<<(JavaParserVOLATILE-33))|(1<<(JavaParserMODULE-33))|(1<<(JavaParserOPEN-33))|(1<<(JavaParserREQUIRES-33))|(1<<(JavaParserEXPORTS-33))|(1<<(JavaParserOPENS-33))|(1<<(JavaParserTO-33))|(1<<(JavaParserUSES-33))|(1<<(JavaParserPROVIDES-33))|(1<<(JavaParserWITH-33))|(1<<(JavaParserTRANSITIVE-33))|(1<<(JavaParserVAR-33))|(1<<(JavaParserYIELD-33))|(1<<(JavaParserRECORD-33))|(1<<(JavaParserSEALED-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(JavaParserPERMITS-65))|(1<<(JavaParserNON_SEALED-65))|(1<<(JavaParserLBRACE-65))|(1<<(JavaParserSEMI-65))|(1<<(JavaParserLT-65)))) != 0) || _la == JavaParserAT || _la == JavaParserIDENTIFIER {
		{
			p.SetState(435)
			p.ClassBodyDeclaration()
		}

		p.SetState(440)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInterfaceDeclarationContext is an interface to support dynamic dispatch.
type IInterfaceDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterfaceDeclarationContext differentiates from other interfaces.
	IsInterfaceDeclarationContext()
}

type InterfaceDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceDeclarationContext() *InterfaceDeclarationContext {
	var p = new(InterfaceDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_interfaceDeclaration
	return p
}

func (*InterfaceDeclarationContext) IsInterfaceDeclarationContext() {}

func NewInterfaceDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceDeclarationContext {
	var p = new(InterfaceDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_interfaceDeclaration

	return p
}

func (s *InterfaceDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceDeclarationContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(JavaParserINTERFACE, 0)
}

func (s *InterfaceDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InterfaceDeclarationContext) InterfaceBody() IInterfaceBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceBodyContext)
}

func (s *InterfaceDeclarationContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *InterfaceDeclarationContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(JavaParserEXTENDS, 0)
}

func (s *InterfaceDeclarationContext) AllTypeList() []ITypeListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeListContext); ok {
			len++
		}
	}

	tst := make([]ITypeListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeListContext); ok {
			tst[i] = t.(ITypeListContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceDeclarationContext) TypeList(i int) ITypeListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *InterfaceDeclarationContext) PERMITS() antlr.TerminalNode {
	return s.GetToken(JavaParserPERMITS, 0)
}

func (s *InterfaceDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterInterfaceDeclaration(s)
	}
}

func (s *InterfaceDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitInterfaceDeclaration(s)
	}
}

func (p *JavaParser) InterfaceDeclaration() (localctx IInterfaceDeclarationContext) {
	this := p
	_ = this

	localctx = NewInterfaceDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, JavaParserRULE_interfaceDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(441)
		p.Match(JavaParserINTERFACE)
	}
	{
		p.SetState(442)
		p.Identifier()
	}
	p.SetState(444)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserLT {
		{
			p.SetState(443)
			p.TypeParameters()
		}

	}
	p.SetState(448)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserEXTENDS {
		{
			p.SetState(446)
			p.Match(JavaParserEXTENDS)
		}
		{
			p.SetState(447)
			p.TypeList()
		}

	}
	p.SetState(452)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserPERMITS {
		{
			p.SetState(450)
			p.Match(JavaParserPERMITS)
		}
		{
			p.SetState(451)
			p.TypeList()
		}

	}
	{
		p.SetState(454)
		p.InterfaceBody()
	}

	return localctx
}

// IClassBodyContext is an interface to support dynamic dispatch.
type IClassBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassBodyContext differentiates from other interfaces.
	IsClassBodyContext()
}

type ClassBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassBodyContext() *ClassBodyContext {
	var p = new(ClassBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_classBody
	return p
}

func (*ClassBodyContext) IsClassBodyContext() {}

func NewClassBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassBodyContext {
	var p = new(ClassBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_classBody

	return p
}

func (s *ClassBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(JavaParserLBRACE, 0)
}

func (s *ClassBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(JavaParserRBRACE, 0)
}

func (s *ClassBodyContext) AllClassBodyDeclaration() []IClassBodyDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassBodyDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IClassBodyDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassBodyDeclarationContext); ok {
			tst[i] = t.(IClassBodyDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *ClassBodyContext) ClassBodyDeclaration(i int) IClassBodyDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBodyDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBodyDeclarationContext)
}

func (s *ClassBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterClassBody(s)
	}
}

func (s *ClassBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitClassBody(s)
	}
}

func (p *JavaParser) ClassBody() (localctx IClassBodyContext) {
	this := p
	_ = this

	localctx = NewClassBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, JavaParserRULE_classBody)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(456)
		p.Match(JavaParserLBRACE)
	}
	p.SetState(460)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<JavaParserABSTRACT)|(1<<JavaParserBOOLEAN)|(1<<JavaParserBYTE)|(1<<JavaParserCHAR)|(1<<JavaParserCLASS)|(1<<JavaParserDOUBLE)|(1<<JavaParserENUM)|(1<<JavaParserFINAL)|(1<<JavaParserFLOAT)|(1<<JavaParserINT)|(1<<JavaParserINTERFACE)|(1<<JavaParserLONG)|(1<<JavaParserNATIVE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(JavaParserPRIVATE-33))|(1<<(JavaParserPROTECTED-33))|(1<<(JavaParserPUBLIC-33))|(1<<(JavaParserSHORT-33))|(1<<(JavaParserSTATIC-33))|(1<<(JavaParserSTRICTFP-33))|(1<<(JavaParserSYNCHRONIZED-33))|(1<<(JavaParserTRANSIENT-33))|(1<<(JavaParserVOID-33))|(1<<(JavaParserVOLATILE-33))|(1<<(JavaParserMODULE-33))|(1<<(JavaParserOPEN-33))|(1<<(JavaParserREQUIRES-33))|(1<<(JavaParserEXPORTS-33))|(1<<(JavaParserOPENS-33))|(1<<(JavaParserTO-33))|(1<<(JavaParserUSES-33))|(1<<(JavaParserPROVIDES-33))|(1<<(JavaParserWITH-33))|(1<<(JavaParserTRANSITIVE-33))|(1<<(JavaParserVAR-33))|(1<<(JavaParserYIELD-33))|(1<<(JavaParserRECORD-33))|(1<<(JavaParserSEALED-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(JavaParserPERMITS-65))|(1<<(JavaParserNON_SEALED-65))|(1<<(JavaParserLBRACE-65))|(1<<(JavaParserSEMI-65))|(1<<(JavaParserLT-65)))) != 0) || _la == JavaParserAT || _la == JavaParserIDENTIFIER {
		{
			p.SetState(457)
			p.ClassBodyDeclaration()
		}

		p.SetState(462)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(463)
		p.Match(JavaParserRBRACE)
	}

	return localctx
}

// IInterfaceBodyContext is an interface to support dynamic dispatch.
type IInterfaceBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterfaceBodyContext differentiates from other interfaces.
	IsInterfaceBodyContext()
}

type InterfaceBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceBodyContext() *InterfaceBodyContext {
	var p = new(InterfaceBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_interfaceBody
	return p
}

func (*InterfaceBodyContext) IsInterfaceBodyContext() {}

func NewInterfaceBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceBodyContext {
	var p = new(InterfaceBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_interfaceBody

	return p
}

func (s *InterfaceBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(JavaParserLBRACE, 0)
}

func (s *InterfaceBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(JavaParserRBRACE, 0)
}

func (s *InterfaceBodyContext) AllInterfaceBodyDeclaration() []IInterfaceBodyDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInterfaceBodyDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IInterfaceBodyDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInterfaceBodyDeclarationContext); ok {
			tst[i] = t.(IInterfaceBodyDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceBodyContext) InterfaceBodyDeclaration(i int) IInterfaceBodyDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceBodyDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceBodyDeclarationContext)
}

func (s *InterfaceBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterInterfaceBody(s)
	}
}

func (s *InterfaceBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitInterfaceBody(s)
	}
}

func (p *JavaParser) InterfaceBody() (localctx IInterfaceBodyContext) {
	this := p
	_ = this

	localctx = NewInterfaceBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, JavaParserRULE_interfaceBody)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(465)
		p.Match(JavaParserLBRACE)
	}
	p.SetState(469)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<JavaParserABSTRACT)|(1<<JavaParserBOOLEAN)|(1<<JavaParserBYTE)|(1<<JavaParserCHAR)|(1<<JavaParserCLASS)|(1<<JavaParserDEFAULT)|(1<<JavaParserDOUBLE)|(1<<JavaParserENUM)|(1<<JavaParserFINAL)|(1<<JavaParserFLOAT)|(1<<JavaParserINT)|(1<<JavaParserINTERFACE)|(1<<JavaParserLONG)|(1<<JavaParserNATIVE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(JavaParserPRIVATE-33))|(1<<(JavaParserPROTECTED-33))|(1<<(JavaParserPUBLIC-33))|(1<<(JavaParserSHORT-33))|(1<<(JavaParserSTATIC-33))|(1<<(JavaParserSTRICTFP-33))|(1<<(JavaParserSYNCHRONIZED-33))|(1<<(JavaParserTRANSIENT-33))|(1<<(JavaParserVOID-33))|(1<<(JavaParserVOLATILE-33))|(1<<(JavaParserMODULE-33))|(1<<(JavaParserOPEN-33))|(1<<(JavaParserREQUIRES-33))|(1<<(JavaParserEXPORTS-33))|(1<<(JavaParserOPENS-33))|(1<<(JavaParserTO-33))|(1<<(JavaParserUSES-33))|(1<<(JavaParserPROVIDES-33))|(1<<(JavaParserWITH-33))|(1<<(JavaParserTRANSITIVE-33))|(1<<(JavaParserVAR-33))|(1<<(JavaParserYIELD-33))|(1<<(JavaParserRECORD-33))|(1<<(JavaParserSEALED-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(JavaParserPERMITS-65))|(1<<(JavaParserNON_SEALED-65))|(1<<(JavaParserSEMI-65))|(1<<(JavaParserLT-65)))) != 0) || _la == JavaParserAT || _la == JavaParserIDENTIFIER {
		{
			p.SetState(466)
			p.InterfaceBodyDeclaration()
		}

		p.SetState(471)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(472)
		p.Match(JavaParserRBRACE)
	}

	return localctx
}

// IClassBodyDeclarationContext is an interface to support dynamic dispatch.
type IClassBodyDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassBodyDeclarationContext differentiates from other interfaces.
	IsClassBodyDeclarationContext()
}

type ClassBodyDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassBodyDeclarationContext() *ClassBodyDeclarationContext {
	var p = new(ClassBodyDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_classBodyDeclaration
	return p
}

func (*ClassBodyDeclarationContext) IsClassBodyDeclarationContext() {}

func NewClassBodyDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassBodyDeclarationContext {
	var p = new(ClassBodyDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_classBodyDeclaration

	return p
}

func (s *ClassBodyDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassBodyDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(JavaParserSEMI, 0)
}

func (s *ClassBodyDeclarationContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ClassBodyDeclarationContext) STATIC() antlr.TerminalNode {
	return s.GetToken(JavaParserSTATIC, 0)
}

func (s *ClassBodyDeclarationContext) MemberDeclaration() IMemberDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberDeclarationContext)
}

func (s *ClassBodyDeclarationContext) AllModifier() []IModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModifierContext); ok {
			len++
		}
	}

	tst := make([]IModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModifierContext); ok {
			tst[i] = t.(IModifierContext)
			i++
		}
	}

	return tst
}

func (s *ClassBodyDeclarationContext) Modifier(i int) IModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *ClassBodyDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassBodyDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassBodyDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterClassBodyDeclaration(s)
	}
}

func (s *ClassBodyDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitClassBodyDeclaration(s)
	}
}

func (p *JavaParser) ClassBodyDeclaration() (localctx IClassBodyDeclarationContext) {
	this := p
	_ = this

	localctx = NewClassBodyDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, JavaParserRULE_classBodyDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(486)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 38, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(474)
			p.Match(JavaParserSEMI)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(476)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JavaParserSTATIC {
			{
				p.SetState(475)
				p.Match(JavaParserSTATIC)
			}

		}
		{
			p.SetState(478)
			p.Block()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(482)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(479)
					p.Modifier()
				}

			}
			p.SetState(484)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext())
		}
		{
			p.SetState(485)
			p.MemberDeclaration()
		}

	}

	return localctx
}

// IMemberDeclarationContext is an interface to support dynamic dispatch.
type IMemberDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMemberDeclarationContext differentiates from other interfaces.
	IsMemberDeclarationContext()
}

type MemberDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemberDeclarationContext() *MemberDeclarationContext {
	var p = new(MemberDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_memberDeclaration
	return p
}

func (*MemberDeclarationContext) IsMemberDeclarationContext() {}

func NewMemberDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemberDeclarationContext {
	var p = new(MemberDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_memberDeclaration

	return p
}

func (s *MemberDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *MemberDeclarationContext) MethodDeclaration() IMethodDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodDeclarationContext)
}

func (s *MemberDeclarationContext) GenericMethodDeclaration() IGenericMethodDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericMethodDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericMethodDeclarationContext)
}

func (s *MemberDeclarationContext) FieldDeclaration() IFieldDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldDeclarationContext)
}

func (s *MemberDeclarationContext) ConstructorDeclaration() IConstructorDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstructorDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstructorDeclarationContext)
}

func (s *MemberDeclarationContext) GenericConstructorDeclaration() IGenericConstructorDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericConstructorDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericConstructorDeclarationContext)
}

func (s *MemberDeclarationContext) InterfaceDeclaration() IInterfaceDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclarationContext)
}

func (s *MemberDeclarationContext) AnnotationTypeDeclaration() IAnnotationTypeDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationTypeDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationTypeDeclarationContext)
}

func (s *MemberDeclarationContext) ClassDeclaration() IClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *MemberDeclarationContext) EnumDeclaration() IEnumDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumDeclarationContext)
}

func (s *MemberDeclarationContext) RecordDeclaration() IRecordDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordDeclarationContext)
}

func (s *MemberDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemberDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterMemberDeclaration(s)
	}
}

func (s *MemberDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitMemberDeclaration(s)
	}
}

func (p *JavaParser) MemberDeclaration() (localctx IMemberDeclarationContext) {
	this := p
	_ = this

	localctx = NewMemberDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, JavaParserRULE_memberDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(498)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(488)
			p.MethodDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(489)
			p.GenericMethodDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(490)
			p.FieldDeclaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(491)
			p.ConstructorDeclaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(492)
			p.GenericConstructorDeclaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(493)
			p.InterfaceDeclaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(494)
			p.AnnotationTypeDeclaration()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(495)
			p.ClassDeclaration()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(496)
			p.EnumDeclaration()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(497)
			p.RecordDeclaration()
		}

	}

	return localctx
}

// IMethodDeclarationContext is an interface to support dynamic dispatch.
type IMethodDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethodDeclarationContext differentiates from other interfaces.
	IsMethodDeclarationContext()
}

type MethodDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodDeclarationContext() *MethodDeclarationContext {
	var p = new(MethodDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_methodDeclaration
	return p
}

func (*MethodDeclarationContext) IsMethodDeclarationContext() {}

func NewMethodDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodDeclarationContext {
	var p = new(MethodDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_methodDeclaration

	return p
}

func (s *MethodDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodDeclarationContext) TypeTypeOrVoid() ITypeTypeOrVoidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeOrVoidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeOrVoidContext)
}

func (s *MethodDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MethodDeclarationContext) FormalParameters() IFormalParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParametersContext)
}

func (s *MethodDeclarationContext) MethodBody() IMethodBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodBodyContext)
}

func (s *MethodDeclarationContext) AllLBRACK() []antlr.TerminalNode {
	return s.GetTokens(JavaParserLBRACK)
}

func (s *MethodDeclarationContext) LBRACK(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserLBRACK, i)
}

func (s *MethodDeclarationContext) AllRBRACK() []antlr.TerminalNode {
	return s.GetTokens(JavaParserRBRACK)
}

func (s *MethodDeclarationContext) RBRACK(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserRBRACK, i)
}

func (s *MethodDeclarationContext) THROWS() antlr.TerminalNode {
	return s.GetToken(JavaParserTHROWS, 0)
}

func (s *MethodDeclarationContext) QualifiedNameList() IQualifiedNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameListContext)
}

func (s *MethodDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterMethodDeclaration(s)
	}
}

func (s *MethodDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitMethodDeclaration(s)
	}
}

func (p *JavaParser) MethodDeclaration() (localctx IMethodDeclarationContext) {
	this := p
	_ = this

	localctx = NewMethodDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, JavaParserRULE_methodDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(500)
		p.TypeTypeOrVoid()
	}
	{
		p.SetState(501)
		p.Identifier()
	}
	{
		p.SetState(502)
		p.FormalParameters()
	}
	p.SetState(507)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == JavaParserLBRACK {
		{
			p.SetState(503)
			p.Match(JavaParserLBRACK)
		}
		{
			p.SetState(504)
			p.Match(JavaParserRBRACK)
		}

		p.SetState(509)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(512)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserTHROWS {
		{
			p.SetState(510)
			p.Match(JavaParserTHROWS)
		}
		{
			p.SetState(511)
			p.QualifiedNameList()
		}

	}
	{
		p.SetState(514)
		p.MethodBody()
	}

	return localctx
}

// IMethodBodyContext is an interface to support dynamic dispatch.
type IMethodBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethodBodyContext differentiates from other interfaces.
	IsMethodBodyContext()
}

type MethodBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodBodyContext() *MethodBodyContext {
	var p = new(MethodBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_methodBody
	return p
}

func (*MethodBodyContext) IsMethodBodyContext() {}

func NewMethodBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodBodyContext {
	var p = new(MethodBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_methodBody

	return p
}

func (s *MethodBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodBodyContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *MethodBodyContext) SEMI() antlr.TerminalNode {
	return s.GetToken(JavaParserSEMI, 0)
}

func (s *MethodBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterMethodBody(s)
	}
}

func (s *MethodBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitMethodBody(s)
	}
}

func (p *JavaParser) MethodBody() (localctx IMethodBodyContext) {
	this := p
	_ = this

	localctx = NewMethodBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, JavaParserRULE_methodBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(518)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JavaParserLBRACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(516)
			p.Block()
		}

	case JavaParserSEMI:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(517)
			p.Match(JavaParserSEMI)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITypeTypeOrVoidContext is an interface to support dynamic dispatch.
type ITypeTypeOrVoidContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeTypeOrVoidContext differentiates from other interfaces.
	IsTypeTypeOrVoidContext()
}

type TypeTypeOrVoidContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeTypeOrVoidContext() *TypeTypeOrVoidContext {
	var p = new(TypeTypeOrVoidContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_typeTypeOrVoid
	return p
}

func (*TypeTypeOrVoidContext) IsTypeTypeOrVoidContext() {}

func NewTypeTypeOrVoidContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeTypeOrVoidContext {
	var p = new(TypeTypeOrVoidContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_typeTypeOrVoid

	return p
}

func (s *TypeTypeOrVoidContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeTypeOrVoidContext) TypeType() ITypeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *TypeTypeOrVoidContext) VOID() antlr.TerminalNode {
	return s.GetToken(JavaParserVOID, 0)
}

func (s *TypeTypeOrVoidContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeTypeOrVoidContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeTypeOrVoidContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterTypeTypeOrVoid(s)
	}
}

func (s *TypeTypeOrVoidContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitTypeTypeOrVoid(s)
	}
}

func (p *JavaParser) TypeTypeOrVoid() (localctx ITypeTypeOrVoidContext) {
	this := p
	_ = this

	localctx = NewTypeTypeOrVoidContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, JavaParserRULE_typeTypeOrVoid)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(522)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JavaParserBOOLEAN, JavaParserBYTE, JavaParserCHAR, JavaParserDOUBLE, JavaParserFLOAT, JavaParserINT, JavaParserLONG, JavaParserSHORT, JavaParserMODULE, JavaParserOPEN, JavaParserREQUIRES, JavaParserEXPORTS, JavaParserOPENS, JavaParserTO, JavaParserUSES, JavaParserPROVIDES, JavaParserWITH, JavaParserTRANSITIVE, JavaParserVAR, JavaParserYIELD, JavaParserRECORD, JavaParserSEALED, JavaParserPERMITS, JavaParserAT, JavaParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(520)
			p.TypeType()
		}

	case JavaParserVOID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(521)
			p.Match(JavaParserVOID)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IGenericMethodDeclarationContext is an interface to support dynamic dispatch.
type IGenericMethodDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenericMethodDeclarationContext differentiates from other interfaces.
	IsGenericMethodDeclarationContext()
}

type GenericMethodDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericMethodDeclarationContext() *GenericMethodDeclarationContext {
	var p = new(GenericMethodDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_genericMethodDeclaration
	return p
}

func (*GenericMethodDeclarationContext) IsGenericMethodDeclarationContext() {}

func NewGenericMethodDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericMethodDeclarationContext {
	var p = new(GenericMethodDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_genericMethodDeclaration

	return p
}

func (s *GenericMethodDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericMethodDeclarationContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *GenericMethodDeclarationContext) MethodDeclaration() IMethodDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodDeclarationContext)
}

func (s *GenericMethodDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericMethodDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericMethodDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterGenericMethodDeclaration(s)
	}
}

func (s *GenericMethodDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitGenericMethodDeclaration(s)
	}
}

func (p *JavaParser) GenericMethodDeclaration() (localctx IGenericMethodDeclarationContext) {
	this := p
	_ = this

	localctx = NewGenericMethodDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, JavaParserRULE_genericMethodDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(524)
		p.TypeParameters()
	}
	{
		p.SetState(525)
		p.MethodDeclaration()
	}

	return localctx
}

// IGenericConstructorDeclarationContext is an interface to support dynamic dispatch.
type IGenericConstructorDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenericConstructorDeclarationContext differentiates from other interfaces.
	IsGenericConstructorDeclarationContext()
}

type GenericConstructorDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericConstructorDeclarationContext() *GenericConstructorDeclarationContext {
	var p = new(GenericConstructorDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_genericConstructorDeclaration
	return p
}

func (*GenericConstructorDeclarationContext) IsGenericConstructorDeclarationContext() {}

func NewGenericConstructorDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericConstructorDeclarationContext {
	var p = new(GenericConstructorDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_genericConstructorDeclaration

	return p
}

func (s *GenericConstructorDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericConstructorDeclarationContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *GenericConstructorDeclarationContext) ConstructorDeclaration() IConstructorDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstructorDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstructorDeclarationContext)
}

func (s *GenericConstructorDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericConstructorDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericConstructorDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterGenericConstructorDeclaration(s)
	}
}

func (s *GenericConstructorDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitGenericConstructorDeclaration(s)
	}
}

func (p *JavaParser) GenericConstructorDeclaration() (localctx IGenericConstructorDeclarationContext) {
	this := p
	_ = this

	localctx = NewGenericConstructorDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, JavaParserRULE_genericConstructorDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(527)
		p.TypeParameters()
	}
	{
		p.SetState(528)
		p.ConstructorDeclaration()
	}

	return localctx
}

// IConstructorDeclarationContext is an interface to support dynamic dispatch.
type IConstructorDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetConstructorBody returns the constructorBody rule contexts.
	GetConstructorBody() IBlockContext

	// SetConstructorBody sets the constructorBody rule contexts.
	SetConstructorBody(IBlockContext)

	// IsConstructorDeclarationContext differentiates from other interfaces.
	IsConstructorDeclarationContext()
}

type ConstructorDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser          antlr.Parser
	constructorBody IBlockContext
}

func NewEmptyConstructorDeclarationContext() *ConstructorDeclarationContext {
	var p = new(ConstructorDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_constructorDeclaration
	return p
}

func (*ConstructorDeclarationContext) IsConstructorDeclarationContext() {}

func NewConstructorDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstructorDeclarationContext {
	var p = new(ConstructorDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_constructorDeclaration

	return p
}

func (s *ConstructorDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstructorDeclarationContext) GetConstructorBody() IBlockContext { return s.constructorBody }

func (s *ConstructorDeclarationContext) SetConstructorBody(v IBlockContext) { s.constructorBody = v }

func (s *ConstructorDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ConstructorDeclarationContext) FormalParameters() IFormalParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParametersContext)
}

func (s *ConstructorDeclarationContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ConstructorDeclarationContext) THROWS() antlr.TerminalNode {
	return s.GetToken(JavaParserTHROWS, 0)
}

func (s *ConstructorDeclarationContext) QualifiedNameList() IQualifiedNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameListContext)
}

func (s *ConstructorDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstructorDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstructorDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterConstructorDeclaration(s)
	}
}

func (s *ConstructorDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitConstructorDeclaration(s)
	}
}

func (p *JavaParser) ConstructorDeclaration() (localctx IConstructorDeclarationContext) {
	this := p
	_ = this

	localctx = NewConstructorDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, JavaParserRULE_constructorDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(530)
		p.Identifier()
	}
	{
		p.SetState(531)
		p.FormalParameters()
	}
	p.SetState(534)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserTHROWS {
		{
			p.SetState(532)
			p.Match(JavaParserTHROWS)
		}
		{
			p.SetState(533)
			p.QualifiedNameList()
		}

	}
	{
		p.SetState(536)

		var _x = p.Block()

		localctx.(*ConstructorDeclarationContext).constructorBody = _x
	}

	return localctx
}

// IFieldDeclarationContext is an interface to support dynamic dispatch.
type IFieldDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFieldDeclarationContext differentiates from other interfaces.
	IsFieldDeclarationContext()
}

type FieldDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldDeclarationContext() *FieldDeclarationContext {
	var p = new(FieldDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_fieldDeclaration
	return p
}

func (*FieldDeclarationContext) IsFieldDeclarationContext() {}

func NewFieldDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldDeclarationContext {
	var p = new(FieldDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_fieldDeclaration

	return p
}

func (s *FieldDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldDeclarationContext) TypeType() ITypeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *FieldDeclarationContext) VariableDeclarators() IVariableDeclaratorsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorsContext)
}

func (s *FieldDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(JavaParserSEMI, 0)
}

func (s *FieldDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterFieldDeclaration(s)
	}
}

func (s *FieldDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitFieldDeclaration(s)
	}
}

func (p *JavaParser) FieldDeclaration() (localctx IFieldDeclarationContext) {
	this := p
	_ = this

	localctx = NewFieldDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, JavaParserRULE_fieldDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(538)
		p.TypeType()
	}
	{
		p.SetState(539)
		p.VariableDeclarators()
	}
	{
		p.SetState(540)
		p.Match(JavaParserSEMI)
	}

	return localctx
}

// IInterfaceBodyDeclarationContext is an interface to support dynamic dispatch.
type IInterfaceBodyDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterfaceBodyDeclarationContext differentiates from other interfaces.
	IsInterfaceBodyDeclarationContext()
}

type InterfaceBodyDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceBodyDeclarationContext() *InterfaceBodyDeclarationContext {
	var p = new(InterfaceBodyDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_interfaceBodyDeclaration
	return p
}

func (*InterfaceBodyDeclarationContext) IsInterfaceBodyDeclarationContext() {}

func NewInterfaceBodyDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceBodyDeclarationContext {
	var p = new(InterfaceBodyDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_interfaceBodyDeclaration

	return p
}

func (s *InterfaceBodyDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceBodyDeclarationContext) InterfaceMemberDeclaration() IInterfaceMemberDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceMemberDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceMemberDeclarationContext)
}

func (s *InterfaceBodyDeclarationContext) AllModifier() []IModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModifierContext); ok {
			len++
		}
	}

	tst := make([]IModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModifierContext); ok {
			tst[i] = t.(IModifierContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceBodyDeclarationContext) Modifier(i int) IModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *InterfaceBodyDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(JavaParserSEMI, 0)
}

func (s *InterfaceBodyDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceBodyDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceBodyDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterInterfaceBodyDeclaration(s)
	}
}

func (s *InterfaceBodyDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitInterfaceBodyDeclaration(s)
	}
}

func (p *JavaParser) InterfaceBodyDeclaration() (localctx IInterfaceBodyDeclarationContext) {
	this := p
	_ = this

	localctx = NewInterfaceBodyDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, JavaParserRULE_interfaceBodyDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(550)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JavaParserABSTRACT, JavaParserBOOLEAN, JavaParserBYTE, JavaParserCHAR, JavaParserCLASS, JavaParserDEFAULT, JavaParserDOUBLE, JavaParserENUM, JavaParserFINAL, JavaParserFLOAT, JavaParserINT, JavaParserINTERFACE, JavaParserLONG, JavaParserNATIVE, JavaParserPRIVATE, JavaParserPROTECTED, JavaParserPUBLIC, JavaParserSHORT, JavaParserSTATIC, JavaParserSTRICTFP, JavaParserSYNCHRONIZED, JavaParserTRANSIENT, JavaParserVOID, JavaParserVOLATILE, JavaParserMODULE, JavaParserOPEN, JavaParserREQUIRES, JavaParserEXPORTS, JavaParserOPENS, JavaParserTO, JavaParserUSES, JavaParserPROVIDES, JavaParserWITH, JavaParserTRANSITIVE, JavaParserVAR, JavaParserYIELD, JavaParserRECORD, JavaParserSEALED, JavaParserPERMITS, JavaParserNON_SEALED, JavaParserLT, JavaParserAT, JavaParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(545)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 45, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(542)
					p.Modifier()
				}

			}
			p.SetState(547)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 45, p.GetParserRuleContext())
		}
		{
			p.SetState(548)
			p.InterfaceMemberDeclaration()
		}

	case JavaParserSEMI:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(549)
			p.Match(JavaParserSEMI)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInterfaceMemberDeclarationContext is an interface to support dynamic dispatch.
type IInterfaceMemberDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterfaceMemberDeclarationContext differentiates from other interfaces.
	IsInterfaceMemberDeclarationContext()
}

type InterfaceMemberDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceMemberDeclarationContext() *InterfaceMemberDeclarationContext {
	var p = new(InterfaceMemberDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_interfaceMemberDeclaration
	return p
}

func (*InterfaceMemberDeclarationContext) IsInterfaceMemberDeclarationContext() {}

func NewInterfaceMemberDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceMemberDeclarationContext {
	var p = new(InterfaceMemberDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_interfaceMemberDeclaration

	return p
}

func (s *InterfaceMemberDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceMemberDeclarationContext) ConstDeclaration() IConstDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstDeclarationContext)
}

func (s *InterfaceMemberDeclarationContext) InterfaceMethodDeclaration() IInterfaceMethodDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceMethodDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceMethodDeclarationContext)
}

func (s *InterfaceMemberDeclarationContext) GenericInterfaceMethodDeclaration() IGenericInterfaceMethodDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericInterfaceMethodDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericInterfaceMethodDeclarationContext)
}

func (s *InterfaceMemberDeclarationContext) InterfaceDeclaration() IInterfaceDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclarationContext)
}

func (s *InterfaceMemberDeclarationContext) AnnotationTypeDeclaration() IAnnotationTypeDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationTypeDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationTypeDeclarationContext)
}

func (s *InterfaceMemberDeclarationContext) ClassDeclaration() IClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *InterfaceMemberDeclarationContext) EnumDeclaration() IEnumDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumDeclarationContext)
}

func (s *InterfaceMemberDeclarationContext) RecordDeclaration() IRecordDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordDeclarationContext)
}

func (s *InterfaceMemberDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceMemberDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceMemberDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterInterfaceMemberDeclaration(s)
	}
}

func (s *InterfaceMemberDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitInterfaceMemberDeclaration(s)
	}
}

func (p *JavaParser) InterfaceMemberDeclaration() (localctx IInterfaceMemberDeclarationContext) {
	this := p
	_ = this

	localctx = NewInterfaceMemberDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, JavaParserRULE_interfaceMemberDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(560)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(552)
			p.ConstDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(553)
			p.InterfaceMethodDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(554)
			p.GenericInterfaceMethodDeclaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(555)
			p.InterfaceDeclaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(556)
			p.AnnotationTypeDeclaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(557)
			p.ClassDeclaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(558)
			p.EnumDeclaration()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(559)
			p.RecordDeclaration()
		}

	}

	return localctx
}

// IConstDeclarationContext is an interface to support dynamic dispatch.
type IConstDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstDeclarationContext differentiates from other interfaces.
	IsConstDeclarationContext()
}

type ConstDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstDeclarationContext() *ConstDeclarationContext {
	var p = new(ConstDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_constDeclaration
	return p
}

func (*ConstDeclarationContext) IsConstDeclarationContext() {}

func NewConstDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstDeclarationContext {
	var p = new(ConstDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_constDeclaration

	return p
}

func (s *ConstDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstDeclarationContext) TypeType() ITypeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *ConstDeclarationContext) AllConstantDeclarator() []IConstantDeclaratorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantDeclaratorContext); ok {
			len++
		}
	}

	tst := make([]IConstantDeclaratorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantDeclaratorContext); ok {
			tst[i] = t.(IConstantDeclaratorContext)
			i++
		}
	}

	return tst
}

func (s *ConstDeclarationContext) ConstantDeclarator(i int) IConstantDeclaratorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantDeclaratorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantDeclaratorContext)
}

func (s *ConstDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(JavaParserSEMI, 0)
}

func (s *ConstDeclarationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(JavaParserCOMMA)
}

func (s *ConstDeclarationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserCOMMA, i)
}

func (s *ConstDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterConstDeclaration(s)
	}
}

func (s *ConstDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitConstDeclaration(s)
	}
}

func (p *JavaParser) ConstDeclaration() (localctx IConstDeclarationContext) {
	this := p
	_ = this

	localctx = NewConstDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, JavaParserRULE_constDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(562)
		p.TypeType()
	}
	{
		p.SetState(563)
		p.ConstantDeclarator()
	}
	p.SetState(568)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == JavaParserCOMMA {
		{
			p.SetState(564)
			p.Match(JavaParserCOMMA)
		}
		{
			p.SetState(565)
			p.ConstantDeclarator()
		}

		p.SetState(570)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(571)
		p.Match(JavaParserSEMI)
	}

	return localctx
}

// IConstantDeclaratorContext is an interface to support dynamic dispatch.
type IConstantDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstantDeclaratorContext differentiates from other interfaces.
	IsConstantDeclaratorContext()
}

type ConstantDeclaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantDeclaratorContext() *ConstantDeclaratorContext {
	var p = new(ConstantDeclaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_constantDeclarator
	return p
}

func (*ConstantDeclaratorContext) IsConstantDeclaratorContext() {}

func NewConstantDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantDeclaratorContext {
	var p = new(ConstantDeclaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_constantDeclarator

	return p
}

func (s *ConstantDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantDeclaratorContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ConstantDeclaratorContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(JavaParserASSIGN, 0)
}

func (s *ConstantDeclaratorContext) VariableInitializer() IVariableInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableInitializerContext)
}

func (s *ConstantDeclaratorContext) AllLBRACK() []antlr.TerminalNode {
	return s.GetTokens(JavaParserLBRACK)
}

func (s *ConstantDeclaratorContext) LBRACK(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserLBRACK, i)
}

func (s *ConstantDeclaratorContext) AllRBRACK() []antlr.TerminalNode {
	return s.GetTokens(JavaParserRBRACK)
}

func (s *ConstantDeclaratorContext) RBRACK(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserRBRACK, i)
}

func (s *ConstantDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantDeclaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterConstantDeclarator(s)
	}
}

func (s *ConstantDeclaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitConstantDeclarator(s)
	}
}

func (p *JavaParser) ConstantDeclarator() (localctx IConstantDeclaratorContext) {
	this := p
	_ = this

	localctx = NewConstantDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, JavaParserRULE_constantDeclarator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(573)
		p.Identifier()
	}
	p.SetState(578)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == JavaParserLBRACK {
		{
			p.SetState(574)
			p.Match(JavaParserLBRACK)
		}
		{
			p.SetState(575)
			p.Match(JavaParserRBRACK)
		}

		p.SetState(580)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(581)
		p.Match(JavaParserASSIGN)
	}
	{
		p.SetState(582)
		p.VariableInitializer()
	}

	return localctx
}

// IInterfaceMethodDeclarationContext is an interface to support dynamic dispatch.
type IInterfaceMethodDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterfaceMethodDeclarationContext differentiates from other interfaces.
	IsInterfaceMethodDeclarationContext()
}

type InterfaceMethodDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceMethodDeclarationContext() *InterfaceMethodDeclarationContext {
	var p = new(InterfaceMethodDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_interfaceMethodDeclaration
	return p
}

func (*InterfaceMethodDeclarationContext) IsInterfaceMethodDeclarationContext() {}

func NewInterfaceMethodDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceMethodDeclarationContext {
	var p = new(InterfaceMethodDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_interfaceMethodDeclaration

	return p
}

func (s *InterfaceMethodDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceMethodDeclarationContext) InterfaceCommonBodyDeclaration() IInterfaceCommonBodyDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceCommonBodyDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceCommonBodyDeclarationContext)
}

func (s *InterfaceMethodDeclarationContext) AllInterfaceMethodModifier() []IInterfaceMethodModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInterfaceMethodModifierContext); ok {
			len++
		}
	}

	tst := make([]IInterfaceMethodModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInterfaceMethodModifierContext); ok {
			tst[i] = t.(IInterfaceMethodModifierContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceMethodDeclarationContext) InterfaceMethodModifier(i int) IInterfaceMethodModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceMethodModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceMethodModifierContext)
}

func (s *InterfaceMethodDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceMethodDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceMethodDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterInterfaceMethodDeclaration(s)
	}
}

func (s *InterfaceMethodDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitInterfaceMethodDeclaration(s)
	}
}

func (p *JavaParser) InterfaceMethodDeclaration() (localctx IInterfaceMethodDeclarationContext) {
	this := p
	_ = this

	localctx = NewInterfaceMethodDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, JavaParserRULE_interfaceMethodDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(587)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(584)
				p.InterfaceMethodModifier()
			}

		}
		p.SetState(589)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext())
	}
	{
		p.SetState(590)
		p.InterfaceCommonBodyDeclaration()
	}

	return localctx
}

// IInterfaceMethodModifierContext is an interface to support dynamic dispatch.
type IInterfaceMethodModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterfaceMethodModifierContext differentiates from other interfaces.
	IsInterfaceMethodModifierContext()
}

type InterfaceMethodModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceMethodModifierContext() *InterfaceMethodModifierContext {
	var p = new(InterfaceMethodModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_interfaceMethodModifier
	return p
}

func (*InterfaceMethodModifierContext) IsInterfaceMethodModifierContext() {}

func NewInterfaceMethodModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceMethodModifierContext {
	var p = new(InterfaceMethodModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_interfaceMethodModifier

	return p
}

func (s *InterfaceMethodModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceMethodModifierContext) Annotation() IAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *InterfaceMethodModifierContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(JavaParserPUBLIC, 0)
}

func (s *InterfaceMethodModifierContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(JavaParserABSTRACT, 0)
}

func (s *InterfaceMethodModifierContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(JavaParserDEFAULT, 0)
}

func (s *InterfaceMethodModifierContext) STATIC() antlr.TerminalNode {
	return s.GetToken(JavaParserSTATIC, 0)
}

func (s *InterfaceMethodModifierContext) STRICTFP() antlr.TerminalNode {
	return s.GetToken(JavaParserSTRICTFP, 0)
}

func (s *InterfaceMethodModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceMethodModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceMethodModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterInterfaceMethodModifier(s)
	}
}

func (s *InterfaceMethodModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitInterfaceMethodModifier(s)
	}
}

func (p *JavaParser) InterfaceMethodModifier() (localctx IInterfaceMethodModifierContext) {
	this := p
	_ = this

	localctx = NewInterfaceMethodModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, JavaParserRULE_interfaceMethodModifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(598)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JavaParserMODULE, JavaParserOPEN, JavaParserREQUIRES, JavaParserEXPORTS, JavaParserOPENS, JavaParserTO, JavaParserUSES, JavaParserPROVIDES, JavaParserWITH, JavaParserTRANSITIVE, JavaParserVAR, JavaParserYIELD, JavaParserRECORD, JavaParserSEALED, JavaParserPERMITS, JavaParserAT, JavaParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(592)
			p.Annotation()
		}

	case JavaParserPUBLIC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(593)
			p.Match(JavaParserPUBLIC)
		}

	case JavaParserABSTRACT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(594)
			p.Match(JavaParserABSTRACT)
		}

	case JavaParserDEFAULT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(595)
			p.Match(JavaParserDEFAULT)
		}

	case JavaParserSTATIC:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(596)
			p.Match(JavaParserSTATIC)
		}

	case JavaParserSTRICTFP:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(597)
			p.Match(JavaParserSTRICTFP)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IGenericInterfaceMethodDeclarationContext is an interface to support dynamic dispatch.
type IGenericInterfaceMethodDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenericInterfaceMethodDeclarationContext differentiates from other interfaces.
	IsGenericInterfaceMethodDeclarationContext()
}

type GenericInterfaceMethodDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericInterfaceMethodDeclarationContext() *GenericInterfaceMethodDeclarationContext {
	var p = new(GenericInterfaceMethodDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_genericInterfaceMethodDeclaration
	return p
}

func (*GenericInterfaceMethodDeclarationContext) IsGenericInterfaceMethodDeclarationContext() {}

func NewGenericInterfaceMethodDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericInterfaceMethodDeclarationContext {
	var p = new(GenericInterfaceMethodDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_genericInterfaceMethodDeclaration

	return p
}

func (s *GenericInterfaceMethodDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericInterfaceMethodDeclarationContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *GenericInterfaceMethodDeclarationContext) InterfaceCommonBodyDeclaration() IInterfaceCommonBodyDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceCommonBodyDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceCommonBodyDeclarationContext)
}

func (s *GenericInterfaceMethodDeclarationContext) AllInterfaceMethodModifier() []IInterfaceMethodModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInterfaceMethodModifierContext); ok {
			len++
		}
	}

	tst := make([]IInterfaceMethodModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInterfaceMethodModifierContext); ok {
			tst[i] = t.(IInterfaceMethodModifierContext)
			i++
		}
	}

	return tst
}

func (s *GenericInterfaceMethodDeclarationContext) InterfaceMethodModifier(i int) IInterfaceMethodModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceMethodModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceMethodModifierContext)
}

func (s *GenericInterfaceMethodDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericInterfaceMethodDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericInterfaceMethodDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterGenericInterfaceMethodDeclaration(s)
	}
}

func (s *GenericInterfaceMethodDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitGenericInterfaceMethodDeclaration(s)
	}
}

func (p *JavaParser) GenericInterfaceMethodDeclaration() (localctx IGenericInterfaceMethodDeclarationContext) {
	this := p
	_ = this

	localctx = NewGenericInterfaceMethodDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, JavaParserRULE_genericInterfaceMethodDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(603)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == JavaParserABSTRACT || _la == JavaParserDEFAULT || (((_la-35)&-(0x1f+1)) == 0 && ((1<<uint((_la-35)))&((1<<(JavaParserPUBLIC-35))|(1<<(JavaParserSTATIC-35))|(1<<(JavaParserSTRICTFP-35))|(1<<(JavaParserMODULE-35))|(1<<(JavaParserOPEN-35))|(1<<(JavaParserREQUIRES-35))|(1<<(JavaParserEXPORTS-35))|(1<<(JavaParserOPENS-35))|(1<<(JavaParserTO-35))|(1<<(JavaParserUSES-35))|(1<<(JavaParserPROVIDES-35))|(1<<(JavaParserWITH-35))|(1<<(JavaParserTRANSITIVE-35))|(1<<(JavaParserVAR-35))|(1<<(JavaParserYIELD-35))|(1<<(JavaParserRECORD-35))|(1<<(JavaParserSEALED-35))|(1<<(JavaParserPERMITS-35)))) != 0) || _la == JavaParserAT || _la == JavaParserIDENTIFIER {
		{
			p.SetState(600)
			p.InterfaceMethodModifier()
		}

		p.SetState(605)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(606)
		p.TypeParameters()
	}
	{
		p.SetState(607)
		p.InterfaceCommonBodyDeclaration()
	}

	return localctx
}

// IInterfaceCommonBodyDeclarationContext is an interface to support dynamic dispatch.
type IInterfaceCommonBodyDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterfaceCommonBodyDeclarationContext differentiates from other interfaces.
	IsInterfaceCommonBodyDeclarationContext()
}

type InterfaceCommonBodyDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceCommonBodyDeclarationContext() *InterfaceCommonBodyDeclarationContext {
	var p = new(InterfaceCommonBodyDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_interfaceCommonBodyDeclaration
	return p
}

func (*InterfaceCommonBodyDeclarationContext) IsInterfaceCommonBodyDeclarationContext() {}

func NewInterfaceCommonBodyDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceCommonBodyDeclarationContext {
	var p = new(InterfaceCommonBodyDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_interfaceCommonBodyDeclaration

	return p
}

func (s *InterfaceCommonBodyDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceCommonBodyDeclarationContext) TypeTypeOrVoid() ITypeTypeOrVoidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeOrVoidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeOrVoidContext)
}

func (s *InterfaceCommonBodyDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InterfaceCommonBodyDeclarationContext) FormalParameters() IFormalParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParametersContext)
}

func (s *InterfaceCommonBodyDeclarationContext) MethodBody() IMethodBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodBodyContext)
}

func (s *InterfaceCommonBodyDeclarationContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceCommonBodyDeclarationContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *InterfaceCommonBodyDeclarationContext) AllLBRACK() []antlr.TerminalNode {
	return s.GetTokens(JavaParserLBRACK)
}

func (s *InterfaceCommonBodyDeclarationContext) LBRACK(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserLBRACK, i)
}

func (s *InterfaceCommonBodyDeclarationContext) AllRBRACK() []antlr.TerminalNode {
	return s.GetTokens(JavaParserRBRACK)
}

func (s *InterfaceCommonBodyDeclarationContext) RBRACK(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserRBRACK, i)
}

func (s *InterfaceCommonBodyDeclarationContext) THROWS() antlr.TerminalNode {
	return s.GetToken(JavaParserTHROWS, 0)
}

func (s *InterfaceCommonBodyDeclarationContext) QualifiedNameList() IQualifiedNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameListContext)
}

func (s *InterfaceCommonBodyDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceCommonBodyDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceCommonBodyDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterInterfaceCommonBodyDeclaration(s)
	}
}

func (s *InterfaceCommonBodyDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitInterfaceCommonBodyDeclaration(s)
	}
}

func (p *JavaParser) InterfaceCommonBodyDeclaration() (localctx IInterfaceCommonBodyDeclarationContext) {
	this := p
	_ = this

	localctx = NewInterfaceCommonBodyDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, JavaParserRULE_interfaceCommonBodyDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(612)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 53, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(609)
				p.Annotation()
			}

		}
		p.SetState(614)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 53, p.GetParserRuleContext())
	}
	{
		p.SetState(615)
		p.TypeTypeOrVoid()
	}
	{
		p.SetState(616)
		p.Identifier()
	}
	{
		p.SetState(617)
		p.FormalParameters()
	}
	p.SetState(622)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == JavaParserLBRACK {
		{
			p.SetState(618)
			p.Match(JavaParserLBRACK)
		}
		{
			p.SetState(619)
			p.Match(JavaParserRBRACK)
		}

		p.SetState(624)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(627)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserTHROWS {
		{
			p.SetState(625)
			p.Match(JavaParserTHROWS)
		}
		{
			p.SetState(626)
			p.QualifiedNameList()
		}

	}
	{
		p.SetState(629)
		p.MethodBody()
	}

	return localctx
}

// IVariableDeclaratorsContext is an interface to support dynamic dispatch.
type IVariableDeclaratorsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableDeclaratorsContext differentiates from other interfaces.
	IsVariableDeclaratorsContext()
}

type VariableDeclaratorsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclaratorsContext() *VariableDeclaratorsContext {
	var p = new(VariableDeclaratorsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_variableDeclarators
	return p
}

func (*VariableDeclaratorsContext) IsVariableDeclaratorsContext() {}

func NewVariableDeclaratorsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclaratorsContext {
	var p = new(VariableDeclaratorsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_variableDeclarators

	return p
}

func (s *VariableDeclaratorsContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclaratorsContext) AllVariableDeclarator() []IVariableDeclaratorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDeclaratorContext); ok {
			len++
		}
	}

	tst := make([]IVariableDeclaratorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDeclaratorContext); ok {
			tst[i] = t.(IVariableDeclaratorContext)
			i++
		}
	}

	return tst
}

func (s *VariableDeclaratorsContext) VariableDeclarator(i int) IVariableDeclaratorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorContext)
}

func (s *VariableDeclaratorsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(JavaParserCOMMA)
}

func (s *VariableDeclaratorsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserCOMMA, i)
}

func (s *VariableDeclaratorsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclaratorsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclaratorsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterVariableDeclarators(s)
	}
}

func (s *VariableDeclaratorsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitVariableDeclarators(s)
	}
}

func (p *JavaParser) VariableDeclarators() (localctx IVariableDeclaratorsContext) {
	this := p
	_ = this

	localctx = NewVariableDeclaratorsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, JavaParserRULE_variableDeclarators)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(631)
		p.VariableDeclarator()
	}
	p.SetState(636)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == JavaParserCOMMA {
		{
			p.SetState(632)
			p.Match(JavaParserCOMMA)
		}
		{
			p.SetState(633)
			p.VariableDeclarator()
		}

		p.SetState(638)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IVariableDeclaratorContext is an interface to support dynamic dispatch.
type IVariableDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableDeclaratorContext differentiates from other interfaces.
	IsVariableDeclaratorContext()
}

type VariableDeclaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclaratorContext() *VariableDeclaratorContext {
	var p = new(VariableDeclaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_variableDeclarator
	return p
}

func (*VariableDeclaratorContext) IsVariableDeclaratorContext() {}

func NewVariableDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclaratorContext {
	var p = new(VariableDeclaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_variableDeclarator

	return p
}

func (s *VariableDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclaratorContext) VariableDeclaratorId() IVariableDeclaratorIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorIdContext)
}

func (s *VariableDeclaratorContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(JavaParserASSIGN, 0)
}

func (s *VariableDeclaratorContext) VariableInitializer() IVariableInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableInitializerContext)
}

func (s *VariableDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterVariableDeclarator(s)
	}
}

func (s *VariableDeclaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitVariableDeclarator(s)
	}
}

func (p *JavaParser) VariableDeclarator() (localctx IVariableDeclaratorContext) {
	this := p
	_ = this

	localctx = NewVariableDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, JavaParserRULE_variableDeclarator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(639)
		p.VariableDeclaratorId()
	}
	p.SetState(642)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserASSIGN {
		{
			p.SetState(640)
			p.Match(JavaParserASSIGN)
		}
		{
			p.SetState(641)
			p.VariableInitializer()
		}

	}

	return localctx
}

// IVariableDeclaratorIdContext is an interface to support dynamic dispatch.
type IVariableDeclaratorIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableDeclaratorIdContext differentiates from other interfaces.
	IsVariableDeclaratorIdContext()
}

type VariableDeclaratorIdContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclaratorIdContext() *VariableDeclaratorIdContext {
	var p = new(VariableDeclaratorIdContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_variableDeclaratorId
	return p
}

func (*VariableDeclaratorIdContext) IsVariableDeclaratorIdContext() {}

func NewVariableDeclaratorIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclaratorIdContext {
	var p = new(VariableDeclaratorIdContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_variableDeclaratorId

	return p
}

func (s *VariableDeclaratorIdContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclaratorIdContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *VariableDeclaratorIdContext) AllLBRACK() []antlr.TerminalNode {
	return s.GetTokens(JavaParserLBRACK)
}

func (s *VariableDeclaratorIdContext) LBRACK(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserLBRACK, i)
}

func (s *VariableDeclaratorIdContext) AllRBRACK() []antlr.TerminalNode {
	return s.GetTokens(JavaParserRBRACK)
}

func (s *VariableDeclaratorIdContext) RBRACK(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserRBRACK, i)
}

func (s *VariableDeclaratorIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclaratorIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclaratorIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterVariableDeclaratorId(s)
	}
}

func (s *VariableDeclaratorIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitVariableDeclaratorId(s)
	}
}

func (p *JavaParser) VariableDeclaratorId() (localctx IVariableDeclaratorIdContext) {
	this := p
	_ = this

	localctx = NewVariableDeclaratorIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, JavaParserRULE_variableDeclaratorId)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(644)
		p.Identifier()
	}
	p.SetState(649)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == JavaParserLBRACK {
		{
			p.SetState(645)
			p.Match(JavaParserLBRACK)
		}
		{
			p.SetState(646)
			p.Match(JavaParserRBRACK)
		}

		p.SetState(651)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IVariableInitializerContext is an interface to support dynamic dispatch.
type IVariableInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableInitializerContext differentiates from other interfaces.
	IsVariableInitializerContext()
}

type VariableInitializerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableInitializerContext() *VariableInitializerContext {
	var p = new(VariableInitializerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_variableInitializer
	return p
}

func (*VariableInitializerContext) IsVariableInitializerContext() {}

func NewVariableInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableInitializerContext {
	var p = new(VariableInitializerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_variableInitializer

	return p
}

func (s *VariableInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableInitializerContext) ArrayInitializer() IArrayInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayInitializerContext)
}

func (s *VariableInitializerContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *VariableInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterVariableInitializer(s)
	}
}

func (s *VariableInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitVariableInitializer(s)
	}
}

func (p *JavaParser) VariableInitializer() (localctx IVariableInitializerContext) {
	this := p
	_ = this

	localctx = NewVariableInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, JavaParserRULE_variableInitializer)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(654)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JavaParserLBRACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(652)
			p.ArrayInitializer()
		}

	case JavaParserBOOLEAN, JavaParserBYTE, JavaParserCHAR, JavaParserDOUBLE, JavaParserFLOAT, JavaParserINT, JavaParserLONG, JavaParserNEW, JavaParserSHORT, JavaParserSUPER, JavaParserSWITCH, JavaParserTHIS, JavaParserVOID, JavaParserMODULE, JavaParserOPEN, JavaParserREQUIRES, JavaParserEXPORTS, JavaParserOPENS, JavaParserTO, JavaParserUSES, JavaParserPROVIDES, JavaParserWITH, JavaParserTRANSITIVE, JavaParserVAR, JavaParserYIELD, JavaParserRECORD, JavaParserSEALED, JavaParserPERMITS, JavaParserDECIMAL_LITERAL, JavaParserHEX_LITERAL, JavaParserOCT_LITERAL, JavaParserBINARY_LITERAL, JavaParserFLOAT_LITERAL, JavaParserHEX_FLOAT_LITERAL, JavaParserBOOL_LITERAL, JavaParserCHAR_LITERAL, JavaParserSTRING_LITERAL, JavaParserTEXT_BLOCK, JavaParserNULL_LITERAL, JavaParserLPAREN, JavaParserLT, JavaParserBANG, JavaParserTILDE, JavaParserINC, JavaParserDEC, JavaParserADD, JavaParserSUB, JavaParserAT, JavaParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(653)
			p.expression(0)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArrayInitializerContext is an interface to support dynamic dispatch.
type IArrayInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayInitializerContext differentiates from other interfaces.
	IsArrayInitializerContext()
}

type ArrayInitializerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayInitializerContext() *ArrayInitializerContext {
	var p = new(ArrayInitializerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_arrayInitializer
	return p
}

func (*ArrayInitializerContext) IsArrayInitializerContext() {}

func NewArrayInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayInitializerContext {
	var p = new(ArrayInitializerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_arrayInitializer

	return p
}

func (s *ArrayInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayInitializerContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(JavaParserLBRACE, 0)
}

func (s *ArrayInitializerContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(JavaParserRBRACE, 0)
}

func (s *ArrayInitializerContext) AllVariableInitializer() []IVariableInitializerContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableInitializerContext); ok {
			len++
		}
	}

	tst := make([]IVariableInitializerContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableInitializerContext); ok {
			tst[i] = t.(IVariableInitializerContext)
			i++
		}
	}

	return tst
}

func (s *ArrayInitializerContext) VariableInitializer(i int) IVariableInitializerContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableInitializerContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableInitializerContext)
}

func (s *ArrayInitializerContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(JavaParserCOMMA)
}

func (s *ArrayInitializerContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserCOMMA, i)
}

func (s *ArrayInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterArrayInitializer(s)
	}
}

func (s *ArrayInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitArrayInitializer(s)
	}
}

func (p *JavaParser) ArrayInitializer() (localctx IArrayInitializerContext) {
	this := p
	_ = this

	localctx = NewArrayInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, JavaParserRULE_arrayInitializer)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(656)
		p.Match(JavaParserLBRACE)
	}
	p.SetState(668)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<JavaParserBOOLEAN)|(1<<JavaParserBYTE)|(1<<JavaParserCHAR)|(1<<JavaParserDOUBLE)|(1<<JavaParserFLOAT)|(1<<JavaParserINT)|(1<<JavaParserLONG)|(1<<JavaParserNEW))) != 0) || (((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(JavaParserSHORT-37))|(1<<(JavaParserSUPER-37))|(1<<(JavaParserSWITCH-37))|(1<<(JavaParserTHIS-37))|(1<<(JavaParserVOID-37))|(1<<(JavaParserMODULE-37))|(1<<(JavaParserOPEN-37))|(1<<(JavaParserREQUIRES-37))|(1<<(JavaParserEXPORTS-37))|(1<<(JavaParserOPENS-37))|(1<<(JavaParserTO-37))|(1<<(JavaParserUSES-37))|(1<<(JavaParserPROVIDES-37))|(1<<(JavaParserWITH-37))|(1<<(JavaParserTRANSITIVE-37))|(1<<(JavaParserVAR-37))|(1<<(JavaParserYIELD-37))|(1<<(JavaParserRECORD-37))|(1<<(JavaParserSEALED-37))|(1<<(JavaParserPERMITS-37))|(1<<(JavaParserDECIMAL_LITERAL-37))|(1<<(JavaParserHEX_LITERAL-37)))) != 0) || (((_la-69)&-(0x1f+1)) == 0 && ((1<<uint((_la-69)))&((1<<(JavaParserOCT_LITERAL-69))|(1<<(JavaParserBINARY_LITERAL-69))|(1<<(JavaParserFLOAT_LITERAL-69))|(1<<(JavaParserHEX_FLOAT_LITERAL-69))|(1<<(JavaParserBOOL_LITERAL-69))|(1<<(JavaParserCHAR_LITERAL-69))|(1<<(JavaParserSTRING_LITERAL-69))|(1<<(JavaParserTEXT_BLOCK-69))|(1<<(JavaParserNULL_LITERAL-69))|(1<<(JavaParserLPAREN-69))|(1<<(JavaParserLBRACE-69))|(1<<(JavaParserLT-69))|(1<<(JavaParserBANG-69))|(1<<(JavaParserTILDE-69))|(1<<(JavaParserINC-69)))) != 0) || (((_la-101)&-(0x1f+1)) == 0 && ((1<<uint((_la-101)))&((1<<(JavaParserDEC-101))|(1<<(JavaParserADD-101))|(1<<(JavaParserSUB-101))|(1<<(JavaParserAT-101))|(1<<(JavaParserIDENTIFIER-101)))) != 0) {
		{
			p.SetState(657)
			p.VariableInitializer()
		}
		p.SetState(662)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 60, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(658)
					p.Match(JavaParserCOMMA)
				}
				{
					p.SetState(659)
					p.VariableInitializer()
				}

			}
			p.SetState(664)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 60, p.GetParserRuleContext())
		}
		p.SetState(666)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JavaParserCOMMA {
			{
				p.SetState(665)
				p.Match(JavaParserCOMMA)
			}

		}

	}
	{
		p.SetState(670)
		p.Match(JavaParserRBRACE)
	}

	return localctx
}

// IClassOrInterfaceTypeContext is an interface to support dynamic dispatch.
type IClassOrInterfaceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassOrInterfaceTypeContext differentiates from other interfaces.
	IsClassOrInterfaceTypeContext()
}

type ClassOrInterfaceTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassOrInterfaceTypeContext() *ClassOrInterfaceTypeContext {
	var p = new(ClassOrInterfaceTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_classOrInterfaceType
	return p
}

func (*ClassOrInterfaceTypeContext) IsClassOrInterfaceTypeContext() {}

func NewClassOrInterfaceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassOrInterfaceTypeContext {
	var p = new(ClassOrInterfaceTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_classOrInterfaceType

	return p
}

func (s *ClassOrInterfaceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassOrInterfaceTypeContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ClassOrInterfaceTypeContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassOrInterfaceTypeContext) AllTypeArguments() []ITypeArgumentsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			len++
		}
	}

	tst := make([]ITypeArgumentsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeArgumentsContext); ok {
			tst[i] = t.(ITypeArgumentsContext)
			i++
		}
	}

	return tst
}

func (s *ClassOrInterfaceTypeContext) TypeArguments(i int) ITypeArgumentsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *ClassOrInterfaceTypeContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(JavaParserDOT)
}

func (s *ClassOrInterfaceTypeContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserDOT, i)
}

func (s *ClassOrInterfaceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassOrInterfaceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassOrInterfaceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterClassOrInterfaceType(s)
	}
}

func (s *ClassOrInterfaceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitClassOrInterfaceType(s)
	}
}

func (p *JavaParser) ClassOrInterfaceType() (localctx IClassOrInterfaceTypeContext) {
	this := p
	_ = this

	localctx = NewClassOrInterfaceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, JavaParserRULE_classOrInterfaceType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(672)
		p.Identifier()
	}
	p.SetState(674)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 63, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(673)
			p.TypeArguments()
		}

	}
	p.SetState(683)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(676)
				p.Match(JavaParserDOT)
			}
			{
				p.SetState(677)
				p.Identifier()
			}
			p.SetState(679)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(678)
					p.TypeArguments()
				}

			}

		}
		p.SetState(685)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext())
	}

	return localctx
}

// ITypeArgumentContext is an interface to support dynamic dispatch.
type ITypeArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeArgumentContext differentiates from other interfaces.
	IsTypeArgumentContext()
}

type TypeArgumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeArgumentContext() *TypeArgumentContext {
	var p = new(TypeArgumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_typeArgument
	return p
}

func (*TypeArgumentContext) IsTypeArgumentContext() {}

func NewTypeArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeArgumentContext {
	var p = new(TypeArgumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_typeArgument

	return p
}

func (s *TypeArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeArgumentContext) TypeType() ITypeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *TypeArgumentContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(JavaParserQUESTION, 0)
}

func (s *TypeArgumentContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *TypeArgumentContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *TypeArgumentContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(JavaParserEXTENDS, 0)
}

func (s *TypeArgumentContext) SUPER() antlr.TerminalNode {
	return s.GetToken(JavaParserSUPER, 0)
}

func (s *TypeArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterTypeArgument(s)
	}
}

func (s *TypeArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitTypeArgument(s)
	}
}

func (p *JavaParser) TypeArgument() (localctx ITypeArgumentContext) {
	this := p
	_ = this

	localctx = NewTypeArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, JavaParserRULE_typeArgument)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(698)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(686)
			p.TypeType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(690)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la-51)&-(0x1f+1)) == 0 && ((1<<uint((_la-51)))&((1<<(JavaParserMODULE-51))|(1<<(JavaParserOPEN-51))|(1<<(JavaParserREQUIRES-51))|(1<<(JavaParserEXPORTS-51))|(1<<(JavaParserOPENS-51))|(1<<(JavaParserTO-51))|(1<<(JavaParserUSES-51))|(1<<(JavaParserPROVIDES-51))|(1<<(JavaParserWITH-51))|(1<<(JavaParserTRANSITIVE-51))|(1<<(JavaParserVAR-51))|(1<<(JavaParserYIELD-51))|(1<<(JavaParserRECORD-51))|(1<<(JavaParserSEALED-51))|(1<<(JavaParserPERMITS-51)))) != 0) || _la == JavaParserAT || _la == JavaParserIDENTIFIER {
			{
				p.SetState(687)
				p.Annotation()
			}

			p.SetState(692)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(693)
			p.Match(JavaParserQUESTION)
		}
		p.SetState(696)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JavaParserEXTENDS || _la == JavaParserSUPER {
			{
				p.SetState(694)
				_la = p.GetTokenStream().LA(1)

				if !(_la == JavaParserEXTENDS || _la == JavaParserSUPER) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(695)
				p.TypeType()
			}

		}

	}

	return localctx
}

// IQualifiedNameListContext is an interface to support dynamic dispatch.
type IQualifiedNameListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedNameListContext differentiates from other interfaces.
	IsQualifiedNameListContext()
}

type QualifiedNameListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedNameListContext() *QualifiedNameListContext {
	var p = new(QualifiedNameListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_qualifiedNameList
	return p
}

func (*QualifiedNameListContext) IsQualifiedNameListContext() {}

func NewQualifiedNameListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedNameListContext {
	var p = new(QualifiedNameListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_qualifiedNameList

	return p
}

func (s *QualifiedNameListContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedNameListContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedNameListContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *QualifiedNameListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(JavaParserCOMMA)
}

func (s *QualifiedNameListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserCOMMA, i)
}

func (s *QualifiedNameListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedNameListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedNameListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterQualifiedNameList(s)
	}
}

func (s *QualifiedNameListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitQualifiedNameList(s)
	}
}

func (p *JavaParser) QualifiedNameList() (localctx IQualifiedNameListContext) {
	this := p
	_ = this

	localctx = NewQualifiedNameListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, JavaParserRULE_qualifiedNameList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(700)
		p.QualifiedName()
	}
	p.SetState(705)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == JavaParserCOMMA {
		{
			p.SetState(701)
			p.Match(JavaParserCOMMA)
		}
		{
			p.SetState(702)
			p.QualifiedName()
		}

		p.SetState(707)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFormalParametersContext is an interface to support dynamic dispatch.
type IFormalParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormalParametersContext differentiates from other interfaces.
	IsFormalParametersContext()
}

type FormalParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParametersContext() *FormalParametersContext {
	var p = new(FormalParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_formalParameters
	return p
}

func (*FormalParametersContext) IsFormalParametersContext() {}

func NewFormalParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParametersContext {
	var p = new(FormalParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_formalParameters

	return p
}

func (s *FormalParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParametersContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserLPAREN, 0)
}

func (s *FormalParametersContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserRPAREN, 0)
}

func (s *FormalParametersContext) ReceiverParameter() IReceiverParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReceiverParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReceiverParameterContext)
}

func (s *FormalParametersContext) COMMA() antlr.TerminalNode {
	return s.GetToken(JavaParserCOMMA, 0)
}

func (s *FormalParametersContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *FormalParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterFormalParameters(s)
	}
}

func (s *FormalParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitFormalParameters(s)
	}
}

func (p *JavaParser) FormalParameters() (localctx IFormalParametersContext) {
	this := p
	_ = this

	localctx = NewFormalParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, JavaParserRULE_formalParameters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(708)
		p.Match(JavaParserLPAREN)
	}
	p.SetState(720)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 73, p.GetParserRuleContext()) {
	case 1:
		p.SetState(710)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<JavaParserBOOLEAN)|(1<<JavaParserBYTE)|(1<<JavaParserCHAR)|(1<<JavaParserDOUBLE)|(1<<JavaParserFLOAT)|(1<<JavaParserINT)|(1<<JavaParserLONG))) != 0) || (((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(JavaParserSHORT-37))|(1<<(JavaParserMODULE-37))|(1<<(JavaParserOPEN-37))|(1<<(JavaParserREQUIRES-37))|(1<<(JavaParserEXPORTS-37))|(1<<(JavaParserOPENS-37))|(1<<(JavaParserTO-37))|(1<<(JavaParserUSES-37))|(1<<(JavaParserPROVIDES-37))|(1<<(JavaParserWITH-37))|(1<<(JavaParserTRANSITIVE-37))|(1<<(JavaParserVAR-37))|(1<<(JavaParserYIELD-37))|(1<<(JavaParserRECORD-37))|(1<<(JavaParserSEALED-37))|(1<<(JavaParserPERMITS-37)))) != 0) || _la == JavaParserAT || _la == JavaParserIDENTIFIER {
			{
				p.SetState(709)
				p.ReceiverParameter()
			}

		}

	case 2:
		{
			p.SetState(712)
			p.ReceiverParameter()
		}
		p.SetState(715)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JavaParserCOMMA {
			{
				p.SetState(713)
				p.Match(JavaParserCOMMA)
			}
			{
				p.SetState(714)
				p.FormalParameterList()
			}

		}

	case 3:
		p.SetState(718)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<JavaParserBOOLEAN)|(1<<JavaParserBYTE)|(1<<JavaParserCHAR)|(1<<JavaParserDOUBLE)|(1<<JavaParserFINAL)|(1<<JavaParserFLOAT)|(1<<JavaParserINT)|(1<<JavaParserLONG))) != 0) || (((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(JavaParserSHORT-37))|(1<<(JavaParserMODULE-37))|(1<<(JavaParserOPEN-37))|(1<<(JavaParserREQUIRES-37))|(1<<(JavaParserEXPORTS-37))|(1<<(JavaParserOPENS-37))|(1<<(JavaParserTO-37))|(1<<(JavaParserUSES-37))|(1<<(JavaParserPROVIDES-37))|(1<<(JavaParserWITH-37))|(1<<(JavaParserTRANSITIVE-37))|(1<<(JavaParserVAR-37))|(1<<(JavaParserYIELD-37))|(1<<(JavaParserRECORD-37))|(1<<(JavaParserSEALED-37))|(1<<(JavaParserPERMITS-37)))) != 0) || _la == JavaParserAT || _la == JavaParserIDENTIFIER {
			{
				p.SetState(717)
				p.FormalParameterList()
			}

		}

	}
	{
		p.SetState(722)
		p.Match(JavaParserRPAREN)
	}

	return localctx
}

// IReceiverParameterContext is an interface to support dynamic dispatch.
type IReceiverParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReceiverParameterContext differentiates from other interfaces.
	IsReceiverParameterContext()
}

type ReceiverParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiverParameterContext() *ReceiverParameterContext {
	var p = new(ReceiverParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_receiverParameter
	return p
}

func (*ReceiverParameterContext) IsReceiverParameterContext() {}

func NewReceiverParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiverParameterContext {
	var p = new(ReceiverParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_receiverParameter

	return p
}

func (s *ReceiverParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiverParameterContext) TypeType() ITypeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *ReceiverParameterContext) THIS() antlr.TerminalNode {
	return s.GetToken(JavaParserTHIS, 0)
}

func (s *ReceiverParameterContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ReceiverParameterContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ReceiverParameterContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(JavaParserDOT)
}

func (s *ReceiverParameterContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserDOT, i)
}

func (s *ReceiverParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiverParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiverParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterReceiverParameter(s)
	}
}

func (s *ReceiverParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitReceiverParameter(s)
	}
}

func (p *JavaParser) ReceiverParameter() (localctx IReceiverParameterContext) {
	this := p
	_ = this

	localctx = NewReceiverParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, JavaParserRULE_receiverParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(724)
		p.TypeType()
	}
	p.SetState(730)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-51)&-(0x1f+1)) == 0 && ((1<<uint((_la-51)))&((1<<(JavaParserMODULE-51))|(1<<(JavaParserOPEN-51))|(1<<(JavaParserREQUIRES-51))|(1<<(JavaParserEXPORTS-51))|(1<<(JavaParserOPENS-51))|(1<<(JavaParserTO-51))|(1<<(JavaParserUSES-51))|(1<<(JavaParserPROVIDES-51))|(1<<(JavaParserWITH-51))|(1<<(JavaParserTRANSITIVE-51))|(1<<(JavaParserVAR-51))|(1<<(JavaParserYIELD-51))|(1<<(JavaParserRECORD-51))|(1<<(JavaParserSEALED-51))|(1<<(JavaParserPERMITS-51)))) != 0) || _la == JavaParserIDENTIFIER {
		{
			p.SetState(725)
			p.Identifier()
		}
		{
			p.SetState(726)
			p.Match(JavaParserDOT)
		}

		p.SetState(732)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(733)
		p.Match(JavaParserTHIS)
	}

	return localctx
}

// IFormalParameterListContext is an interface to support dynamic dispatch.
type IFormalParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormalParameterListContext differentiates from other interfaces.
	IsFormalParameterListContext()
}

type FormalParameterListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterListContext() *FormalParameterListContext {
	var p = new(FormalParameterListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_formalParameterList
	return p
}

func (*FormalParameterListContext) IsFormalParameterListContext() {}

func NewFormalParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterListContext {
	var p = new(FormalParameterListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_formalParameterList

	return p
}

func (s *FormalParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterListContext) AllFormalParameter() []IFormalParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFormalParameterContext); ok {
			len++
		}
	}

	tst := make([]IFormalParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFormalParameterContext); ok {
			tst[i] = t.(IFormalParameterContext)
			i++
		}
	}

	return tst
}

func (s *FormalParameterListContext) FormalParameter(i int) IFormalParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterContext)
}

func (s *FormalParameterListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(JavaParserCOMMA)
}

func (s *FormalParameterListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserCOMMA, i)
}

func (s *FormalParameterListContext) LastFormalParameter() ILastFormalParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILastFormalParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILastFormalParameterContext)
}

func (s *FormalParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterFormalParameterList(s)
	}
}

func (s *FormalParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitFormalParameterList(s)
	}
}

func (p *JavaParser) FormalParameterList() (localctx IFormalParameterListContext) {
	this := p
	_ = this

	localctx = NewFormalParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, JavaParserRULE_formalParameterList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(748)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 77, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(735)
			p.FormalParameter()
		}
		p.SetState(740)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(736)
					p.Match(JavaParserCOMMA)
				}
				{
					p.SetState(737)
					p.FormalParameter()
				}

			}
			p.SetState(742)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext())
		}
		p.SetState(745)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JavaParserCOMMA {
			{
				p.SetState(743)
				p.Match(JavaParserCOMMA)
			}
			{
				p.SetState(744)
				p.LastFormalParameter()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(747)
			p.LastFormalParameter()
		}

	}

	return localctx
}

// IFormalParameterContext is an interface to support dynamic dispatch.
type IFormalParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormalParameterContext differentiates from other interfaces.
	IsFormalParameterContext()
}

type FormalParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterContext() *FormalParameterContext {
	var p = new(FormalParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_formalParameter
	return p
}

func (*FormalParameterContext) IsFormalParameterContext() {}

func NewFormalParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterContext {
	var p = new(FormalParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_formalParameter

	return p
}

func (s *FormalParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterContext) TypeType() ITypeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *FormalParameterContext) VariableDeclaratorId() IVariableDeclaratorIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorIdContext)
}

func (s *FormalParameterContext) AllVariableModifier() []IVariableModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableModifierContext); ok {
			len++
		}
	}

	tst := make([]IVariableModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableModifierContext); ok {
			tst[i] = t.(IVariableModifierContext)
			i++
		}
	}

	return tst
}

func (s *FormalParameterContext) VariableModifier(i int) IVariableModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableModifierContext)
}

func (s *FormalParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterFormalParameter(s)
	}
}

func (s *FormalParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitFormalParameter(s)
	}
}

func (p *JavaParser) FormalParameter() (localctx IFormalParameterContext) {
	this := p
	_ = this

	localctx = NewFormalParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, JavaParserRULE_formalParameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(753)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(750)
				p.VariableModifier()
			}

		}
		p.SetState(755)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext())
	}
	{
		p.SetState(756)
		p.TypeType()
	}
	{
		p.SetState(757)
		p.VariableDeclaratorId()
	}

	return localctx
}

// ILastFormalParameterContext is an interface to support dynamic dispatch.
type ILastFormalParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLastFormalParameterContext differentiates from other interfaces.
	IsLastFormalParameterContext()
}

type LastFormalParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLastFormalParameterContext() *LastFormalParameterContext {
	var p = new(LastFormalParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_lastFormalParameter
	return p
}

func (*LastFormalParameterContext) IsLastFormalParameterContext() {}

func NewLastFormalParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LastFormalParameterContext {
	var p = new(LastFormalParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_lastFormalParameter

	return p
}

func (s *LastFormalParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *LastFormalParameterContext) TypeType() ITypeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *LastFormalParameterContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(JavaParserELLIPSIS, 0)
}

func (s *LastFormalParameterContext) VariableDeclaratorId() IVariableDeclaratorIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorIdContext)
}

func (s *LastFormalParameterContext) AllVariableModifier() []IVariableModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableModifierContext); ok {
			len++
		}
	}

	tst := make([]IVariableModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableModifierContext); ok {
			tst[i] = t.(IVariableModifierContext)
			i++
		}
	}

	return tst
}

func (s *LastFormalParameterContext) VariableModifier(i int) IVariableModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableModifierContext)
}

func (s *LastFormalParameterContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *LastFormalParameterContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *LastFormalParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LastFormalParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LastFormalParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterLastFormalParameter(s)
	}
}

func (s *LastFormalParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitLastFormalParameter(s)
	}
}

func (p *JavaParser) LastFormalParameter() (localctx ILastFormalParameterContext) {
	this := p
	_ = this

	localctx = NewLastFormalParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, JavaParserRULE_lastFormalParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(762)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 79, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(759)
				p.VariableModifier()
			}

		}
		p.SetState(764)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 79, p.GetParserRuleContext())
	}
	{
		p.SetState(765)
		p.TypeType()
	}
	p.SetState(769)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-51)&-(0x1f+1)) == 0 && ((1<<uint((_la-51)))&((1<<(JavaParserMODULE-51))|(1<<(JavaParserOPEN-51))|(1<<(JavaParserREQUIRES-51))|(1<<(JavaParserEXPORTS-51))|(1<<(JavaParserOPENS-51))|(1<<(JavaParserTO-51))|(1<<(JavaParserUSES-51))|(1<<(JavaParserPROVIDES-51))|(1<<(JavaParserWITH-51))|(1<<(JavaParserTRANSITIVE-51))|(1<<(JavaParserVAR-51))|(1<<(JavaParserYIELD-51))|(1<<(JavaParserRECORD-51))|(1<<(JavaParserSEALED-51))|(1<<(JavaParserPERMITS-51)))) != 0) || _la == JavaParserAT || _la == JavaParserIDENTIFIER {
		{
			p.SetState(766)
			p.Annotation()
		}

		p.SetState(771)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(772)
		p.Match(JavaParserELLIPSIS)
	}
	{
		p.SetState(773)
		p.VariableDeclaratorId()
	}

	return localctx
}

// ILambdaLVTIListContext is an interface to support dynamic dispatch.
type ILambdaLVTIListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLambdaLVTIListContext differentiates from other interfaces.
	IsLambdaLVTIListContext()
}

type LambdaLVTIListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaLVTIListContext() *LambdaLVTIListContext {
	var p = new(LambdaLVTIListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_lambdaLVTIList
	return p
}

func (*LambdaLVTIListContext) IsLambdaLVTIListContext() {}

func NewLambdaLVTIListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaLVTIListContext {
	var p = new(LambdaLVTIListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_lambdaLVTIList

	return p
}

func (s *LambdaLVTIListContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaLVTIListContext) AllLambdaLVTIParameter() []ILambdaLVTIParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILambdaLVTIParameterContext); ok {
			len++
		}
	}

	tst := make([]ILambdaLVTIParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILambdaLVTIParameterContext); ok {
			tst[i] = t.(ILambdaLVTIParameterContext)
			i++
		}
	}

	return tst
}

func (s *LambdaLVTIListContext) LambdaLVTIParameter(i int) ILambdaLVTIParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaLVTIParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaLVTIParameterContext)
}

func (s *LambdaLVTIListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(JavaParserCOMMA)
}

func (s *LambdaLVTIListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserCOMMA, i)
}

func (s *LambdaLVTIListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaLVTIListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaLVTIListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterLambdaLVTIList(s)
	}
}

func (s *LambdaLVTIListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitLambdaLVTIList(s)
	}
}

func (p *JavaParser) LambdaLVTIList() (localctx ILambdaLVTIListContext) {
	this := p
	_ = this

	localctx = NewLambdaLVTIListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, JavaParserRULE_lambdaLVTIList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(775)
		p.LambdaLVTIParameter()
	}
	p.SetState(780)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == JavaParserCOMMA {
		{
			p.SetState(776)
			p.Match(JavaParserCOMMA)
		}
		{
			p.SetState(777)
			p.LambdaLVTIParameter()
		}

		p.SetState(782)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ILambdaLVTIParameterContext is an interface to support dynamic dispatch.
type ILambdaLVTIParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLambdaLVTIParameterContext differentiates from other interfaces.
	IsLambdaLVTIParameterContext()
}

type LambdaLVTIParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaLVTIParameterContext() *LambdaLVTIParameterContext {
	var p = new(LambdaLVTIParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_lambdaLVTIParameter
	return p
}

func (*LambdaLVTIParameterContext) IsLambdaLVTIParameterContext() {}

func NewLambdaLVTIParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaLVTIParameterContext {
	var p = new(LambdaLVTIParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_lambdaLVTIParameter

	return p
}

func (s *LambdaLVTIParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaLVTIParameterContext) VAR() antlr.TerminalNode {
	return s.GetToken(JavaParserVAR, 0)
}

func (s *LambdaLVTIParameterContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LambdaLVTIParameterContext) AllVariableModifier() []IVariableModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableModifierContext); ok {
			len++
		}
	}

	tst := make([]IVariableModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableModifierContext); ok {
			tst[i] = t.(IVariableModifierContext)
			i++
		}
	}

	return tst
}

func (s *LambdaLVTIParameterContext) VariableModifier(i int) IVariableModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableModifierContext)
}

func (s *LambdaLVTIParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaLVTIParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaLVTIParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterLambdaLVTIParameter(s)
	}
}

func (s *LambdaLVTIParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitLambdaLVTIParameter(s)
	}
}

func (p *JavaParser) LambdaLVTIParameter() (localctx ILambdaLVTIParameterContext) {
	this := p
	_ = this

	localctx = NewLambdaLVTIParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, JavaParserRULE_lambdaLVTIParameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(786)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 82, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(783)
				p.VariableModifier()
			}

		}
		p.SetState(788)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 82, p.GetParserRuleContext())
	}
	{
		p.SetState(789)
		p.Match(JavaParserVAR)
	}
	{
		p.SetState(790)
		p.Identifier()
	}

	return localctx
}

// IQualifiedNameContext is an interface to support dynamic dispatch.
type IQualifiedNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedNameContext differentiates from other interfaces.
	IsQualifiedNameContext()
}

type QualifiedNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedNameContext() *QualifiedNameContext {
	var p = new(QualifiedNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_qualifiedName
	return p
}

func (*QualifiedNameContext) IsQualifiedNameContext() {}

func NewQualifiedNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedNameContext {
	var p = new(QualifiedNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_qualifiedName

	return p
}

func (s *QualifiedNameContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedNameContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedNameContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *QualifiedNameContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(JavaParserDOT)
}

func (s *QualifiedNameContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserDOT, i)
}

func (s *QualifiedNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterQualifiedName(s)
	}
}

func (s *QualifiedNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitQualifiedName(s)
	}
}

func (p *JavaParser) QualifiedName() (localctx IQualifiedNameContext) {
	this := p
	_ = this

	localctx = NewQualifiedNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, JavaParserRULE_qualifiedName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(792)
		p.Identifier()
	}
	p.SetState(797)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 83, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(793)
				p.Match(JavaParserDOT)
			}
			{
				p.SetState(794)
				p.Identifier()
			}

		}
		p.SetState(799)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 83, p.GetParserRuleContext())
	}

	return localctx
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *LiteralContext) FloatLiteral() IFloatLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFloatLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFloatLiteralContext)
}

func (s *LiteralContext) CHAR_LITERAL() antlr.TerminalNode {
	return s.GetToken(JavaParserCHAR_LITERAL, 0)
}

func (s *LiteralContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(JavaParserSTRING_LITERAL, 0)
}

func (s *LiteralContext) BOOL_LITERAL() antlr.TerminalNode {
	return s.GetToken(JavaParserBOOL_LITERAL, 0)
}

func (s *LiteralContext) NULL_LITERAL() antlr.TerminalNode {
	return s.GetToken(JavaParserNULL_LITERAL, 0)
}

func (s *LiteralContext) TEXT_BLOCK() antlr.TerminalNode {
	return s.GetToken(JavaParserTEXT_BLOCK, 0)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (p *JavaParser) Literal() (localctx ILiteralContext) {
	this := p
	_ = this

	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, JavaParserRULE_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(807)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JavaParserDECIMAL_LITERAL, JavaParserHEX_LITERAL, JavaParserOCT_LITERAL, JavaParserBINARY_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(800)
			p.IntegerLiteral()
		}

	case JavaParserFLOAT_LITERAL, JavaParserHEX_FLOAT_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(801)
			p.FloatLiteral()
		}

	case JavaParserCHAR_LITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(802)
			p.Match(JavaParserCHAR_LITERAL)
		}

	case JavaParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(803)
			p.Match(JavaParserSTRING_LITERAL)
		}

	case JavaParserBOOL_LITERAL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(804)
			p.Match(JavaParserBOOL_LITERAL)
		}

	case JavaParserNULL_LITERAL:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(805)
			p.Match(JavaParserNULL_LITERAL)
		}

	case JavaParserTEXT_BLOCK:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(806)
			p.Match(JavaParserTEXT_BLOCK)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIntegerLiteralContext is an interface to support dynamic dispatch.
type IIntegerLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntegerLiteralContext differentiates from other interfaces.
	IsIntegerLiteralContext()
}

type IntegerLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntegerLiteralContext() *IntegerLiteralContext {
	var p = new(IntegerLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_integerLiteral
	return p
}

func (*IntegerLiteralContext) IsIntegerLiteralContext() {}

func NewIntegerLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntegerLiteralContext {
	var p = new(IntegerLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_integerLiteral

	return p
}

func (s *IntegerLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *IntegerLiteralContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(JavaParserDECIMAL_LITERAL, 0)
}

func (s *IntegerLiteralContext) HEX_LITERAL() antlr.TerminalNode {
	return s.GetToken(JavaParserHEX_LITERAL, 0)
}

func (s *IntegerLiteralContext) OCT_LITERAL() antlr.TerminalNode {
	return s.GetToken(JavaParserOCT_LITERAL, 0)
}

func (s *IntegerLiteralContext) BINARY_LITERAL() antlr.TerminalNode {
	return s.GetToken(JavaParserBINARY_LITERAL, 0)
}

func (s *IntegerLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntegerLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterIntegerLiteral(s)
	}
}

func (s *IntegerLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitIntegerLiteral(s)
	}
}

func (p *JavaParser) IntegerLiteral() (localctx IIntegerLiteralContext) {
	this := p
	_ = this

	localctx = NewIntegerLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, JavaParserRULE_integerLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(809)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-67)&-(0x1f+1)) == 0 && ((1<<uint((_la-67)))&((1<<(JavaParserDECIMAL_LITERAL-67))|(1<<(JavaParserHEX_LITERAL-67))|(1<<(JavaParserOCT_LITERAL-67))|(1<<(JavaParserBINARY_LITERAL-67)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IFloatLiteralContext is an interface to support dynamic dispatch.
type IFloatLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFloatLiteralContext differentiates from other interfaces.
	IsFloatLiteralContext()
}

type FloatLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFloatLiteralContext() *FloatLiteralContext {
	var p = new(FloatLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_floatLiteral
	return p
}

func (*FloatLiteralContext) IsFloatLiteralContext() {}

func NewFloatLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FloatLiteralContext {
	var p = new(FloatLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_floatLiteral

	return p
}

func (s *FloatLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *FloatLiteralContext) FLOAT_LITERAL() antlr.TerminalNode {
	return s.GetToken(JavaParserFLOAT_LITERAL, 0)
}

func (s *FloatLiteralContext) HEX_FLOAT_LITERAL() antlr.TerminalNode {
	return s.GetToken(JavaParserHEX_FLOAT_LITERAL, 0)
}

func (s *FloatLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FloatLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FloatLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterFloatLiteral(s)
	}
}

func (s *FloatLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitFloatLiteral(s)
	}
}

func (p *JavaParser) FloatLiteral() (localctx IFloatLiteralContext) {
	this := p
	_ = this

	localctx = NewFloatLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, JavaParserRULE_floatLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(811)
		_la = p.GetTokenStream().LA(1)

		if !(_la == JavaParserFLOAT_LITERAL || _la == JavaParserHEX_FLOAT_LITERAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IAltAnnotationQualifiedNameContext is an interface to support dynamic dispatch.
type IAltAnnotationQualifiedNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAltAnnotationQualifiedNameContext differentiates from other interfaces.
	IsAltAnnotationQualifiedNameContext()
}

type AltAnnotationQualifiedNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAltAnnotationQualifiedNameContext() *AltAnnotationQualifiedNameContext {
	var p = new(AltAnnotationQualifiedNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_altAnnotationQualifiedName
	return p
}

func (*AltAnnotationQualifiedNameContext) IsAltAnnotationQualifiedNameContext() {}

func NewAltAnnotationQualifiedNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AltAnnotationQualifiedNameContext {
	var p = new(AltAnnotationQualifiedNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_altAnnotationQualifiedName

	return p
}

func (s *AltAnnotationQualifiedNameContext) GetParser() antlr.Parser { return s.parser }

func (s *AltAnnotationQualifiedNameContext) AT() antlr.TerminalNode {
	return s.GetToken(JavaParserAT, 0)
}

func (s *AltAnnotationQualifiedNameContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AltAnnotationQualifiedNameContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AltAnnotationQualifiedNameContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(JavaParserDOT)
}

func (s *AltAnnotationQualifiedNameContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserDOT, i)
}

func (s *AltAnnotationQualifiedNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AltAnnotationQualifiedNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AltAnnotationQualifiedNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterAltAnnotationQualifiedName(s)
	}
}

func (s *AltAnnotationQualifiedNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitAltAnnotationQualifiedName(s)
	}
}

func (p *JavaParser) AltAnnotationQualifiedName() (localctx IAltAnnotationQualifiedNameContext) {
	this := p
	_ = this

	localctx = NewAltAnnotationQualifiedNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, JavaParserRULE_altAnnotationQualifiedName)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(818)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-51)&-(0x1f+1)) == 0 && ((1<<uint((_la-51)))&((1<<(JavaParserMODULE-51))|(1<<(JavaParserOPEN-51))|(1<<(JavaParserREQUIRES-51))|(1<<(JavaParserEXPORTS-51))|(1<<(JavaParserOPENS-51))|(1<<(JavaParserTO-51))|(1<<(JavaParserUSES-51))|(1<<(JavaParserPROVIDES-51))|(1<<(JavaParserWITH-51))|(1<<(JavaParserTRANSITIVE-51))|(1<<(JavaParserVAR-51))|(1<<(JavaParserYIELD-51))|(1<<(JavaParserRECORD-51))|(1<<(JavaParserSEALED-51))|(1<<(JavaParserPERMITS-51)))) != 0) || _la == JavaParserIDENTIFIER {
		{
			p.SetState(813)
			p.Identifier()
		}
		{
			p.SetState(814)
			p.Match(JavaParserDOT)
		}

		p.SetState(820)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(821)
		p.Match(JavaParserAT)
	}
	{
		p.SetState(822)
		p.Identifier()
	}

	return localctx
}

// IAnnotationContext is an interface to support dynamic dispatch.
type IAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationContext differentiates from other interfaces.
	IsAnnotationContext()
}

type AnnotationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationContext() *AnnotationContext {
	var p = new(AnnotationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_annotation
	return p
}

func (*AnnotationContext) IsAnnotationContext() {}

func NewAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationContext {
	var p = new(AnnotationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_annotation

	return p
}

func (s *AnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationContext) AT() antlr.TerminalNode {
	return s.GetToken(JavaParserAT, 0)
}

func (s *AnnotationContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AnnotationContext) AltAnnotationQualifiedName() IAltAnnotationQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAltAnnotationQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAltAnnotationQualifiedNameContext)
}

func (s *AnnotationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserLPAREN, 0)
}

func (s *AnnotationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserRPAREN, 0)
}

func (s *AnnotationContext) ElementValuePairs() IElementValuePairsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValuePairsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValuePairsContext)
}

func (s *AnnotationContext) ElementValue() IElementValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValueContext)
}

func (s *AnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterAnnotation(s)
	}
}

func (s *AnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitAnnotation(s)
	}
}

func (p *JavaParser) Annotation() (localctx IAnnotationContext) {
	this := p
	_ = this

	localctx = NewAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, JavaParserRULE_annotation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(827)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 86, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(824)
			p.Match(JavaParserAT)
		}
		{
			p.SetState(825)
			p.QualifiedName()
		}

	case 2:
		{
			p.SetState(826)
			p.AltAnnotationQualifiedName()
		}

	}
	p.SetState(835)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserLPAREN {
		{
			p.SetState(829)
			p.Match(JavaParserLPAREN)
		}
		p.SetState(832)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 87, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(830)
				p.ElementValuePairs()
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 87, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(831)
				p.ElementValue()
			}

		}
		{
			p.SetState(834)
			p.Match(JavaParserRPAREN)
		}

	}

	return localctx
}

// IElementValuePairsContext is an interface to support dynamic dispatch.
type IElementValuePairsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementValuePairsContext differentiates from other interfaces.
	IsElementValuePairsContext()
}

type ElementValuePairsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValuePairsContext() *ElementValuePairsContext {
	var p = new(ElementValuePairsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_elementValuePairs
	return p
}

func (*ElementValuePairsContext) IsElementValuePairsContext() {}

func NewElementValuePairsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValuePairsContext {
	var p = new(ElementValuePairsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_elementValuePairs

	return p
}

func (s *ElementValuePairsContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValuePairsContext) AllElementValuePair() []IElementValuePairContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IElementValuePairContext); ok {
			len++
		}
	}

	tst := make([]IElementValuePairContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IElementValuePairContext); ok {
			tst[i] = t.(IElementValuePairContext)
			i++
		}
	}

	return tst
}

func (s *ElementValuePairsContext) ElementValuePair(i int) IElementValuePairContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValuePairContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValuePairContext)
}

func (s *ElementValuePairsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(JavaParserCOMMA)
}

func (s *ElementValuePairsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserCOMMA, i)
}

func (s *ElementValuePairsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValuePairsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementValuePairsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterElementValuePairs(s)
	}
}

func (s *ElementValuePairsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitElementValuePairs(s)
	}
}

func (p *JavaParser) ElementValuePairs() (localctx IElementValuePairsContext) {
	this := p
	_ = this

	localctx = NewElementValuePairsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, JavaParserRULE_elementValuePairs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(837)
		p.ElementValuePair()
	}
	p.SetState(842)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == JavaParserCOMMA {
		{
			p.SetState(838)
			p.Match(JavaParserCOMMA)
		}
		{
			p.SetState(839)
			p.ElementValuePair()
		}

		p.SetState(844)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IElementValuePairContext is an interface to support dynamic dispatch.
type IElementValuePairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementValuePairContext differentiates from other interfaces.
	IsElementValuePairContext()
}

type ElementValuePairContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValuePairContext() *ElementValuePairContext {
	var p = new(ElementValuePairContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_elementValuePair
	return p
}

func (*ElementValuePairContext) IsElementValuePairContext() {}

func NewElementValuePairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValuePairContext {
	var p = new(ElementValuePairContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_elementValuePair

	return p
}

func (s *ElementValuePairContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValuePairContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ElementValuePairContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(JavaParserASSIGN, 0)
}

func (s *ElementValuePairContext) ElementValue() IElementValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValueContext)
}

func (s *ElementValuePairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValuePairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementValuePairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterElementValuePair(s)
	}
}

func (s *ElementValuePairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitElementValuePair(s)
	}
}

func (p *JavaParser) ElementValuePair() (localctx IElementValuePairContext) {
	this := p
	_ = this

	localctx = NewElementValuePairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, JavaParserRULE_elementValuePair)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(845)
		p.Identifier()
	}
	{
		p.SetState(846)
		p.Match(JavaParserASSIGN)
	}
	{
		p.SetState(847)
		p.ElementValue()
	}

	return localctx
}

// IElementValueContext is an interface to support dynamic dispatch.
type IElementValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementValueContext differentiates from other interfaces.
	IsElementValueContext()
}

type ElementValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValueContext() *ElementValueContext {
	var p = new(ElementValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_elementValue
	return p
}

func (*ElementValueContext) IsElementValueContext() {}

func NewElementValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValueContext {
	var p = new(ElementValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_elementValue

	return p
}

func (s *ElementValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValueContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ElementValueContext) Annotation() IAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ElementValueContext) ElementValueArrayInitializer() IElementValueArrayInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValueArrayInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValueArrayInitializerContext)
}

func (s *ElementValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterElementValue(s)
	}
}

func (s *ElementValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitElementValue(s)
	}
}

func (p *JavaParser) ElementValue() (localctx IElementValueContext) {
	this := p
	_ = this

	localctx = NewElementValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, JavaParserRULE_elementValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(852)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 90, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(849)
			p.expression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(850)
			p.Annotation()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(851)
			p.ElementValueArrayInitializer()
		}

	}

	return localctx
}

// IElementValueArrayInitializerContext is an interface to support dynamic dispatch.
type IElementValueArrayInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementValueArrayInitializerContext differentiates from other interfaces.
	IsElementValueArrayInitializerContext()
}

type ElementValueArrayInitializerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValueArrayInitializerContext() *ElementValueArrayInitializerContext {
	var p = new(ElementValueArrayInitializerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_elementValueArrayInitializer
	return p
}

func (*ElementValueArrayInitializerContext) IsElementValueArrayInitializerContext() {}

func NewElementValueArrayInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValueArrayInitializerContext {
	var p = new(ElementValueArrayInitializerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_elementValueArrayInitializer

	return p
}

func (s *ElementValueArrayInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValueArrayInitializerContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(JavaParserLBRACE, 0)
}

func (s *ElementValueArrayInitializerContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(JavaParserRBRACE, 0)
}

func (s *ElementValueArrayInitializerContext) AllElementValue() []IElementValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IElementValueContext); ok {
			len++
		}
	}

	tst := make([]IElementValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IElementValueContext); ok {
			tst[i] = t.(IElementValueContext)
			i++
		}
	}

	return tst
}

func (s *ElementValueArrayInitializerContext) ElementValue(i int) IElementValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValueContext)
}

func (s *ElementValueArrayInitializerContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(JavaParserCOMMA)
}

func (s *ElementValueArrayInitializerContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserCOMMA, i)
}

func (s *ElementValueArrayInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValueArrayInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementValueArrayInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterElementValueArrayInitializer(s)
	}
}

func (s *ElementValueArrayInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitElementValueArrayInitializer(s)
	}
}

func (p *JavaParser) ElementValueArrayInitializer() (localctx IElementValueArrayInitializerContext) {
	this := p
	_ = this

	localctx = NewElementValueArrayInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, JavaParserRULE_elementValueArrayInitializer)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(854)
		p.Match(JavaParserLBRACE)
	}
	p.SetState(863)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<JavaParserBOOLEAN)|(1<<JavaParserBYTE)|(1<<JavaParserCHAR)|(1<<JavaParserDOUBLE)|(1<<JavaParserFLOAT)|(1<<JavaParserINT)|(1<<JavaParserLONG)|(1<<JavaParserNEW))) != 0) || (((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(JavaParserSHORT-37))|(1<<(JavaParserSUPER-37))|(1<<(JavaParserSWITCH-37))|(1<<(JavaParserTHIS-37))|(1<<(JavaParserVOID-37))|(1<<(JavaParserMODULE-37))|(1<<(JavaParserOPEN-37))|(1<<(JavaParserREQUIRES-37))|(1<<(JavaParserEXPORTS-37))|(1<<(JavaParserOPENS-37))|(1<<(JavaParserTO-37))|(1<<(JavaParserUSES-37))|(1<<(JavaParserPROVIDES-37))|(1<<(JavaParserWITH-37))|(1<<(JavaParserTRANSITIVE-37))|(1<<(JavaParserVAR-37))|(1<<(JavaParserYIELD-37))|(1<<(JavaParserRECORD-37))|(1<<(JavaParserSEALED-37))|(1<<(JavaParserPERMITS-37))|(1<<(JavaParserDECIMAL_LITERAL-37))|(1<<(JavaParserHEX_LITERAL-37)))) != 0) || (((_la-69)&-(0x1f+1)) == 0 && ((1<<uint((_la-69)))&((1<<(JavaParserOCT_LITERAL-69))|(1<<(JavaParserBINARY_LITERAL-69))|(1<<(JavaParserFLOAT_LITERAL-69))|(1<<(JavaParserHEX_FLOAT_LITERAL-69))|(1<<(JavaParserBOOL_LITERAL-69))|(1<<(JavaParserCHAR_LITERAL-69))|(1<<(JavaParserSTRING_LITERAL-69))|(1<<(JavaParserTEXT_BLOCK-69))|(1<<(JavaParserNULL_LITERAL-69))|(1<<(JavaParserLPAREN-69))|(1<<(JavaParserLBRACE-69))|(1<<(JavaParserLT-69))|(1<<(JavaParserBANG-69))|(1<<(JavaParserTILDE-69))|(1<<(JavaParserINC-69)))) != 0) || (((_la-101)&-(0x1f+1)) == 0 && ((1<<uint((_la-101)))&((1<<(JavaParserDEC-101))|(1<<(JavaParserADD-101))|(1<<(JavaParserSUB-101))|(1<<(JavaParserAT-101))|(1<<(JavaParserIDENTIFIER-101)))) != 0) {
		{
			p.SetState(855)
			p.ElementValue()
		}
		p.SetState(860)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 91, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(856)
					p.Match(JavaParserCOMMA)
				}
				{
					p.SetState(857)
					p.ElementValue()
				}

			}
			p.SetState(862)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 91, p.GetParserRuleContext())
		}

	}
	p.SetState(866)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserCOMMA {
		{
			p.SetState(865)
			p.Match(JavaParserCOMMA)
		}

	}
	{
		p.SetState(868)
		p.Match(JavaParserRBRACE)
	}

	return localctx
}

// IAnnotationTypeDeclarationContext is an interface to support dynamic dispatch.
type IAnnotationTypeDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationTypeDeclarationContext differentiates from other interfaces.
	IsAnnotationTypeDeclarationContext()
}

type AnnotationTypeDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationTypeDeclarationContext() *AnnotationTypeDeclarationContext {
	var p = new(AnnotationTypeDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_annotationTypeDeclaration
	return p
}

func (*AnnotationTypeDeclarationContext) IsAnnotationTypeDeclarationContext() {}

func NewAnnotationTypeDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationTypeDeclarationContext {
	var p = new(AnnotationTypeDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_annotationTypeDeclaration

	return p
}

func (s *AnnotationTypeDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationTypeDeclarationContext) AT() antlr.TerminalNode {
	return s.GetToken(JavaParserAT, 0)
}

func (s *AnnotationTypeDeclarationContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(JavaParserINTERFACE, 0)
}

func (s *AnnotationTypeDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AnnotationTypeDeclarationContext) AnnotationTypeBody() IAnnotationTypeBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationTypeBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationTypeBodyContext)
}

func (s *AnnotationTypeDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationTypeDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationTypeDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterAnnotationTypeDeclaration(s)
	}
}

func (s *AnnotationTypeDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitAnnotationTypeDeclaration(s)
	}
}

func (p *JavaParser) AnnotationTypeDeclaration() (localctx IAnnotationTypeDeclarationContext) {
	this := p
	_ = this

	localctx = NewAnnotationTypeDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, JavaParserRULE_annotationTypeDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(870)
		p.Match(JavaParserAT)
	}
	{
		p.SetState(871)
		p.Match(JavaParserINTERFACE)
	}
	{
		p.SetState(872)
		p.Identifier()
	}
	{
		p.SetState(873)
		p.AnnotationTypeBody()
	}

	return localctx
}

// IAnnotationTypeBodyContext is an interface to support dynamic dispatch.
type IAnnotationTypeBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationTypeBodyContext differentiates from other interfaces.
	IsAnnotationTypeBodyContext()
}

type AnnotationTypeBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationTypeBodyContext() *AnnotationTypeBodyContext {
	var p = new(AnnotationTypeBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_annotationTypeBody
	return p
}

func (*AnnotationTypeBodyContext) IsAnnotationTypeBodyContext() {}

func NewAnnotationTypeBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationTypeBodyContext {
	var p = new(AnnotationTypeBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_annotationTypeBody

	return p
}

func (s *AnnotationTypeBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationTypeBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(JavaParserLBRACE, 0)
}

func (s *AnnotationTypeBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(JavaParserRBRACE, 0)
}

func (s *AnnotationTypeBodyContext) AllAnnotationTypeElementDeclaration() []IAnnotationTypeElementDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationTypeElementDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationTypeElementDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationTypeElementDeclarationContext); ok {
			tst[i] = t.(IAnnotationTypeElementDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *AnnotationTypeBodyContext) AnnotationTypeElementDeclaration(i int) IAnnotationTypeElementDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationTypeElementDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationTypeElementDeclarationContext)
}

func (s *AnnotationTypeBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationTypeBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationTypeBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterAnnotationTypeBody(s)
	}
}

func (s *AnnotationTypeBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitAnnotationTypeBody(s)
	}
}

func (p *JavaParser) AnnotationTypeBody() (localctx IAnnotationTypeBodyContext) {
	this := p
	_ = this

	localctx = NewAnnotationTypeBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, JavaParserRULE_annotationTypeBody)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(875)
		p.Match(JavaParserLBRACE)
	}
	p.SetState(879)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<JavaParserABSTRACT)|(1<<JavaParserBOOLEAN)|(1<<JavaParserBYTE)|(1<<JavaParserCHAR)|(1<<JavaParserCLASS)|(1<<JavaParserDOUBLE)|(1<<JavaParserENUM)|(1<<JavaParserFINAL)|(1<<JavaParserFLOAT)|(1<<JavaParserINT)|(1<<JavaParserINTERFACE)|(1<<JavaParserLONG)|(1<<JavaParserNATIVE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(JavaParserPRIVATE-33))|(1<<(JavaParserPROTECTED-33))|(1<<(JavaParserPUBLIC-33))|(1<<(JavaParserSHORT-33))|(1<<(JavaParserSTATIC-33))|(1<<(JavaParserSTRICTFP-33))|(1<<(JavaParserSYNCHRONIZED-33))|(1<<(JavaParserTRANSIENT-33))|(1<<(JavaParserVOLATILE-33))|(1<<(JavaParserMODULE-33))|(1<<(JavaParserOPEN-33))|(1<<(JavaParserREQUIRES-33))|(1<<(JavaParserEXPORTS-33))|(1<<(JavaParserOPENS-33))|(1<<(JavaParserTO-33))|(1<<(JavaParserUSES-33))|(1<<(JavaParserPROVIDES-33))|(1<<(JavaParserWITH-33))|(1<<(JavaParserTRANSITIVE-33))|(1<<(JavaParserVAR-33))|(1<<(JavaParserYIELD-33))|(1<<(JavaParserRECORD-33))|(1<<(JavaParserSEALED-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(JavaParserPERMITS-65))|(1<<(JavaParserNON_SEALED-65))|(1<<(JavaParserSEMI-65)))) != 0) || _la == JavaParserAT || _la == JavaParserIDENTIFIER {
		{
			p.SetState(876)
			p.AnnotationTypeElementDeclaration()
		}

		p.SetState(881)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(882)
		p.Match(JavaParserRBRACE)
	}

	return localctx
}

// IAnnotationTypeElementDeclarationContext is an interface to support dynamic dispatch.
type IAnnotationTypeElementDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationTypeElementDeclarationContext differentiates from other interfaces.
	IsAnnotationTypeElementDeclarationContext()
}

type AnnotationTypeElementDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationTypeElementDeclarationContext() *AnnotationTypeElementDeclarationContext {
	var p = new(AnnotationTypeElementDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_annotationTypeElementDeclaration
	return p
}

func (*AnnotationTypeElementDeclarationContext) IsAnnotationTypeElementDeclarationContext() {}

func NewAnnotationTypeElementDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationTypeElementDeclarationContext {
	var p = new(AnnotationTypeElementDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_annotationTypeElementDeclaration

	return p
}

func (s *AnnotationTypeElementDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationTypeElementDeclarationContext) AnnotationTypeElementRest() IAnnotationTypeElementRestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationTypeElementRestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationTypeElementRestContext)
}

func (s *AnnotationTypeElementDeclarationContext) AllModifier() []IModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModifierContext); ok {
			len++
		}
	}

	tst := make([]IModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModifierContext); ok {
			tst[i] = t.(IModifierContext)
			i++
		}
	}

	return tst
}

func (s *AnnotationTypeElementDeclarationContext) Modifier(i int) IModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *AnnotationTypeElementDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(JavaParserSEMI, 0)
}

func (s *AnnotationTypeElementDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationTypeElementDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationTypeElementDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterAnnotationTypeElementDeclaration(s)
	}
}

func (s *AnnotationTypeElementDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitAnnotationTypeElementDeclaration(s)
	}
}

func (p *JavaParser) AnnotationTypeElementDeclaration() (localctx IAnnotationTypeElementDeclarationContext) {
	this := p
	_ = this

	localctx = NewAnnotationTypeElementDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, JavaParserRULE_annotationTypeElementDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(892)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JavaParserABSTRACT, JavaParserBOOLEAN, JavaParserBYTE, JavaParserCHAR, JavaParserCLASS, JavaParserDOUBLE, JavaParserENUM, JavaParserFINAL, JavaParserFLOAT, JavaParserINT, JavaParserINTERFACE, JavaParserLONG, JavaParserNATIVE, JavaParserPRIVATE, JavaParserPROTECTED, JavaParserPUBLIC, JavaParserSHORT, JavaParserSTATIC, JavaParserSTRICTFP, JavaParserSYNCHRONIZED, JavaParserTRANSIENT, JavaParserVOLATILE, JavaParserMODULE, JavaParserOPEN, JavaParserREQUIRES, JavaParserEXPORTS, JavaParserOPENS, JavaParserTO, JavaParserUSES, JavaParserPROVIDES, JavaParserWITH, JavaParserTRANSITIVE, JavaParserVAR, JavaParserYIELD, JavaParserRECORD, JavaParserSEALED, JavaParserPERMITS, JavaParserNON_SEALED, JavaParserAT, JavaParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(887)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 95, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(884)
					p.Modifier()
				}

			}
			p.SetState(889)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 95, p.GetParserRuleContext())
		}
		{
			p.SetState(890)
			p.AnnotationTypeElementRest()
		}

	case JavaParserSEMI:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(891)
			p.Match(JavaParserSEMI)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAnnotationTypeElementRestContext is an interface to support dynamic dispatch.
type IAnnotationTypeElementRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationTypeElementRestContext differentiates from other interfaces.
	IsAnnotationTypeElementRestContext()
}

type AnnotationTypeElementRestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationTypeElementRestContext() *AnnotationTypeElementRestContext {
	var p = new(AnnotationTypeElementRestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_annotationTypeElementRest
	return p
}

func (*AnnotationTypeElementRestContext) IsAnnotationTypeElementRestContext() {}

func NewAnnotationTypeElementRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationTypeElementRestContext {
	var p = new(AnnotationTypeElementRestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_annotationTypeElementRest

	return p
}

func (s *AnnotationTypeElementRestContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationTypeElementRestContext) TypeType() ITypeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *AnnotationTypeElementRestContext) AnnotationMethodOrConstantRest() IAnnotationMethodOrConstantRestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationMethodOrConstantRestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationMethodOrConstantRestContext)
}

func (s *AnnotationTypeElementRestContext) SEMI() antlr.TerminalNode {
	return s.GetToken(JavaParserSEMI, 0)
}

func (s *AnnotationTypeElementRestContext) ClassDeclaration() IClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *AnnotationTypeElementRestContext) InterfaceDeclaration() IInterfaceDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclarationContext)
}

func (s *AnnotationTypeElementRestContext) EnumDeclaration() IEnumDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumDeclarationContext)
}

func (s *AnnotationTypeElementRestContext) AnnotationTypeDeclaration() IAnnotationTypeDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationTypeDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationTypeDeclarationContext)
}

func (s *AnnotationTypeElementRestContext) RecordDeclaration() IRecordDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordDeclarationContext)
}

func (s *AnnotationTypeElementRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationTypeElementRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationTypeElementRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterAnnotationTypeElementRest(s)
	}
}

func (s *AnnotationTypeElementRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitAnnotationTypeElementRest(s)
	}
}

func (p *JavaParser) AnnotationTypeElementRest() (localctx IAnnotationTypeElementRestContext) {
	this := p
	_ = this

	localctx = NewAnnotationTypeElementRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, JavaParserRULE_annotationTypeElementRest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(918)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(894)
			p.TypeType()
		}
		{
			p.SetState(895)
			p.AnnotationMethodOrConstantRest()
		}
		{
			p.SetState(896)
			p.Match(JavaParserSEMI)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(898)
			p.ClassDeclaration()
		}
		p.SetState(900)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 97, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(899)
				p.Match(JavaParserSEMI)
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(902)
			p.InterfaceDeclaration()
		}
		p.SetState(904)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 98, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(903)
				p.Match(JavaParserSEMI)
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(906)
			p.EnumDeclaration()
		}
		p.SetState(908)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 99, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(907)
				p.Match(JavaParserSEMI)
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(910)
			p.AnnotationTypeDeclaration()
		}
		p.SetState(912)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 100, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(911)
				p.Match(JavaParserSEMI)
			}

		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(914)
			p.RecordDeclaration()
		}
		p.SetState(916)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 101, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(915)
				p.Match(JavaParserSEMI)
			}

		}

	}

	return localctx
}

// IAnnotationMethodOrConstantRestContext is an interface to support dynamic dispatch.
type IAnnotationMethodOrConstantRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationMethodOrConstantRestContext differentiates from other interfaces.
	IsAnnotationMethodOrConstantRestContext()
}

type AnnotationMethodOrConstantRestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationMethodOrConstantRestContext() *AnnotationMethodOrConstantRestContext {
	var p = new(AnnotationMethodOrConstantRestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_annotationMethodOrConstantRest
	return p
}

func (*AnnotationMethodOrConstantRestContext) IsAnnotationMethodOrConstantRestContext() {}

func NewAnnotationMethodOrConstantRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationMethodOrConstantRestContext {
	var p = new(AnnotationMethodOrConstantRestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_annotationMethodOrConstantRest

	return p
}

func (s *AnnotationMethodOrConstantRestContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationMethodOrConstantRestContext) AnnotationMethodRest() IAnnotationMethodRestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationMethodRestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationMethodRestContext)
}

func (s *AnnotationMethodOrConstantRestContext) AnnotationConstantRest() IAnnotationConstantRestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationConstantRestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationConstantRestContext)
}

func (s *AnnotationMethodOrConstantRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationMethodOrConstantRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationMethodOrConstantRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterAnnotationMethodOrConstantRest(s)
	}
}

func (s *AnnotationMethodOrConstantRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitAnnotationMethodOrConstantRest(s)
	}
}

func (p *JavaParser) AnnotationMethodOrConstantRest() (localctx IAnnotationMethodOrConstantRestContext) {
	this := p
	_ = this

	localctx = NewAnnotationMethodOrConstantRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, JavaParserRULE_annotationMethodOrConstantRest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(922)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 103, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(920)
			p.AnnotationMethodRest()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(921)
			p.AnnotationConstantRest()
		}

	}

	return localctx
}

// IAnnotationMethodRestContext is an interface to support dynamic dispatch.
type IAnnotationMethodRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationMethodRestContext differentiates from other interfaces.
	IsAnnotationMethodRestContext()
}

type AnnotationMethodRestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationMethodRestContext() *AnnotationMethodRestContext {
	var p = new(AnnotationMethodRestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_annotationMethodRest
	return p
}

func (*AnnotationMethodRestContext) IsAnnotationMethodRestContext() {}

func NewAnnotationMethodRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationMethodRestContext {
	var p = new(AnnotationMethodRestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_annotationMethodRest

	return p
}

func (s *AnnotationMethodRestContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationMethodRestContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AnnotationMethodRestContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserLPAREN, 0)
}

func (s *AnnotationMethodRestContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserRPAREN, 0)
}

func (s *AnnotationMethodRestContext) DefaultValue() IDefaultValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultValueContext)
}

func (s *AnnotationMethodRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationMethodRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationMethodRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterAnnotationMethodRest(s)
	}
}

func (s *AnnotationMethodRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitAnnotationMethodRest(s)
	}
}

func (p *JavaParser) AnnotationMethodRest() (localctx IAnnotationMethodRestContext) {
	this := p
	_ = this

	localctx = NewAnnotationMethodRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, JavaParserRULE_annotationMethodRest)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(924)
		p.Identifier()
	}
	{
		p.SetState(925)
		p.Match(JavaParserLPAREN)
	}
	{
		p.SetState(926)
		p.Match(JavaParserRPAREN)
	}
	p.SetState(928)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserDEFAULT {
		{
			p.SetState(927)
			p.DefaultValue()
		}

	}

	return localctx
}

// IAnnotationConstantRestContext is an interface to support dynamic dispatch.
type IAnnotationConstantRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationConstantRestContext differentiates from other interfaces.
	IsAnnotationConstantRestContext()
}

type AnnotationConstantRestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationConstantRestContext() *AnnotationConstantRestContext {
	var p = new(AnnotationConstantRestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_annotationConstantRest
	return p
}

func (*AnnotationConstantRestContext) IsAnnotationConstantRestContext() {}

func NewAnnotationConstantRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationConstantRestContext {
	var p = new(AnnotationConstantRestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_annotationConstantRest

	return p
}

func (s *AnnotationConstantRestContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationConstantRestContext) VariableDeclarators() IVariableDeclaratorsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorsContext)
}

func (s *AnnotationConstantRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationConstantRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationConstantRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterAnnotationConstantRest(s)
	}
}

func (s *AnnotationConstantRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitAnnotationConstantRest(s)
	}
}

func (p *JavaParser) AnnotationConstantRest() (localctx IAnnotationConstantRestContext) {
	this := p
	_ = this

	localctx = NewAnnotationConstantRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, JavaParserRULE_annotationConstantRest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(930)
		p.VariableDeclarators()
	}

	return localctx
}

// IDefaultValueContext is an interface to support dynamic dispatch.
type IDefaultValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefaultValueContext differentiates from other interfaces.
	IsDefaultValueContext()
}

type DefaultValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultValueContext() *DefaultValueContext {
	var p = new(DefaultValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_defaultValue
	return p
}

func (*DefaultValueContext) IsDefaultValueContext() {}

func NewDefaultValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultValueContext {
	var p = new(DefaultValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_defaultValue

	return p
}

func (s *DefaultValueContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultValueContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(JavaParserDEFAULT, 0)
}

func (s *DefaultValueContext) ElementValue() IElementValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValueContext)
}

func (s *DefaultValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterDefaultValue(s)
	}
}

func (s *DefaultValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitDefaultValue(s)
	}
}

func (p *JavaParser) DefaultValue() (localctx IDefaultValueContext) {
	this := p
	_ = this

	localctx = NewDefaultValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, JavaParserRULE_defaultValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(932)
		p.Match(JavaParserDEFAULT)
	}
	{
		p.SetState(933)
		p.ElementValue()
	}

	return localctx
}

// IModuleDeclarationContext is an interface to support dynamic dispatch.
type IModuleDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModuleDeclarationContext differentiates from other interfaces.
	IsModuleDeclarationContext()
}

type ModuleDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleDeclarationContext() *ModuleDeclarationContext {
	var p = new(ModuleDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_moduleDeclaration
	return p
}

func (*ModuleDeclarationContext) IsModuleDeclarationContext() {}

func NewModuleDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleDeclarationContext {
	var p = new(ModuleDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_moduleDeclaration

	return p
}

func (s *ModuleDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleDeclarationContext) MODULE() antlr.TerminalNode {
	return s.GetToken(JavaParserMODULE, 0)
}

func (s *ModuleDeclarationContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ModuleDeclarationContext) ModuleBody() IModuleBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModuleBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModuleBodyContext)
}

func (s *ModuleDeclarationContext) OPEN() antlr.TerminalNode {
	return s.GetToken(JavaParserOPEN, 0)
}

func (s *ModuleDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterModuleDeclaration(s)
	}
}

func (s *ModuleDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitModuleDeclaration(s)
	}
}

func (p *JavaParser) ModuleDeclaration() (localctx IModuleDeclarationContext) {
	this := p
	_ = this

	localctx = NewModuleDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, JavaParserRULE_moduleDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(936)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserOPEN {
		{
			p.SetState(935)
			p.Match(JavaParserOPEN)
		}

	}
	{
		p.SetState(938)
		p.Match(JavaParserMODULE)
	}
	{
		p.SetState(939)
		p.QualifiedName()
	}
	{
		p.SetState(940)
		p.ModuleBody()
	}

	return localctx
}

// IModuleBodyContext is an interface to support dynamic dispatch.
type IModuleBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModuleBodyContext differentiates from other interfaces.
	IsModuleBodyContext()
}

type ModuleBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleBodyContext() *ModuleBodyContext {
	var p = new(ModuleBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_moduleBody
	return p
}

func (*ModuleBodyContext) IsModuleBodyContext() {}

func NewModuleBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleBodyContext {
	var p = new(ModuleBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_moduleBody

	return p
}

func (s *ModuleBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(JavaParserLBRACE, 0)
}

func (s *ModuleBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(JavaParserRBRACE, 0)
}

func (s *ModuleBodyContext) AllModuleDirective() []IModuleDirectiveContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModuleDirectiveContext); ok {
			len++
		}
	}

	tst := make([]IModuleDirectiveContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModuleDirectiveContext); ok {
			tst[i] = t.(IModuleDirectiveContext)
			i++
		}
	}

	return tst
}

func (s *ModuleBodyContext) ModuleDirective(i int) IModuleDirectiveContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModuleDirectiveContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModuleDirectiveContext)
}

func (s *ModuleBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterModuleBody(s)
	}
}

func (s *ModuleBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitModuleBody(s)
	}
}

func (p *JavaParser) ModuleBody() (localctx IModuleBodyContext) {
	this := p
	_ = this

	localctx = NewModuleBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, JavaParserRULE_moduleBody)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(942)
		p.Match(JavaParserLBRACE)
	}
	p.SetState(946)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la-53)&-(0x1f+1)) == 0 && ((1<<uint((_la-53)))&((1<<(JavaParserREQUIRES-53))|(1<<(JavaParserEXPORTS-53))|(1<<(JavaParserOPENS-53))|(1<<(JavaParserUSES-53))|(1<<(JavaParserPROVIDES-53)))) != 0 {
		{
			p.SetState(943)
			p.ModuleDirective()
		}

		p.SetState(948)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(949)
		p.Match(JavaParserRBRACE)
	}

	return localctx
}

// IModuleDirectiveContext is an interface to support dynamic dispatch.
type IModuleDirectiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModuleDirectiveContext differentiates from other interfaces.
	IsModuleDirectiveContext()
}

type ModuleDirectiveContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleDirectiveContext() *ModuleDirectiveContext {
	var p = new(ModuleDirectiveContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_moduleDirective
	return p
}

func (*ModuleDirectiveContext) IsModuleDirectiveContext() {}

func NewModuleDirectiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleDirectiveContext {
	var p = new(ModuleDirectiveContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_moduleDirective

	return p
}

func (s *ModuleDirectiveContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleDirectiveContext) REQUIRES() antlr.TerminalNode {
	return s.GetToken(JavaParserREQUIRES, 0)
}

func (s *ModuleDirectiveContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *ModuleDirectiveContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ModuleDirectiveContext) SEMI() antlr.TerminalNode {
	return s.GetToken(JavaParserSEMI, 0)
}

func (s *ModuleDirectiveContext) AllRequiresModifier() []IRequiresModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRequiresModifierContext); ok {
			len++
		}
	}

	tst := make([]IRequiresModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRequiresModifierContext); ok {
			tst[i] = t.(IRequiresModifierContext)
			i++
		}
	}

	return tst
}

func (s *ModuleDirectiveContext) RequiresModifier(i int) IRequiresModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRequiresModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRequiresModifierContext)
}

func (s *ModuleDirectiveContext) EXPORTS() antlr.TerminalNode {
	return s.GetToken(JavaParserEXPORTS, 0)
}

func (s *ModuleDirectiveContext) TO() antlr.TerminalNode {
	return s.GetToken(JavaParserTO, 0)
}

func (s *ModuleDirectiveContext) OPENS() antlr.TerminalNode {
	return s.GetToken(JavaParserOPENS, 0)
}

func (s *ModuleDirectiveContext) USES() antlr.TerminalNode {
	return s.GetToken(JavaParserUSES, 0)
}

func (s *ModuleDirectiveContext) PROVIDES() antlr.TerminalNode {
	return s.GetToken(JavaParserPROVIDES, 0)
}

func (s *ModuleDirectiveContext) WITH() antlr.TerminalNode {
	return s.GetToken(JavaParserWITH, 0)
}

func (s *ModuleDirectiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleDirectiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleDirectiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterModuleDirective(s)
	}
}

func (s *ModuleDirectiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitModuleDirective(s)
	}
}

func (p *JavaParser) ModuleDirective() (localctx IModuleDirectiveContext) {
	this := p
	_ = this

	localctx = NewModuleDirectiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, JavaParserRULE_moduleDirective)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(987)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JavaParserREQUIRES:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(951)
			p.Match(JavaParserREQUIRES)
		}
		p.SetState(955)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 107, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(952)
					p.RequiresModifier()
				}

			}
			p.SetState(957)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 107, p.GetParserRuleContext())
		}
		{
			p.SetState(958)
			p.QualifiedName()
		}
		{
			p.SetState(959)
			p.Match(JavaParserSEMI)
		}

	case JavaParserEXPORTS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(961)
			p.Match(JavaParserEXPORTS)
		}
		{
			p.SetState(962)
			p.QualifiedName()
		}
		p.SetState(965)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JavaParserTO {
			{
				p.SetState(963)
				p.Match(JavaParserTO)
			}
			{
				p.SetState(964)
				p.QualifiedName()
			}

		}
		{
			p.SetState(967)
			p.Match(JavaParserSEMI)
		}

	case JavaParserOPENS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(969)
			p.Match(JavaParserOPENS)
		}
		{
			p.SetState(970)
			p.QualifiedName()
		}
		p.SetState(973)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JavaParserTO {
			{
				p.SetState(971)
				p.Match(JavaParserTO)
			}
			{
				p.SetState(972)
				p.QualifiedName()
			}

		}
		{
			p.SetState(975)
			p.Match(JavaParserSEMI)
		}

	case JavaParserUSES:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(977)
			p.Match(JavaParserUSES)
		}
		{
			p.SetState(978)
			p.QualifiedName()
		}
		{
			p.SetState(979)
			p.Match(JavaParserSEMI)
		}

	case JavaParserPROVIDES:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(981)
			p.Match(JavaParserPROVIDES)
		}
		{
			p.SetState(982)
			p.QualifiedName()
		}
		{
			p.SetState(983)
			p.Match(JavaParserWITH)
		}
		{
			p.SetState(984)
			p.QualifiedName()
		}
		{
			p.SetState(985)
			p.Match(JavaParserSEMI)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRequiresModifierContext is an interface to support dynamic dispatch.
type IRequiresModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRequiresModifierContext differentiates from other interfaces.
	IsRequiresModifierContext()
}

type RequiresModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRequiresModifierContext() *RequiresModifierContext {
	var p = new(RequiresModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_requiresModifier
	return p
}

func (*RequiresModifierContext) IsRequiresModifierContext() {}

func NewRequiresModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RequiresModifierContext {
	var p = new(RequiresModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_requiresModifier

	return p
}

func (s *RequiresModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *RequiresModifierContext) TRANSITIVE() antlr.TerminalNode {
	return s.GetToken(JavaParserTRANSITIVE, 0)
}

func (s *RequiresModifierContext) STATIC() antlr.TerminalNode {
	return s.GetToken(JavaParserSTATIC, 0)
}

func (s *RequiresModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RequiresModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RequiresModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterRequiresModifier(s)
	}
}

func (s *RequiresModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitRequiresModifier(s)
	}
}

func (p *JavaParser) RequiresModifier() (localctx IRequiresModifierContext) {
	this := p
	_ = this

	localctx = NewRequiresModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, JavaParserRULE_requiresModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(989)
		_la = p.GetTokenStream().LA(1)

		if !(_la == JavaParserSTATIC || _la == JavaParserTRANSITIVE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IRecordDeclarationContext is an interface to support dynamic dispatch.
type IRecordDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecordDeclarationContext differentiates from other interfaces.
	IsRecordDeclarationContext()
}

type RecordDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordDeclarationContext() *RecordDeclarationContext {
	var p = new(RecordDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_recordDeclaration
	return p
}

func (*RecordDeclarationContext) IsRecordDeclarationContext() {}

func NewRecordDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordDeclarationContext {
	var p = new(RecordDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_recordDeclaration

	return p
}

func (s *RecordDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordDeclarationContext) RECORD() antlr.TerminalNode {
	return s.GetToken(JavaParserRECORD, 0)
}

func (s *RecordDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RecordDeclarationContext) RecordHeader() IRecordHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordHeaderContext)
}

func (s *RecordDeclarationContext) RecordBody() IRecordBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordBodyContext)
}

func (s *RecordDeclarationContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *RecordDeclarationContext) IMPLEMENTS() antlr.TerminalNode {
	return s.GetToken(JavaParserIMPLEMENTS, 0)
}

func (s *RecordDeclarationContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *RecordDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterRecordDeclaration(s)
	}
}

func (s *RecordDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitRecordDeclaration(s)
	}
}

func (p *JavaParser) RecordDeclaration() (localctx IRecordDeclarationContext) {
	this := p
	_ = this

	localctx = NewRecordDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, JavaParserRULE_recordDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(991)
		p.Match(JavaParserRECORD)
	}
	{
		p.SetState(992)
		p.Identifier()
	}
	p.SetState(994)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserLT {
		{
			p.SetState(993)
			p.TypeParameters()
		}

	}
	{
		p.SetState(996)
		p.RecordHeader()
	}
	p.SetState(999)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserIMPLEMENTS {
		{
			p.SetState(997)
			p.Match(JavaParserIMPLEMENTS)
		}
		{
			p.SetState(998)
			p.TypeList()
		}

	}
	{
		p.SetState(1001)
		p.RecordBody()
	}

	return localctx
}

// IRecordHeaderContext is an interface to support dynamic dispatch.
type IRecordHeaderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecordHeaderContext differentiates from other interfaces.
	IsRecordHeaderContext()
}

type RecordHeaderContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordHeaderContext() *RecordHeaderContext {
	var p = new(RecordHeaderContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_recordHeader
	return p
}

func (*RecordHeaderContext) IsRecordHeaderContext() {}

func NewRecordHeaderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordHeaderContext {
	var p = new(RecordHeaderContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_recordHeader

	return p
}

func (s *RecordHeaderContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordHeaderContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserLPAREN, 0)
}

func (s *RecordHeaderContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserRPAREN, 0)
}

func (s *RecordHeaderContext) RecordComponentList() IRecordComponentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordComponentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordComponentListContext)
}

func (s *RecordHeaderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordHeaderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordHeaderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterRecordHeader(s)
	}
}

func (s *RecordHeaderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitRecordHeader(s)
	}
}

func (p *JavaParser) RecordHeader() (localctx IRecordHeaderContext) {
	this := p
	_ = this

	localctx = NewRecordHeaderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, JavaParserRULE_recordHeader)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1003)
		p.Match(JavaParserLPAREN)
	}
	p.SetState(1005)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<JavaParserBOOLEAN)|(1<<JavaParserBYTE)|(1<<JavaParserCHAR)|(1<<JavaParserDOUBLE)|(1<<JavaParserFLOAT)|(1<<JavaParserINT)|(1<<JavaParserLONG))) != 0) || (((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(JavaParserSHORT-37))|(1<<(JavaParserMODULE-37))|(1<<(JavaParserOPEN-37))|(1<<(JavaParserREQUIRES-37))|(1<<(JavaParserEXPORTS-37))|(1<<(JavaParserOPENS-37))|(1<<(JavaParserTO-37))|(1<<(JavaParserUSES-37))|(1<<(JavaParserPROVIDES-37))|(1<<(JavaParserWITH-37))|(1<<(JavaParserTRANSITIVE-37))|(1<<(JavaParserVAR-37))|(1<<(JavaParserYIELD-37))|(1<<(JavaParserRECORD-37))|(1<<(JavaParserSEALED-37))|(1<<(JavaParserPERMITS-37)))) != 0) || _la == JavaParserAT || _la == JavaParserIDENTIFIER {
		{
			p.SetState(1004)
			p.RecordComponentList()
		}

	}
	{
		p.SetState(1007)
		p.Match(JavaParserRPAREN)
	}

	return localctx
}

// IRecordComponentListContext is an interface to support dynamic dispatch.
type IRecordComponentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecordComponentListContext differentiates from other interfaces.
	IsRecordComponentListContext()
}

type RecordComponentListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordComponentListContext() *RecordComponentListContext {
	var p = new(RecordComponentListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_recordComponentList
	return p
}

func (*RecordComponentListContext) IsRecordComponentListContext() {}

func NewRecordComponentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordComponentListContext {
	var p = new(RecordComponentListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_recordComponentList

	return p
}

func (s *RecordComponentListContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordComponentListContext) AllRecordComponent() []IRecordComponentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRecordComponentContext); ok {
			len++
		}
	}

	tst := make([]IRecordComponentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRecordComponentContext); ok {
			tst[i] = t.(IRecordComponentContext)
			i++
		}
	}

	return tst
}

func (s *RecordComponentListContext) RecordComponent(i int) IRecordComponentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordComponentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordComponentContext)
}

func (s *RecordComponentListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(JavaParserCOMMA)
}

func (s *RecordComponentListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserCOMMA, i)
}

func (s *RecordComponentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordComponentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordComponentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterRecordComponentList(s)
	}
}

func (s *RecordComponentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitRecordComponentList(s)
	}
}

func (p *JavaParser) RecordComponentList() (localctx IRecordComponentListContext) {
	this := p
	_ = this

	localctx = NewRecordComponentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, JavaParserRULE_recordComponentList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1009)
		p.RecordComponent()
	}
	p.SetState(1014)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == JavaParserCOMMA {
		{
			p.SetState(1010)
			p.Match(JavaParserCOMMA)
		}
		{
			p.SetState(1011)
			p.RecordComponent()
		}

		p.SetState(1016)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IRecordComponentContext is an interface to support dynamic dispatch.
type IRecordComponentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecordComponentContext differentiates from other interfaces.
	IsRecordComponentContext()
}

type RecordComponentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordComponentContext() *RecordComponentContext {
	var p = new(RecordComponentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_recordComponent
	return p
}

func (*RecordComponentContext) IsRecordComponentContext() {}

func NewRecordComponentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordComponentContext {
	var p = new(RecordComponentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_recordComponent

	return p
}

func (s *RecordComponentContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordComponentContext) TypeType() ITypeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *RecordComponentContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RecordComponentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordComponentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordComponentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterRecordComponent(s)
	}
}

func (s *RecordComponentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitRecordComponent(s)
	}
}

func (p *JavaParser) RecordComponent() (localctx IRecordComponentContext) {
	this := p
	_ = this

	localctx = NewRecordComponentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, JavaParserRULE_recordComponent)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1017)
		p.TypeType()
	}
	{
		p.SetState(1018)
		p.Identifier()
	}

	return localctx
}

// IRecordBodyContext is an interface to support dynamic dispatch.
type IRecordBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecordBodyContext differentiates from other interfaces.
	IsRecordBodyContext()
}

type RecordBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordBodyContext() *RecordBodyContext {
	var p = new(RecordBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_recordBody
	return p
}

func (*RecordBodyContext) IsRecordBodyContext() {}

func NewRecordBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordBodyContext {
	var p = new(RecordBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_recordBody

	return p
}

func (s *RecordBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(JavaParserLBRACE, 0)
}

func (s *RecordBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(JavaParserRBRACE, 0)
}

func (s *RecordBodyContext) AllClassBodyDeclaration() []IClassBodyDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassBodyDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IClassBodyDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassBodyDeclarationContext); ok {
			tst[i] = t.(IClassBodyDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *RecordBodyContext) ClassBodyDeclaration(i int) IClassBodyDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBodyDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBodyDeclarationContext)
}

func (s *RecordBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterRecordBody(s)
	}
}

func (s *RecordBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitRecordBody(s)
	}
}

func (p *JavaParser) RecordBody() (localctx IRecordBodyContext) {
	this := p
	_ = this

	localctx = NewRecordBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, JavaParserRULE_recordBody)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1020)
		p.Match(JavaParserLBRACE)
	}
	p.SetState(1024)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<JavaParserABSTRACT)|(1<<JavaParserBOOLEAN)|(1<<JavaParserBYTE)|(1<<JavaParserCHAR)|(1<<JavaParserCLASS)|(1<<JavaParserDOUBLE)|(1<<JavaParserENUM)|(1<<JavaParserFINAL)|(1<<JavaParserFLOAT)|(1<<JavaParserINT)|(1<<JavaParserINTERFACE)|(1<<JavaParserLONG)|(1<<JavaParserNATIVE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(JavaParserPRIVATE-33))|(1<<(JavaParserPROTECTED-33))|(1<<(JavaParserPUBLIC-33))|(1<<(JavaParserSHORT-33))|(1<<(JavaParserSTATIC-33))|(1<<(JavaParserSTRICTFP-33))|(1<<(JavaParserSYNCHRONIZED-33))|(1<<(JavaParserTRANSIENT-33))|(1<<(JavaParserVOID-33))|(1<<(JavaParserVOLATILE-33))|(1<<(JavaParserMODULE-33))|(1<<(JavaParserOPEN-33))|(1<<(JavaParserREQUIRES-33))|(1<<(JavaParserEXPORTS-33))|(1<<(JavaParserOPENS-33))|(1<<(JavaParserTO-33))|(1<<(JavaParserUSES-33))|(1<<(JavaParserPROVIDES-33))|(1<<(JavaParserWITH-33))|(1<<(JavaParserTRANSITIVE-33))|(1<<(JavaParserVAR-33))|(1<<(JavaParserYIELD-33))|(1<<(JavaParserRECORD-33))|(1<<(JavaParserSEALED-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(JavaParserPERMITS-65))|(1<<(JavaParserNON_SEALED-65))|(1<<(JavaParserLBRACE-65))|(1<<(JavaParserSEMI-65))|(1<<(JavaParserLT-65)))) != 0) || _la == JavaParserAT || _la == JavaParserIDENTIFIER {
		{
			p.SetState(1021)
			p.ClassBodyDeclaration()
		}

		p.SetState(1026)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1027)
		p.Match(JavaParserRBRACE)
	}

	return localctx
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_block
	return p
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(JavaParserLBRACE, 0)
}

func (s *BlockContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(JavaParserRBRACE, 0)
}

func (s *BlockContext) AllBlockStatement() []IBlockStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBlockStatementContext); ok {
			len++
		}
	}

	tst := make([]IBlockStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBlockStatementContext); ok {
			tst[i] = t.(IBlockStatementContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) BlockStatement(i int) IBlockStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockStatementContext)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitBlock(s)
	}
}

func (p *JavaParser) Block() (localctx IBlockContext) {
	this := p
	_ = this

	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, JavaParserRULE_block)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1029)
		p.Match(JavaParserLBRACE)
	}
	p.SetState(1033)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<JavaParserABSTRACT)|(1<<JavaParserASSERT)|(1<<JavaParserBOOLEAN)|(1<<JavaParserBREAK)|(1<<JavaParserBYTE)|(1<<JavaParserCHAR)|(1<<JavaParserCLASS)|(1<<JavaParserCONTINUE)|(1<<JavaParserDO)|(1<<JavaParserDOUBLE)|(1<<JavaParserFINAL)|(1<<JavaParserFLOAT)|(1<<JavaParserFOR)|(1<<JavaParserIF)|(1<<JavaParserINT)|(1<<JavaParserINTERFACE)|(1<<JavaParserLONG)|(1<<JavaParserNEW))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(JavaParserPRIVATE-33))|(1<<(JavaParserPROTECTED-33))|(1<<(JavaParserPUBLIC-33))|(1<<(JavaParserRETURN-33))|(1<<(JavaParserSHORT-33))|(1<<(JavaParserSTATIC-33))|(1<<(JavaParserSTRICTFP-33))|(1<<(JavaParserSUPER-33))|(1<<(JavaParserSWITCH-33))|(1<<(JavaParserSYNCHRONIZED-33))|(1<<(JavaParserTHIS-33))|(1<<(JavaParserTHROW-33))|(1<<(JavaParserTRY-33))|(1<<(JavaParserVOID-33))|(1<<(JavaParserWHILE-33))|(1<<(JavaParserMODULE-33))|(1<<(JavaParserOPEN-33))|(1<<(JavaParserREQUIRES-33))|(1<<(JavaParserEXPORTS-33))|(1<<(JavaParserOPENS-33))|(1<<(JavaParserTO-33))|(1<<(JavaParserUSES-33))|(1<<(JavaParserPROVIDES-33))|(1<<(JavaParserWITH-33))|(1<<(JavaParserTRANSITIVE-33))|(1<<(JavaParserVAR-33))|(1<<(JavaParserYIELD-33))|(1<<(JavaParserRECORD-33))|(1<<(JavaParserSEALED-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(JavaParserPERMITS-65))|(1<<(JavaParserNON_SEALED-65))|(1<<(JavaParserDECIMAL_LITERAL-65))|(1<<(JavaParserHEX_LITERAL-65))|(1<<(JavaParserOCT_LITERAL-65))|(1<<(JavaParserBINARY_LITERAL-65))|(1<<(JavaParserFLOAT_LITERAL-65))|(1<<(JavaParserHEX_FLOAT_LITERAL-65))|(1<<(JavaParserBOOL_LITERAL-65))|(1<<(JavaParserCHAR_LITERAL-65))|(1<<(JavaParserSTRING_LITERAL-65))|(1<<(JavaParserTEXT_BLOCK-65))|(1<<(JavaParserNULL_LITERAL-65))|(1<<(JavaParserLPAREN-65))|(1<<(JavaParserLBRACE-65))|(1<<(JavaParserSEMI-65))|(1<<(JavaParserLT-65))|(1<<(JavaParserBANG-65))|(1<<(JavaParserTILDE-65)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(JavaParserINC-100))|(1<<(JavaParserDEC-100))|(1<<(JavaParserADD-100))|(1<<(JavaParserSUB-100))|(1<<(JavaParserAT-100))|(1<<(JavaParserIDENTIFIER-100)))) != 0) {
		{
			p.SetState(1030)
			p.BlockStatement()
		}

		p.SetState(1035)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1036)
		p.Match(JavaParserRBRACE)
	}

	return localctx
}

// IBlockStatementContext is an interface to support dynamic dispatch.
type IBlockStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockStatementContext differentiates from other interfaces.
	IsBlockStatementContext()
}

type BlockStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockStatementContext() *BlockStatementContext {
	var p = new(BlockStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_blockStatement
	return p
}

func (*BlockStatementContext) IsBlockStatementContext() {}

func NewBlockStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockStatementContext {
	var p = new(BlockStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_blockStatement

	return p
}

func (s *BlockStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockStatementContext) LocalVariableDeclaration() ILocalVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocalVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocalVariableDeclarationContext)
}

func (s *BlockStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(JavaParserSEMI, 0)
}

func (s *BlockStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *BlockStatementContext) LocalTypeDeclaration() ILocalTypeDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocalTypeDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocalTypeDeclarationContext)
}

func (s *BlockStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterBlockStatement(s)
	}
}

func (s *BlockStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitBlockStatement(s)
	}
}

func (p *JavaParser) BlockStatement() (localctx IBlockStatementContext) {
	this := p
	_ = this

	localctx = NewBlockStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, JavaParserRULE_blockStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1043)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 117, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1038)
			p.LocalVariableDeclaration()
		}
		{
			p.SetState(1039)
			p.Match(JavaParserSEMI)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1041)
			p.Statement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1042)
			p.LocalTypeDeclaration()
		}

	}

	return localctx
}

// ILocalVariableDeclarationContext is an interface to support dynamic dispatch.
type ILocalVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLocalVariableDeclarationContext differentiates from other interfaces.
	IsLocalVariableDeclarationContext()
}

type LocalVariableDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocalVariableDeclarationContext() *LocalVariableDeclarationContext {
	var p = new(LocalVariableDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_localVariableDeclaration
	return p
}

func (*LocalVariableDeclarationContext) IsLocalVariableDeclarationContext() {}

func NewLocalVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LocalVariableDeclarationContext {
	var p = new(LocalVariableDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_localVariableDeclaration

	return p
}

func (s *LocalVariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *LocalVariableDeclarationContext) TypeType() ITypeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *LocalVariableDeclarationContext) VariableDeclarators() IVariableDeclaratorsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorsContext)
}

func (s *LocalVariableDeclarationContext) VAR() antlr.TerminalNode {
	return s.GetToken(JavaParserVAR, 0)
}

func (s *LocalVariableDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LocalVariableDeclarationContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(JavaParserASSIGN, 0)
}

func (s *LocalVariableDeclarationContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LocalVariableDeclarationContext) AllVariableModifier() []IVariableModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableModifierContext); ok {
			len++
		}
	}

	tst := make([]IVariableModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableModifierContext); ok {
			tst[i] = t.(IVariableModifierContext)
			i++
		}
	}

	return tst
}

func (s *LocalVariableDeclarationContext) VariableModifier(i int) IVariableModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableModifierContext)
}

func (s *LocalVariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocalVariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LocalVariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterLocalVariableDeclaration(s)
	}
}

func (s *LocalVariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitLocalVariableDeclaration(s)
	}
}

func (p *JavaParser) LocalVariableDeclaration() (localctx ILocalVariableDeclarationContext) {
	this := p
	_ = this

	localctx = NewLocalVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, JavaParserRULE_localVariableDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1048)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 118, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1045)
				p.VariableModifier()
			}

		}
		p.SetState(1050)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 118, p.GetParserRuleContext())
	}
	p.SetState(1059)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 119, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1051)
			p.TypeType()
		}
		{
			p.SetState(1052)
			p.VariableDeclarators()
		}

	case 2:
		{
			p.SetState(1054)
			p.Match(JavaParserVAR)
		}
		{
			p.SetState(1055)
			p.Identifier()
		}
		{
			p.SetState(1056)
			p.Match(JavaParserASSIGN)
		}
		{
			p.SetState(1057)
			p.expression(0)
		}

	}

	return localctx
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(JavaParserIDENTIFIER, 0)
}

func (s *IdentifierContext) MODULE() antlr.TerminalNode {
	return s.GetToken(JavaParserMODULE, 0)
}

func (s *IdentifierContext) OPEN() antlr.TerminalNode {
	return s.GetToken(JavaParserOPEN, 0)
}

func (s *IdentifierContext) REQUIRES() antlr.TerminalNode {
	return s.GetToken(JavaParserREQUIRES, 0)
}

func (s *IdentifierContext) EXPORTS() antlr.TerminalNode {
	return s.GetToken(JavaParserEXPORTS, 0)
}

func (s *IdentifierContext) OPENS() antlr.TerminalNode {
	return s.GetToken(JavaParserOPENS, 0)
}

func (s *IdentifierContext) TO() antlr.TerminalNode {
	return s.GetToken(JavaParserTO, 0)
}

func (s *IdentifierContext) USES() antlr.TerminalNode {
	return s.GetToken(JavaParserUSES, 0)
}

func (s *IdentifierContext) PROVIDES() antlr.TerminalNode {
	return s.GetToken(JavaParserPROVIDES, 0)
}

func (s *IdentifierContext) WITH() antlr.TerminalNode {
	return s.GetToken(JavaParserWITH, 0)
}

func (s *IdentifierContext) TRANSITIVE() antlr.TerminalNode {
	return s.GetToken(JavaParserTRANSITIVE, 0)
}

func (s *IdentifierContext) YIELD() antlr.TerminalNode {
	return s.GetToken(JavaParserYIELD, 0)
}

func (s *IdentifierContext) SEALED() antlr.TerminalNode {
	return s.GetToken(JavaParserSEALED, 0)
}

func (s *IdentifierContext) PERMITS() antlr.TerminalNode {
	return s.GetToken(JavaParserPERMITS, 0)
}

func (s *IdentifierContext) RECORD() antlr.TerminalNode {
	return s.GetToken(JavaParserRECORD, 0)
}

func (s *IdentifierContext) VAR() antlr.TerminalNode {
	return s.GetToken(JavaParserVAR, 0)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (p *JavaParser) Identifier() (localctx IIdentifierContext) {
	this := p
	_ = this

	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, JavaParserRULE_identifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1061)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-51)&-(0x1f+1)) == 0 && ((1<<uint((_la-51)))&((1<<(JavaParserMODULE-51))|(1<<(JavaParserOPEN-51))|(1<<(JavaParserREQUIRES-51))|(1<<(JavaParserEXPORTS-51))|(1<<(JavaParserOPENS-51))|(1<<(JavaParserTO-51))|(1<<(JavaParserUSES-51))|(1<<(JavaParserPROVIDES-51))|(1<<(JavaParserWITH-51))|(1<<(JavaParserTRANSITIVE-51))|(1<<(JavaParserVAR-51))|(1<<(JavaParserYIELD-51))|(1<<(JavaParserRECORD-51))|(1<<(JavaParserSEALED-51))|(1<<(JavaParserPERMITS-51)))) != 0) || _la == JavaParserIDENTIFIER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ILocalTypeDeclarationContext is an interface to support dynamic dispatch.
type ILocalTypeDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLocalTypeDeclarationContext differentiates from other interfaces.
	IsLocalTypeDeclarationContext()
}

type LocalTypeDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocalTypeDeclarationContext() *LocalTypeDeclarationContext {
	var p = new(LocalTypeDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_localTypeDeclaration
	return p
}

func (*LocalTypeDeclarationContext) IsLocalTypeDeclarationContext() {}

func NewLocalTypeDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LocalTypeDeclarationContext {
	var p = new(LocalTypeDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_localTypeDeclaration

	return p
}

func (s *LocalTypeDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *LocalTypeDeclarationContext) ClassDeclaration() IClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *LocalTypeDeclarationContext) InterfaceDeclaration() IInterfaceDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclarationContext)
}

func (s *LocalTypeDeclarationContext) RecordDeclaration() IRecordDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordDeclarationContext)
}

func (s *LocalTypeDeclarationContext) AllClassOrInterfaceModifier() []IClassOrInterfaceModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassOrInterfaceModifierContext); ok {
			len++
		}
	}

	tst := make([]IClassOrInterfaceModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassOrInterfaceModifierContext); ok {
			tst[i] = t.(IClassOrInterfaceModifierContext)
			i++
		}
	}

	return tst
}

func (s *LocalTypeDeclarationContext) ClassOrInterfaceModifier(i int) IClassOrInterfaceModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOrInterfaceModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOrInterfaceModifierContext)
}

func (s *LocalTypeDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(JavaParserSEMI, 0)
}

func (s *LocalTypeDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocalTypeDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LocalTypeDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterLocalTypeDeclaration(s)
	}
}

func (s *LocalTypeDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitLocalTypeDeclaration(s)
	}
}

func (p *JavaParser) LocalTypeDeclaration() (localctx ILocalTypeDeclarationContext) {
	this := p
	_ = this

	localctx = NewLocalTypeDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, JavaParserRULE_localTypeDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1075)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JavaParserABSTRACT, JavaParserCLASS, JavaParserFINAL, JavaParserINTERFACE, JavaParserPRIVATE, JavaParserPROTECTED, JavaParserPUBLIC, JavaParserSTATIC, JavaParserSTRICTFP, JavaParserMODULE, JavaParserOPEN, JavaParserREQUIRES, JavaParserEXPORTS, JavaParserOPENS, JavaParserTO, JavaParserUSES, JavaParserPROVIDES, JavaParserWITH, JavaParserTRANSITIVE, JavaParserVAR, JavaParserYIELD, JavaParserRECORD, JavaParserSEALED, JavaParserPERMITS, JavaParserNON_SEALED, JavaParserAT, JavaParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1066)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 120, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1063)
					p.ClassOrInterfaceModifier()
				}

			}
			p.SetState(1068)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 120, p.GetParserRuleContext())
		}
		p.SetState(1072)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case JavaParserCLASS:
			{
				p.SetState(1069)
				p.ClassDeclaration()
			}

		case JavaParserINTERFACE:
			{
				p.SetState(1070)
				p.InterfaceDeclaration()
			}

		case JavaParserRECORD:
			{
				p.SetState(1071)
				p.RecordDeclaration()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case JavaParserSEMI:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1074)
			p.Match(JavaParserSEMI)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetBlockLabel returns the blockLabel rule contexts.
	GetBlockLabel() IBlockContext

	// GetStatementExpression returns the statementExpression rule contexts.
	GetStatementExpression() IExpressionContext

	// GetIdentifierLabel returns the identifierLabel rule contexts.
	GetIdentifierLabel() IIdentifierContext

	// SetBlockLabel sets the blockLabel rule contexts.
	SetBlockLabel(IBlockContext)

	// SetStatementExpression sets the statementExpression rule contexts.
	SetStatementExpression(IExpressionContext)

	// SetIdentifierLabel sets the identifierLabel rule contexts.
	SetIdentifierLabel(IIdentifierContext)

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser              antlr.Parser
	blockLabel          IBlockContext
	statementExpression IExpressionContext
	identifierLabel     IIdentifierContext
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) GetBlockLabel() IBlockContext { return s.blockLabel }

func (s *StatementContext) GetStatementExpression() IExpressionContext { return s.statementExpression }

func (s *StatementContext) GetIdentifierLabel() IIdentifierContext { return s.identifierLabel }

func (s *StatementContext) SetBlockLabel(v IBlockContext) { s.blockLabel = v }

func (s *StatementContext) SetStatementExpression(v IExpressionContext) { s.statementExpression = v }

func (s *StatementContext) SetIdentifierLabel(v IIdentifierContext) { s.identifierLabel = v }

func (s *StatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *StatementContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(JavaParserASSERT, 0)
}

func (s *StatementContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *StatementContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(JavaParserSEMI, 0)
}

func (s *StatementContext) COLON() antlr.TerminalNode {
	return s.GetToken(JavaParserCOLON, 0)
}

func (s *StatementContext) IF() antlr.TerminalNode {
	return s.GetToken(JavaParserIF, 0)
}

func (s *StatementContext) ParExpression() IParExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParExpressionContext)
}

func (s *StatementContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *StatementContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *StatementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(JavaParserELSE, 0)
}

func (s *StatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(JavaParserFOR, 0)
}

func (s *StatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserLPAREN, 0)
}

func (s *StatementContext) ForControl() IForControlContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForControlContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForControlContext)
}

func (s *StatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserRPAREN, 0)
}

func (s *StatementContext) WHILE() antlr.TerminalNode {
	return s.GetToken(JavaParserWHILE, 0)
}

func (s *StatementContext) DO() antlr.TerminalNode {
	return s.GetToken(JavaParserDO, 0)
}

func (s *StatementContext) TRY() antlr.TerminalNode {
	return s.GetToken(JavaParserTRY, 0)
}

func (s *StatementContext) FinallyBlock() IFinallyBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFinallyBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFinallyBlockContext)
}

func (s *StatementContext) AllCatchClause() []ICatchClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICatchClauseContext); ok {
			len++
		}
	}

	tst := make([]ICatchClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICatchClauseContext); ok {
			tst[i] = t.(ICatchClauseContext)
			i++
		}
	}

	return tst
}

func (s *StatementContext) CatchClause(i int) ICatchClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatchClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatchClauseContext)
}

func (s *StatementContext) ResourceSpecification() IResourceSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceSpecificationContext)
}

func (s *StatementContext) SWITCH() antlr.TerminalNode {
	return s.GetToken(JavaParserSWITCH, 0)
}

func (s *StatementContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(JavaParserLBRACE, 0)
}

func (s *StatementContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(JavaParserRBRACE, 0)
}

func (s *StatementContext) AllSwitchBlockStatementGroup() []ISwitchBlockStatementGroupContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISwitchBlockStatementGroupContext); ok {
			len++
		}
	}

	tst := make([]ISwitchBlockStatementGroupContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISwitchBlockStatementGroupContext); ok {
			tst[i] = t.(ISwitchBlockStatementGroupContext)
			i++
		}
	}

	return tst
}

func (s *StatementContext) SwitchBlockStatementGroup(i int) ISwitchBlockStatementGroupContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchBlockStatementGroupContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchBlockStatementGroupContext)
}

func (s *StatementContext) AllSwitchLabel() []ISwitchLabelContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISwitchLabelContext); ok {
			len++
		}
	}

	tst := make([]ISwitchLabelContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISwitchLabelContext); ok {
			tst[i] = t.(ISwitchLabelContext)
			i++
		}
	}

	return tst
}

func (s *StatementContext) SwitchLabel(i int) ISwitchLabelContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchLabelContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchLabelContext)
}

func (s *StatementContext) SYNCHRONIZED() antlr.TerminalNode {
	return s.GetToken(JavaParserSYNCHRONIZED, 0)
}

func (s *StatementContext) RETURN() antlr.TerminalNode {
	return s.GetToken(JavaParserRETURN, 0)
}

func (s *StatementContext) THROW() antlr.TerminalNode {
	return s.GetToken(JavaParserTHROW, 0)
}

func (s *StatementContext) BREAK() antlr.TerminalNode {
	return s.GetToken(JavaParserBREAK, 0)
}

func (s *StatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StatementContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(JavaParserCONTINUE, 0)
}

func (s *StatementContext) YIELD() antlr.TerminalNode {
	return s.GetToken(JavaParserYIELD, 0)
}

func (s *StatementContext) SwitchExpression() ISwitchExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchExpressionContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (p *JavaParser) Statement() (localctx IStatementContext) {
	this := p
	_ = this

	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, JavaParserRULE_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1190)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 136, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1077)

			var _x = p.Block()

			localctx.(*StatementContext).blockLabel = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1078)
			p.Match(JavaParserASSERT)
		}
		{
			p.SetState(1079)
			p.expression(0)
		}
		p.SetState(1082)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JavaParserCOLON {
			{
				p.SetState(1080)
				p.Match(JavaParserCOLON)
			}
			{
				p.SetState(1081)
				p.expression(0)
			}

		}
		{
			p.SetState(1084)
			p.Match(JavaParserSEMI)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1086)
			p.Match(JavaParserIF)
		}
		{
			p.SetState(1087)
			p.ParExpression()
		}
		{
			p.SetState(1088)
			p.Statement()
		}
		p.SetState(1091)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 124, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1089)
				p.Match(JavaParserELSE)
			}
			{
				p.SetState(1090)
				p.Statement()
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1093)
			p.Match(JavaParserFOR)
		}
		{
			p.SetState(1094)
			p.Match(JavaParserLPAREN)
		}
		{
			p.SetState(1095)
			p.ForControl()
		}
		{
			p.SetState(1096)
			p.Match(JavaParserRPAREN)
		}
		{
			p.SetState(1097)
			p.Statement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1099)
			p.Match(JavaParserWHILE)
		}
		{
			p.SetState(1100)
			p.ParExpression()
		}
		{
			p.SetState(1101)
			p.Statement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1103)
			p.Match(JavaParserDO)
		}
		{
			p.SetState(1104)
			p.Statement()
		}
		{
			p.SetState(1105)
			p.Match(JavaParserWHILE)
		}
		{
			p.SetState(1106)
			p.ParExpression()
		}
		{
			p.SetState(1107)
			p.Match(JavaParserSEMI)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1109)
			p.Match(JavaParserTRY)
		}
		{
			p.SetState(1110)
			p.Block()
		}
		p.SetState(1120)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case JavaParserCATCH:
			p.SetState(1112)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = _la == JavaParserCATCH {
				{
					p.SetState(1111)
					p.CatchClause()
				}

				p.SetState(1114)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			p.SetState(1117)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == JavaParserFINALLY {
				{
					p.SetState(1116)
					p.FinallyBlock()
				}

			}

		case JavaParserFINALLY:
			{
				p.SetState(1119)
				p.FinallyBlock()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1122)
			p.Match(JavaParserTRY)
		}
		{
			p.SetState(1123)
			p.ResourceSpecification()
		}
		{
			p.SetState(1124)
			p.Block()
		}
		p.SetState(1128)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == JavaParserCATCH {
			{
				p.SetState(1125)
				p.CatchClause()
			}

			p.SetState(1130)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1132)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JavaParserFINALLY {
			{
				p.SetState(1131)
				p.FinallyBlock()
			}

		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1134)
			p.Match(JavaParserSWITCH)
		}
		{
			p.SetState(1135)
			p.ParExpression()
		}
		{
			p.SetState(1136)
			p.Match(JavaParserLBRACE)
		}
		p.SetState(1140)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 130, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1137)
					p.SwitchBlockStatementGroup()
				}

			}
			p.SetState(1142)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 130, p.GetParserRuleContext())
		}
		p.SetState(1146)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == JavaParserCASE || _la == JavaParserDEFAULT {
			{
				p.SetState(1143)
				p.SwitchLabel()
			}

			p.SetState(1148)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1149)
			p.Match(JavaParserRBRACE)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1151)
			p.Match(JavaParserSYNCHRONIZED)
		}
		{
			p.SetState(1152)
			p.ParExpression()
		}
		{
			p.SetState(1153)
			p.Block()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1155)
			p.Match(JavaParserRETURN)
		}
		p.SetState(1157)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<JavaParserBOOLEAN)|(1<<JavaParserBYTE)|(1<<JavaParserCHAR)|(1<<JavaParserDOUBLE)|(1<<JavaParserFLOAT)|(1<<JavaParserINT)|(1<<JavaParserLONG)|(1<<JavaParserNEW))) != 0) || (((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(JavaParserSHORT-37))|(1<<(JavaParserSUPER-37))|(1<<(JavaParserSWITCH-37))|(1<<(JavaParserTHIS-37))|(1<<(JavaParserVOID-37))|(1<<(JavaParserMODULE-37))|(1<<(JavaParserOPEN-37))|(1<<(JavaParserREQUIRES-37))|(1<<(JavaParserEXPORTS-37))|(1<<(JavaParserOPENS-37))|(1<<(JavaParserTO-37))|(1<<(JavaParserUSES-37))|(1<<(JavaParserPROVIDES-37))|(1<<(JavaParserWITH-37))|(1<<(JavaParserTRANSITIVE-37))|(1<<(JavaParserVAR-37))|(1<<(JavaParserYIELD-37))|(1<<(JavaParserRECORD-37))|(1<<(JavaParserSEALED-37))|(1<<(JavaParserPERMITS-37))|(1<<(JavaParserDECIMAL_LITERAL-37))|(1<<(JavaParserHEX_LITERAL-37)))) != 0) || (((_la-69)&-(0x1f+1)) == 0 && ((1<<uint((_la-69)))&((1<<(JavaParserOCT_LITERAL-69))|(1<<(JavaParserBINARY_LITERAL-69))|(1<<(JavaParserFLOAT_LITERAL-69))|(1<<(JavaParserHEX_FLOAT_LITERAL-69))|(1<<(JavaParserBOOL_LITERAL-69))|(1<<(JavaParserCHAR_LITERAL-69))|(1<<(JavaParserSTRING_LITERAL-69))|(1<<(JavaParserTEXT_BLOCK-69))|(1<<(JavaParserNULL_LITERAL-69))|(1<<(JavaParserLPAREN-69))|(1<<(JavaParserLT-69))|(1<<(JavaParserBANG-69))|(1<<(JavaParserTILDE-69))|(1<<(JavaParserINC-69)))) != 0) || (((_la-101)&-(0x1f+1)) == 0 && ((1<<uint((_la-101)))&((1<<(JavaParserDEC-101))|(1<<(JavaParserADD-101))|(1<<(JavaParserSUB-101))|(1<<(JavaParserAT-101))|(1<<(JavaParserIDENTIFIER-101)))) != 0) {
			{
				p.SetState(1156)
				p.expression(0)
			}

		}
		{
			p.SetState(1159)
			p.Match(JavaParserSEMI)
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1160)
			p.Match(JavaParserTHROW)
		}
		{
			p.SetState(1161)
			p.expression(0)
		}
		{
			p.SetState(1162)
			p.Match(JavaParserSEMI)
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1164)
			p.Match(JavaParserBREAK)
		}
		p.SetState(1166)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-51)&-(0x1f+1)) == 0 && ((1<<uint((_la-51)))&((1<<(JavaParserMODULE-51))|(1<<(JavaParserOPEN-51))|(1<<(JavaParserREQUIRES-51))|(1<<(JavaParserEXPORTS-51))|(1<<(JavaParserOPENS-51))|(1<<(JavaParserTO-51))|(1<<(JavaParserUSES-51))|(1<<(JavaParserPROVIDES-51))|(1<<(JavaParserWITH-51))|(1<<(JavaParserTRANSITIVE-51))|(1<<(JavaParserVAR-51))|(1<<(JavaParserYIELD-51))|(1<<(JavaParserRECORD-51))|(1<<(JavaParserSEALED-51))|(1<<(JavaParserPERMITS-51)))) != 0) || _la == JavaParserIDENTIFIER {
			{
				p.SetState(1165)
				p.Identifier()
			}

		}
		{
			p.SetState(1168)
			p.Match(JavaParserSEMI)
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1169)
			p.Match(JavaParserCONTINUE)
		}
		p.SetState(1171)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-51)&-(0x1f+1)) == 0 && ((1<<uint((_la-51)))&((1<<(JavaParserMODULE-51))|(1<<(JavaParserOPEN-51))|(1<<(JavaParserREQUIRES-51))|(1<<(JavaParserEXPORTS-51))|(1<<(JavaParserOPENS-51))|(1<<(JavaParserTO-51))|(1<<(JavaParserUSES-51))|(1<<(JavaParserPROVIDES-51))|(1<<(JavaParserWITH-51))|(1<<(JavaParserTRANSITIVE-51))|(1<<(JavaParserVAR-51))|(1<<(JavaParserYIELD-51))|(1<<(JavaParserRECORD-51))|(1<<(JavaParserSEALED-51))|(1<<(JavaParserPERMITS-51)))) != 0) || _la == JavaParserIDENTIFIER {
			{
				p.SetState(1170)
				p.Identifier()
			}

		}
		{
			p.SetState(1173)
			p.Match(JavaParserSEMI)
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1174)
			p.Match(JavaParserYIELD)
		}
		{
			p.SetState(1175)
			p.expression(0)
		}
		{
			p.SetState(1176)
			p.Match(JavaParserSEMI)
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1178)
			p.Match(JavaParserSEMI)
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1179)

			var _x = p.expression(0)

			localctx.(*StatementContext).statementExpression = _x
		}
		{
			p.SetState(1180)
			p.Match(JavaParserSEMI)
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1182)
			p.SwitchExpression()
		}
		p.SetState(1184)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 135, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1183)
				p.Match(JavaParserSEMI)
			}

		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1186)

			var _x = p.Identifier()

			localctx.(*StatementContext).identifierLabel = _x
		}
		{
			p.SetState(1187)
			p.Match(JavaParserCOLON)
		}
		{
			p.SetState(1188)
			p.Statement()
		}

	}

	return localctx
}

// ICatchClauseContext is an interface to support dynamic dispatch.
type ICatchClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCatchClauseContext differentiates from other interfaces.
	IsCatchClauseContext()
}

type CatchClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatchClauseContext() *CatchClauseContext {
	var p = new(CatchClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_catchClause
	return p
}

func (*CatchClauseContext) IsCatchClauseContext() {}

func NewCatchClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatchClauseContext {
	var p = new(CatchClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_catchClause

	return p
}

func (s *CatchClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CatchClauseContext) CATCH() antlr.TerminalNode {
	return s.GetToken(JavaParserCATCH, 0)
}

func (s *CatchClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserLPAREN, 0)
}

func (s *CatchClauseContext) CatchType() ICatchTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatchTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatchTypeContext)
}

func (s *CatchClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CatchClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserRPAREN, 0)
}

func (s *CatchClauseContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *CatchClauseContext) AllVariableModifier() []IVariableModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableModifierContext); ok {
			len++
		}
	}

	tst := make([]IVariableModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableModifierContext); ok {
			tst[i] = t.(IVariableModifierContext)
			i++
		}
	}

	return tst
}

func (s *CatchClauseContext) VariableModifier(i int) IVariableModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableModifierContext)
}

func (s *CatchClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatchClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatchClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterCatchClause(s)
	}
}

func (s *CatchClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitCatchClause(s)
	}
}

func (p *JavaParser) CatchClause() (localctx ICatchClauseContext) {
	this := p
	_ = this

	localctx = NewCatchClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, JavaParserRULE_catchClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1192)
		p.Match(JavaParserCATCH)
	}
	{
		p.SetState(1193)
		p.Match(JavaParserLPAREN)
	}
	p.SetState(1197)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 137, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1194)
				p.VariableModifier()
			}

		}
		p.SetState(1199)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 137, p.GetParserRuleContext())
	}
	{
		p.SetState(1200)
		p.CatchType()
	}
	{
		p.SetState(1201)
		p.Identifier()
	}
	{
		p.SetState(1202)
		p.Match(JavaParserRPAREN)
	}
	{
		p.SetState(1203)
		p.Block()
	}

	return localctx
}

// ICatchTypeContext is an interface to support dynamic dispatch.
type ICatchTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCatchTypeContext differentiates from other interfaces.
	IsCatchTypeContext()
}

type CatchTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatchTypeContext() *CatchTypeContext {
	var p = new(CatchTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_catchType
	return p
}

func (*CatchTypeContext) IsCatchTypeContext() {}

func NewCatchTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatchTypeContext {
	var p = new(CatchTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_catchType

	return p
}

func (s *CatchTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *CatchTypeContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *CatchTypeContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CatchTypeContext) AllBITOR() []antlr.TerminalNode {
	return s.GetTokens(JavaParserBITOR)
}

func (s *CatchTypeContext) BITOR(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserBITOR, i)
}

func (s *CatchTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatchTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatchTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterCatchType(s)
	}
}

func (s *CatchTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitCatchType(s)
	}
}

func (p *JavaParser) CatchType() (localctx ICatchTypeContext) {
	this := p
	_ = this

	localctx = NewCatchTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, JavaParserRULE_catchType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1205)
		p.QualifiedName()
	}
	p.SetState(1210)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == JavaParserBITOR {
		{
			p.SetState(1206)
			p.Match(JavaParserBITOR)
		}
		{
			p.SetState(1207)
			p.QualifiedName()
		}

		p.SetState(1212)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFinallyBlockContext is an interface to support dynamic dispatch.
type IFinallyBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFinallyBlockContext differentiates from other interfaces.
	IsFinallyBlockContext()
}

type FinallyBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinallyBlockContext() *FinallyBlockContext {
	var p = new(FinallyBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_finallyBlock
	return p
}

func (*FinallyBlockContext) IsFinallyBlockContext() {}

func NewFinallyBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FinallyBlockContext {
	var p = new(FinallyBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_finallyBlock

	return p
}

func (s *FinallyBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *FinallyBlockContext) FINALLY() antlr.TerminalNode {
	return s.GetToken(JavaParserFINALLY, 0)
}

func (s *FinallyBlockContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *FinallyBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FinallyBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FinallyBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterFinallyBlock(s)
	}
}

func (s *FinallyBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitFinallyBlock(s)
	}
}

func (p *JavaParser) FinallyBlock() (localctx IFinallyBlockContext) {
	this := p
	_ = this

	localctx = NewFinallyBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, JavaParserRULE_finallyBlock)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1213)
		p.Match(JavaParserFINALLY)
	}
	{
		p.SetState(1214)
		p.Block()
	}

	return localctx
}

// IResourceSpecificationContext is an interface to support dynamic dispatch.
type IResourceSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsResourceSpecificationContext differentiates from other interfaces.
	IsResourceSpecificationContext()
}

type ResourceSpecificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourceSpecificationContext() *ResourceSpecificationContext {
	var p = new(ResourceSpecificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_resourceSpecification
	return p
}

func (*ResourceSpecificationContext) IsResourceSpecificationContext() {}

func NewResourceSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceSpecificationContext {
	var p = new(ResourceSpecificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_resourceSpecification

	return p
}

func (s *ResourceSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceSpecificationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserLPAREN, 0)
}

func (s *ResourceSpecificationContext) Resources() IResourcesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourcesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourcesContext)
}

func (s *ResourceSpecificationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserRPAREN, 0)
}

func (s *ResourceSpecificationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(JavaParserSEMI, 0)
}

func (s *ResourceSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterResourceSpecification(s)
	}
}

func (s *ResourceSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitResourceSpecification(s)
	}
}

func (p *JavaParser) ResourceSpecification() (localctx IResourceSpecificationContext) {
	this := p
	_ = this

	localctx = NewResourceSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, JavaParserRULE_resourceSpecification)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1216)
		p.Match(JavaParserLPAREN)
	}
	{
		p.SetState(1217)
		p.Resources()
	}
	p.SetState(1219)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserSEMI {
		{
			p.SetState(1218)
			p.Match(JavaParserSEMI)
		}

	}
	{
		p.SetState(1221)
		p.Match(JavaParserRPAREN)
	}

	return localctx
}

// IResourcesContext is an interface to support dynamic dispatch.
type IResourcesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsResourcesContext differentiates from other interfaces.
	IsResourcesContext()
}

type ResourcesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourcesContext() *ResourcesContext {
	var p = new(ResourcesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_resources
	return p
}

func (*ResourcesContext) IsResourcesContext() {}

func NewResourcesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourcesContext {
	var p = new(ResourcesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_resources

	return p
}

func (s *ResourcesContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourcesContext) AllResource() []IResourceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IResourceContext); ok {
			len++
		}
	}

	tst := make([]IResourceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IResourceContext); ok {
			tst[i] = t.(IResourceContext)
			i++
		}
	}

	return tst
}

func (s *ResourcesContext) Resource(i int) IResourceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceContext)
}

func (s *ResourcesContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(JavaParserSEMI)
}

func (s *ResourcesContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserSEMI, i)
}

func (s *ResourcesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourcesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourcesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterResources(s)
	}
}

func (s *ResourcesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitResources(s)
	}
}

func (p *JavaParser) Resources() (localctx IResourcesContext) {
	this := p
	_ = this

	localctx = NewResourcesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, JavaParserRULE_resources)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1223)
		p.Resource()
	}
	p.SetState(1228)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 140, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1224)
				p.Match(JavaParserSEMI)
			}
			{
				p.SetState(1225)
				p.Resource()
			}

		}
		p.SetState(1230)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 140, p.GetParserRuleContext())
	}

	return localctx
}

// IResourceContext is an interface to support dynamic dispatch.
type IResourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsResourceContext differentiates from other interfaces.
	IsResourceContext()
}

type ResourceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourceContext() *ResourceContext {
	var p = new(ResourceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_resource
	return p
}

func (*ResourceContext) IsResourceContext() {}

func NewResourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceContext {
	var p = new(ResourceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_resource

	return p
}

func (s *ResourceContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(JavaParserASSIGN, 0)
}

func (s *ResourceContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ResourceContext) ClassOrInterfaceType() IClassOrInterfaceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOrInterfaceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOrInterfaceTypeContext)
}

func (s *ResourceContext) VariableDeclaratorId() IVariableDeclaratorIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorIdContext)
}

func (s *ResourceContext) VAR() antlr.TerminalNode {
	return s.GetToken(JavaParserVAR, 0)
}

func (s *ResourceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ResourceContext) AllVariableModifier() []IVariableModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableModifierContext); ok {
			len++
		}
	}

	tst := make([]IVariableModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableModifierContext); ok {
			tst[i] = t.(IVariableModifierContext)
			i++
		}
	}

	return tst
}

func (s *ResourceContext) VariableModifier(i int) IVariableModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableModifierContext)
}

func (s *ResourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterResource(s)
	}
}

func (s *ResourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitResource(s)
	}
}

func (p *JavaParser) Resource() (localctx IResourceContext) {
	this := p
	_ = this

	localctx = NewResourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, JavaParserRULE_resource)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1248)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 143, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1234)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 141, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1231)
					p.VariableModifier()
				}

			}
			p.SetState(1236)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 141, p.GetParserRuleContext())
		}
		p.SetState(1242)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 142, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1237)
				p.ClassOrInterfaceType()
			}
			{
				p.SetState(1238)
				p.VariableDeclaratorId()
			}

		case 2:
			{
				p.SetState(1240)
				p.Match(JavaParserVAR)
			}
			{
				p.SetState(1241)
				p.Identifier()
			}

		}
		{
			p.SetState(1244)
			p.Match(JavaParserASSIGN)
		}
		{
			p.SetState(1245)
			p.expression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1247)
			p.Identifier()
		}

	}

	return localctx
}

// ISwitchBlockStatementGroupContext is an interface to support dynamic dispatch.
type ISwitchBlockStatementGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitchBlockStatementGroupContext differentiates from other interfaces.
	IsSwitchBlockStatementGroupContext()
}

type SwitchBlockStatementGroupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchBlockStatementGroupContext() *SwitchBlockStatementGroupContext {
	var p = new(SwitchBlockStatementGroupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_switchBlockStatementGroup
	return p
}

func (*SwitchBlockStatementGroupContext) IsSwitchBlockStatementGroupContext() {}

func NewSwitchBlockStatementGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchBlockStatementGroupContext {
	var p = new(SwitchBlockStatementGroupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_switchBlockStatementGroup

	return p
}

func (s *SwitchBlockStatementGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchBlockStatementGroupContext) AllSwitchLabel() []ISwitchLabelContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISwitchLabelContext); ok {
			len++
		}
	}

	tst := make([]ISwitchLabelContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISwitchLabelContext); ok {
			tst[i] = t.(ISwitchLabelContext)
			i++
		}
	}

	return tst
}

func (s *SwitchBlockStatementGroupContext) SwitchLabel(i int) ISwitchLabelContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchLabelContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchLabelContext)
}

func (s *SwitchBlockStatementGroupContext) AllBlockStatement() []IBlockStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBlockStatementContext); ok {
			len++
		}
	}

	tst := make([]IBlockStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBlockStatementContext); ok {
			tst[i] = t.(IBlockStatementContext)
			i++
		}
	}

	return tst
}

func (s *SwitchBlockStatementGroupContext) BlockStatement(i int) IBlockStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockStatementContext)
}

func (s *SwitchBlockStatementGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchBlockStatementGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchBlockStatementGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterSwitchBlockStatementGroup(s)
	}
}

func (s *SwitchBlockStatementGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitSwitchBlockStatementGroup(s)
	}
}

func (p *JavaParser) SwitchBlockStatementGroup() (localctx ISwitchBlockStatementGroupContext) {
	this := p
	_ = this

	localctx = NewSwitchBlockStatementGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, JavaParserRULE_switchBlockStatementGroup)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1251)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == JavaParserCASE || _la == JavaParserDEFAULT {
		{
			p.SetState(1250)
			p.SwitchLabel()
		}

		p.SetState(1253)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1256)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<JavaParserABSTRACT)|(1<<JavaParserASSERT)|(1<<JavaParserBOOLEAN)|(1<<JavaParserBREAK)|(1<<JavaParserBYTE)|(1<<JavaParserCHAR)|(1<<JavaParserCLASS)|(1<<JavaParserCONTINUE)|(1<<JavaParserDO)|(1<<JavaParserDOUBLE)|(1<<JavaParserFINAL)|(1<<JavaParserFLOAT)|(1<<JavaParserFOR)|(1<<JavaParserIF)|(1<<JavaParserINT)|(1<<JavaParserINTERFACE)|(1<<JavaParserLONG)|(1<<JavaParserNEW))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(JavaParserPRIVATE-33))|(1<<(JavaParserPROTECTED-33))|(1<<(JavaParserPUBLIC-33))|(1<<(JavaParserRETURN-33))|(1<<(JavaParserSHORT-33))|(1<<(JavaParserSTATIC-33))|(1<<(JavaParserSTRICTFP-33))|(1<<(JavaParserSUPER-33))|(1<<(JavaParserSWITCH-33))|(1<<(JavaParserSYNCHRONIZED-33))|(1<<(JavaParserTHIS-33))|(1<<(JavaParserTHROW-33))|(1<<(JavaParserTRY-33))|(1<<(JavaParserVOID-33))|(1<<(JavaParserWHILE-33))|(1<<(JavaParserMODULE-33))|(1<<(JavaParserOPEN-33))|(1<<(JavaParserREQUIRES-33))|(1<<(JavaParserEXPORTS-33))|(1<<(JavaParserOPENS-33))|(1<<(JavaParserTO-33))|(1<<(JavaParserUSES-33))|(1<<(JavaParserPROVIDES-33))|(1<<(JavaParserWITH-33))|(1<<(JavaParserTRANSITIVE-33))|(1<<(JavaParserVAR-33))|(1<<(JavaParserYIELD-33))|(1<<(JavaParserRECORD-33))|(1<<(JavaParserSEALED-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(JavaParserPERMITS-65))|(1<<(JavaParserNON_SEALED-65))|(1<<(JavaParserDECIMAL_LITERAL-65))|(1<<(JavaParserHEX_LITERAL-65))|(1<<(JavaParserOCT_LITERAL-65))|(1<<(JavaParserBINARY_LITERAL-65))|(1<<(JavaParserFLOAT_LITERAL-65))|(1<<(JavaParserHEX_FLOAT_LITERAL-65))|(1<<(JavaParserBOOL_LITERAL-65))|(1<<(JavaParserCHAR_LITERAL-65))|(1<<(JavaParserSTRING_LITERAL-65))|(1<<(JavaParserTEXT_BLOCK-65))|(1<<(JavaParserNULL_LITERAL-65))|(1<<(JavaParserLPAREN-65))|(1<<(JavaParserLBRACE-65))|(1<<(JavaParserSEMI-65))|(1<<(JavaParserLT-65))|(1<<(JavaParserBANG-65))|(1<<(JavaParserTILDE-65)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(JavaParserINC-100))|(1<<(JavaParserDEC-100))|(1<<(JavaParserADD-100))|(1<<(JavaParserSUB-100))|(1<<(JavaParserAT-100))|(1<<(JavaParserIDENTIFIER-100)))) != 0) {
		{
			p.SetState(1255)
			p.BlockStatement()
		}

		p.SetState(1258)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISwitchLabelContext is an interface to support dynamic dispatch.
type ISwitchLabelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetEnumConstantName returns the enumConstantName token.
	GetEnumConstantName() antlr.Token

	// SetEnumConstantName sets the enumConstantName token.
	SetEnumConstantName(antlr.Token)

	// GetConstantExpression returns the constantExpression rule contexts.
	GetConstantExpression() IExpressionContext

	// GetVarName returns the varName rule contexts.
	GetVarName() IIdentifierContext

	// SetConstantExpression sets the constantExpression rule contexts.
	SetConstantExpression(IExpressionContext)

	// SetVarName sets the varName rule contexts.
	SetVarName(IIdentifierContext)

	// IsSwitchLabelContext differentiates from other interfaces.
	IsSwitchLabelContext()
}

type SwitchLabelContext struct {
	*antlr.BaseParserRuleContext
	parser             antlr.Parser
	constantExpression IExpressionContext
	enumConstantName   antlr.Token
	varName            IIdentifierContext
}

func NewEmptySwitchLabelContext() *SwitchLabelContext {
	var p = new(SwitchLabelContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_switchLabel
	return p
}

func (*SwitchLabelContext) IsSwitchLabelContext() {}

func NewSwitchLabelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchLabelContext {
	var p = new(SwitchLabelContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_switchLabel

	return p
}

func (s *SwitchLabelContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchLabelContext) GetEnumConstantName() antlr.Token { return s.enumConstantName }

func (s *SwitchLabelContext) SetEnumConstantName(v antlr.Token) { s.enumConstantName = v }

func (s *SwitchLabelContext) GetConstantExpression() IExpressionContext { return s.constantExpression }

func (s *SwitchLabelContext) GetVarName() IIdentifierContext { return s.varName }

func (s *SwitchLabelContext) SetConstantExpression(v IExpressionContext) { s.constantExpression = v }

func (s *SwitchLabelContext) SetVarName(v IIdentifierContext) { s.varName = v }

func (s *SwitchLabelContext) CASE() antlr.TerminalNode {
	return s.GetToken(JavaParserCASE, 0)
}

func (s *SwitchLabelContext) COLON() antlr.TerminalNode {
	return s.GetToken(JavaParserCOLON, 0)
}

func (s *SwitchLabelContext) TypeType() ITypeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *SwitchLabelContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SwitchLabelContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(JavaParserIDENTIFIER, 0)
}

func (s *SwitchLabelContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SwitchLabelContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(JavaParserDEFAULT, 0)
}

func (s *SwitchLabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchLabelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchLabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterSwitchLabel(s)
	}
}

func (s *SwitchLabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitSwitchLabel(s)
	}
}

func (p *JavaParser) SwitchLabel() (localctx ISwitchLabelContext) {
	this := p
	_ = this

	localctx = NewSwitchLabelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, JavaParserRULE_switchLabel)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1271)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JavaParserCASE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1260)
			p.Match(JavaParserCASE)
		}
		p.SetState(1266)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 146, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1261)

				var _x = p.expression(0)

				localctx.(*SwitchLabelContext).constantExpression = _x
			}

		case 2:
			{
				p.SetState(1262)

				var _m = p.Match(JavaParserIDENTIFIER)

				localctx.(*SwitchLabelContext).enumConstantName = _m
			}

		case 3:
			{
				p.SetState(1263)
				p.TypeType()
			}
			{
				p.SetState(1264)

				var _x = p.Identifier()

				localctx.(*SwitchLabelContext).varName = _x
			}

		}
		{
			p.SetState(1268)
			p.Match(JavaParserCOLON)
		}

	case JavaParserDEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1269)
			p.Match(JavaParserDEFAULT)
		}
		{
			p.SetState(1270)
			p.Match(JavaParserCOLON)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IForControlContext is an interface to support dynamic dispatch.
type IForControlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetForUpdate returns the forUpdate rule contexts.
	GetForUpdate() IExpressionListContext

	// SetForUpdate sets the forUpdate rule contexts.
	SetForUpdate(IExpressionListContext)

	// IsForControlContext differentiates from other interfaces.
	IsForControlContext()
}

type ForControlContext struct {
	*antlr.BaseParserRuleContext
	parser    antlr.Parser
	forUpdate IExpressionListContext
}

func NewEmptyForControlContext() *ForControlContext {
	var p = new(ForControlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_forControl
	return p
}

func (*ForControlContext) IsForControlContext() {}

func NewForControlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForControlContext {
	var p = new(ForControlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_forControl

	return p
}

func (s *ForControlContext) GetParser() antlr.Parser { return s.parser }

func (s *ForControlContext) GetForUpdate() IExpressionListContext { return s.forUpdate }

func (s *ForControlContext) SetForUpdate(v IExpressionListContext) { s.forUpdate = v }

func (s *ForControlContext) EnhancedForControl() IEnhancedForControlContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnhancedForControlContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnhancedForControlContext)
}

func (s *ForControlContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(JavaParserSEMI)
}

func (s *ForControlContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserSEMI, i)
}

func (s *ForControlContext) ForInit() IForInitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForInitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForInitContext)
}

func (s *ForControlContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ForControlContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ForControlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForControlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForControlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterForControl(s)
	}
}

func (s *ForControlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitForControl(s)
	}
}

func (p *JavaParser) ForControl() (localctx IForControlContext) {
	this := p
	_ = this

	localctx = NewForControlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, JavaParserRULE_forControl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1285)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 151, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1273)
			p.EnhancedForControl()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1275)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<JavaParserBOOLEAN)|(1<<JavaParserBYTE)|(1<<JavaParserCHAR)|(1<<JavaParserDOUBLE)|(1<<JavaParserFINAL)|(1<<JavaParserFLOAT)|(1<<JavaParserINT)|(1<<JavaParserLONG)|(1<<JavaParserNEW))) != 0) || (((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(JavaParserSHORT-37))|(1<<(JavaParserSUPER-37))|(1<<(JavaParserSWITCH-37))|(1<<(JavaParserTHIS-37))|(1<<(JavaParserVOID-37))|(1<<(JavaParserMODULE-37))|(1<<(JavaParserOPEN-37))|(1<<(JavaParserREQUIRES-37))|(1<<(JavaParserEXPORTS-37))|(1<<(JavaParserOPENS-37))|(1<<(JavaParserTO-37))|(1<<(JavaParserUSES-37))|(1<<(JavaParserPROVIDES-37))|(1<<(JavaParserWITH-37))|(1<<(JavaParserTRANSITIVE-37))|(1<<(JavaParserVAR-37))|(1<<(JavaParserYIELD-37))|(1<<(JavaParserRECORD-37))|(1<<(JavaParserSEALED-37))|(1<<(JavaParserPERMITS-37))|(1<<(JavaParserDECIMAL_LITERAL-37))|(1<<(JavaParserHEX_LITERAL-37)))) != 0) || (((_la-69)&-(0x1f+1)) == 0 && ((1<<uint((_la-69)))&((1<<(JavaParserOCT_LITERAL-69))|(1<<(JavaParserBINARY_LITERAL-69))|(1<<(JavaParserFLOAT_LITERAL-69))|(1<<(JavaParserHEX_FLOAT_LITERAL-69))|(1<<(JavaParserBOOL_LITERAL-69))|(1<<(JavaParserCHAR_LITERAL-69))|(1<<(JavaParserSTRING_LITERAL-69))|(1<<(JavaParserTEXT_BLOCK-69))|(1<<(JavaParserNULL_LITERAL-69))|(1<<(JavaParserLPAREN-69))|(1<<(JavaParserLT-69))|(1<<(JavaParserBANG-69))|(1<<(JavaParserTILDE-69))|(1<<(JavaParserINC-69)))) != 0) || (((_la-101)&-(0x1f+1)) == 0 && ((1<<uint((_la-101)))&((1<<(JavaParserDEC-101))|(1<<(JavaParserADD-101))|(1<<(JavaParserSUB-101))|(1<<(JavaParserAT-101))|(1<<(JavaParserIDENTIFIER-101)))) != 0) {
			{
				p.SetState(1274)
				p.ForInit()
			}

		}
		{
			p.SetState(1277)
			p.Match(JavaParserSEMI)
		}
		p.SetState(1279)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<JavaParserBOOLEAN)|(1<<JavaParserBYTE)|(1<<JavaParserCHAR)|(1<<JavaParserDOUBLE)|(1<<JavaParserFLOAT)|(1<<JavaParserINT)|(1<<JavaParserLONG)|(1<<JavaParserNEW))) != 0) || (((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(JavaParserSHORT-37))|(1<<(JavaParserSUPER-37))|(1<<(JavaParserSWITCH-37))|(1<<(JavaParserTHIS-37))|(1<<(JavaParserVOID-37))|(1<<(JavaParserMODULE-37))|(1<<(JavaParserOPEN-37))|(1<<(JavaParserREQUIRES-37))|(1<<(JavaParserEXPORTS-37))|(1<<(JavaParserOPENS-37))|(1<<(JavaParserTO-37))|(1<<(JavaParserUSES-37))|(1<<(JavaParserPROVIDES-37))|(1<<(JavaParserWITH-37))|(1<<(JavaParserTRANSITIVE-37))|(1<<(JavaParserVAR-37))|(1<<(JavaParserYIELD-37))|(1<<(JavaParserRECORD-37))|(1<<(JavaParserSEALED-37))|(1<<(JavaParserPERMITS-37))|(1<<(JavaParserDECIMAL_LITERAL-37))|(1<<(JavaParserHEX_LITERAL-37)))) != 0) || (((_la-69)&-(0x1f+1)) == 0 && ((1<<uint((_la-69)))&((1<<(JavaParserOCT_LITERAL-69))|(1<<(JavaParserBINARY_LITERAL-69))|(1<<(JavaParserFLOAT_LITERAL-69))|(1<<(JavaParserHEX_FLOAT_LITERAL-69))|(1<<(JavaParserBOOL_LITERAL-69))|(1<<(JavaParserCHAR_LITERAL-69))|(1<<(JavaParserSTRING_LITERAL-69))|(1<<(JavaParserTEXT_BLOCK-69))|(1<<(JavaParserNULL_LITERAL-69))|(1<<(JavaParserLPAREN-69))|(1<<(JavaParserLT-69))|(1<<(JavaParserBANG-69))|(1<<(JavaParserTILDE-69))|(1<<(JavaParserINC-69)))) != 0) || (((_la-101)&-(0x1f+1)) == 0 && ((1<<uint((_la-101)))&((1<<(JavaParserDEC-101))|(1<<(JavaParserADD-101))|(1<<(JavaParserSUB-101))|(1<<(JavaParserAT-101))|(1<<(JavaParserIDENTIFIER-101)))) != 0) {
			{
				p.SetState(1278)
				p.expression(0)
			}

		}
		{
			p.SetState(1281)
			p.Match(JavaParserSEMI)
		}
		p.SetState(1283)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<JavaParserBOOLEAN)|(1<<JavaParserBYTE)|(1<<JavaParserCHAR)|(1<<JavaParserDOUBLE)|(1<<JavaParserFLOAT)|(1<<JavaParserINT)|(1<<JavaParserLONG)|(1<<JavaParserNEW))) != 0) || (((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(JavaParserSHORT-37))|(1<<(JavaParserSUPER-37))|(1<<(JavaParserSWITCH-37))|(1<<(JavaParserTHIS-37))|(1<<(JavaParserVOID-37))|(1<<(JavaParserMODULE-37))|(1<<(JavaParserOPEN-37))|(1<<(JavaParserREQUIRES-37))|(1<<(JavaParserEXPORTS-37))|(1<<(JavaParserOPENS-37))|(1<<(JavaParserTO-37))|(1<<(JavaParserUSES-37))|(1<<(JavaParserPROVIDES-37))|(1<<(JavaParserWITH-37))|(1<<(JavaParserTRANSITIVE-37))|(1<<(JavaParserVAR-37))|(1<<(JavaParserYIELD-37))|(1<<(JavaParserRECORD-37))|(1<<(JavaParserSEALED-37))|(1<<(JavaParserPERMITS-37))|(1<<(JavaParserDECIMAL_LITERAL-37))|(1<<(JavaParserHEX_LITERAL-37)))) != 0) || (((_la-69)&-(0x1f+1)) == 0 && ((1<<uint((_la-69)))&((1<<(JavaParserOCT_LITERAL-69))|(1<<(JavaParserBINARY_LITERAL-69))|(1<<(JavaParserFLOAT_LITERAL-69))|(1<<(JavaParserHEX_FLOAT_LITERAL-69))|(1<<(JavaParserBOOL_LITERAL-69))|(1<<(JavaParserCHAR_LITERAL-69))|(1<<(JavaParserSTRING_LITERAL-69))|(1<<(JavaParserTEXT_BLOCK-69))|(1<<(JavaParserNULL_LITERAL-69))|(1<<(JavaParserLPAREN-69))|(1<<(JavaParserLT-69))|(1<<(JavaParserBANG-69))|(1<<(JavaParserTILDE-69))|(1<<(JavaParserINC-69)))) != 0) || (((_la-101)&-(0x1f+1)) == 0 && ((1<<uint((_la-101)))&((1<<(JavaParserDEC-101))|(1<<(JavaParserADD-101))|(1<<(JavaParserSUB-101))|(1<<(JavaParserAT-101))|(1<<(JavaParserIDENTIFIER-101)))) != 0) {
			{
				p.SetState(1282)

				var _x = p.ExpressionList()

				localctx.(*ForControlContext).forUpdate = _x
			}

		}

	}

	return localctx
}

// IForInitContext is an interface to support dynamic dispatch.
type IForInitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForInitContext differentiates from other interfaces.
	IsForInitContext()
}

type ForInitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForInitContext() *ForInitContext {
	var p = new(ForInitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_forInit
	return p
}

func (*ForInitContext) IsForInitContext() {}

func NewForInitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForInitContext {
	var p = new(ForInitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_forInit

	return p
}

func (s *ForInitContext) GetParser() antlr.Parser { return s.parser }

func (s *ForInitContext) LocalVariableDeclaration() ILocalVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocalVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocalVariableDeclarationContext)
}

func (s *ForInitContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ForInitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForInitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForInitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterForInit(s)
	}
}

func (s *ForInitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitForInit(s)
	}
}

func (p *JavaParser) ForInit() (localctx IForInitContext) {
	this := p
	_ = this

	localctx = NewForInitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, JavaParserRULE_forInit)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1289)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 152, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1287)
			p.LocalVariableDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1288)
			p.ExpressionList()
		}

	}

	return localctx
}

// IEnhancedForControlContext is an interface to support dynamic dispatch.
type IEnhancedForControlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnhancedForControlContext differentiates from other interfaces.
	IsEnhancedForControlContext()
}

type EnhancedForControlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnhancedForControlContext() *EnhancedForControlContext {
	var p = new(EnhancedForControlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_enhancedForControl
	return p
}

func (*EnhancedForControlContext) IsEnhancedForControlContext() {}

func NewEnhancedForControlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnhancedForControlContext {
	var p = new(EnhancedForControlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_enhancedForControl

	return p
}

func (s *EnhancedForControlContext) GetParser() antlr.Parser { return s.parser }

func (s *EnhancedForControlContext) VariableDeclaratorId() IVariableDeclaratorIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorIdContext)
}

func (s *EnhancedForControlContext) COLON() antlr.TerminalNode {
	return s.GetToken(JavaParserCOLON, 0)
}

func (s *EnhancedForControlContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *EnhancedForControlContext) TypeType() ITypeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *EnhancedForControlContext) VAR() antlr.TerminalNode {
	return s.GetToken(JavaParserVAR, 0)
}

func (s *EnhancedForControlContext) AllVariableModifier() []IVariableModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableModifierContext); ok {
			len++
		}
	}

	tst := make([]IVariableModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableModifierContext); ok {
			tst[i] = t.(IVariableModifierContext)
			i++
		}
	}

	return tst
}

func (s *EnhancedForControlContext) VariableModifier(i int) IVariableModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableModifierContext)
}

func (s *EnhancedForControlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnhancedForControlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnhancedForControlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterEnhancedForControl(s)
	}
}

func (s *EnhancedForControlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitEnhancedForControl(s)
	}
}

func (p *JavaParser) EnhancedForControl() (localctx IEnhancedForControlContext) {
	this := p
	_ = this

	localctx = NewEnhancedForControlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, JavaParserRULE_enhancedForControl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1294)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 153, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1291)
				p.VariableModifier()
			}

		}
		p.SetState(1296)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 153, p.GetParserRuleContext())
	}
	p.SetState(1299)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 154, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1297)
			p.TypeType()
		}

	case 2:
		{
			p.SetState(1298)
			p.Match(JavaParserVAR)
		}

	}
	{
		p.SetState(1301)
		p.VariableDeclaratorId()
	}
	{
		p.SetState(1302)
		p.Match(JavaParserCOLON)
	}
	{
		p.SetState(1303)
		p.expression(0)
	}

	return localctx
}

// IParExpressionContext is an interface to support dynamic dispatch.
type IParExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParExpressionContext differentiates from other interfaces.
	IsParExpressionContext()
}

type ParExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParExpressionContext() *ParExpressionContext {
	var p = new(ParExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_parExpression
	return p
}

func (*ParExpressionContext) IsParExpressionContext() {}

func NewParExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParExpressionContext {
	var p = new(ParExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_parExpression

	return p
}

func (s *ParExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ParExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserLPAREN, 0)
}

func (s *ParExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserRPAREN, 0)
}

func (s *ParExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterParExpression(s)
	}
}

func (s *ParExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitParExpression(s)
	}
}

func (p *JavaParser) ParExpression() (localctx IParExpressionContext) {
	this := p
	_ = this

	localctx = NewParExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, JavaParserRULE_parExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1305)
		p.Match(JavaParserLPAREN)
	}
	{
		p.SetState(1306)
		p.expression(0)
	}
	{
		p.SetState(1307)
		p.Match(JavaParserRPAREN)
	}

	return localctx
}

// IExpressionListContext is an interface to support dynamic dispatch.
type IExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionListContext differentiates from other interfaces.
	IsExpressionListContext()
}

type ExpressionListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionListContext() *ExpressionListContext {
	var p = new(ExpressionListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_expressionList
	return p
}

func (*ExpressionListContext) IsExpressionListContext() {}

func NewExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionListContext {
	var p = new(ExpressionListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_expressionList

	return p
}

func (s *ExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionListContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionListContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(JavaParserCOMMA)
}

func (s *ExpressionListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserCOMMA, i)
}

func (s *ExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterExpressionList(s)
	}
}

func (s *ExpressionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitExpressionList(s)
	}
}

func (p *JavaParser) ExpressionList() (localctx IExpressionListContext) {
	this := p
	_ = this

	localctx = NewExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, JavaParserRULE_expressionList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1309)
		p.expression(0)
	}
	p.SetState(1314)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == JavaParserCOMMA {
		{
			p.SetState(1310)
			p.Match(JavaParserCOMMA)
		}
		{
			p.SetState(1311)
			p.expression(0)
		}

		p.SetState(1316)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IMethodCallContext is an interface to support dynamic dispatch.
type IMethodCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethodCallContext differentiates from other interfaces.
	IsMethodCallContext()
}

type MethodCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodCallContext() *MethodCallContext {
	var p = new(MethodCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_methodCall
	return p
}

func (*MethodCallContext) IsMethodCallContext() {}

func NewMethodCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodCallContext {
	var p = new(MethodCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_methodCall

	return p
}

func (s *MethodCallContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodCallContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MethodCallContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserLPAREN, 0)
}

func (s *MethodCallContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserRPAREN, 0)
}

func (s *MethodCallContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *MethodCallContext) THIS() antlr.TerminalNode {
	return s.GetToken(JavaParserTHIS, 0)
}

func (s *MethodCallContext) SUPER() antlr.TerminalNode {
	return s.GetToken(JavaParserSUPER, 0)
}

func (s *MethodCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterMethodCall(s)
	}
}

func (s *MethodCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitMethodCall(s)
	}
}

func (p *JavaParser) MethodCall() (localctx IMethodCallContext) {
	this := p
	_ = this

	localctx = NewMethodCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, JavaParserRULE_methodCall)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1336)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JavaParserMODULE, JavaParserOPEN, JavaParserREQUIRES, JavaParserEXPORTS, JavaParserOPENS, JavaParserTO, JavaParserUSES, JavaParserPROVIDES, JavaParserWITH, JavaParserTRANSITIVE, JavaParserVAR, JavaParserYIELD, JavaParserRECORD, JavaParserSEALED, JavaParserPERMITS, JavaParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1317)
			p.Identifier()
		}
		{
			p.SetState(1318)
			p.Match(JavaParserLPAREN)
		}
		p.SetState(1320)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<JavaParserBOOLEAN)|(1<<JavaParserBYTE)|(1<<JavaParserCHAR)|(1<<JavaParserDOUBLE)|(1<<JavaParserFLOAT)|(1<<JavaParserINT)|(1<<JavaParserLONG)|(1<<JavaParserNEW))) != 0) || (((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(JavaParserSHORT-37))|(1<<(JavaParserSUPER-37))|(1<<(JavaParserSWITCH-37))|(1<<(JavaParserTHIS-37))|(1<<(JavaParserVOID-37))|(1<<(JavaParserMODULE-37))|(1<<(JavaParserOPEN-37))|(1<<(JavaParserREQUIRES-37))|(1<<(JavaParserEXPORTS-37))|(1<<(JavaParserOPENS-37))|(1<<(JavaParserTO-37))|(1<<(JavaParserUSES-37))|(1<<(JavaParserPROVIDES-37))|(1<<(JavaParserWITH-37))|(1<<(JavaParserTRANSITIVE-37))|(1<<(JavaParserVAR-37))|(1<<(JavaParserYIELD-37))|(1<<(JavaParserRECORD-37))|(1<<(JavaParserSEALED-37))|(1<<(JavaParserPERMITS-37))|(1<<(JavaParserDECIMAL_LITERAL-37))|(1<<(JavaParserHEX_LITERAL-37)))) != 0) || (((_la-69)&-(0x1f+1)) == 0 && ((1<<uint((_la-69)))&((1<<(JavaParserOCT_LITERAL-69))|(1<<(JavaParserBINARY_LITERAL-69))|(1<<(JavaParserFLOAT_LITERAL-69))|(1<<(JavaParserHEX_FLOAT_LITERAL-69))|(1<<(JavaParserBOOL_LITERAL-69))|(1<<(JavaParserCHAR_LITERAL-69))|(1<<(JavaParserSTRING_LITERAL-69))|(1<<(JavaParserTEXT_BLOCK-69))|(1<<(JavaParserNULL_LITERAL-69))|(1<<(JavaParserLPAREN-69))|(1<<(JavaParserLT-69))|(1<<(JavaParserBANG-69))|(1<<(JavaParserTILDE-69))|(1<<(JavaParserINC-69)))) != 0) || (((_la-101)&-(0x1f+1)) == 0 && ((1<<uint((_la-101)))&((1<<(JavaParserDEC-101))|(1<<(JavaParserADD-101))|(1<<(JavaParserSUB-101))|(1<<(JavaParserAT-101))|(1<<(JavaParserIDENTIFIER-101)))) != 0) {
			{
				p.SetState(1319)
				p.ExpressionList()
			}

		}
		{
			p.SetState(1322)
			p.Match(JavaParserRPAREN)
		}

	case JavaParserTHIS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1324)
			p.Match(JavaParserTHIS)
		}
		{
			p.SetState(1325)
			p.Match(JavaParserLPAREN)
		}
		p.SetState(1327)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<JavaParserBOOLEAN)|(1<<JavaParserBYTE)|(1<<JavaParserCHAR)|(1<<JavaParserDOUBLE)|(1<<JavaParserFLOAT)|(1<<JavaParserINT)|(1<<JavaParserLONG)|(1<<JavaParserNEW))) != 0) || (((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(JavaParserSHORT-37))|(1<<(JavaParserSUPER-37))|(1<<(JavaParserSWITCH-37))|(1<<(JavaParserTHIS-37))|(1<<(JavaParserVOID-37))|(1<<(JavaParserMODULE-37))|(1<<(JavaParserOPEN-37))|(1<<(JavaParserREQUIRES-37))|(1<<(JavaParserEXPORTS-37))|(1<<(JavaParserOPENS-37))|(1<<(JavaParserTO-37))|(1<<(JavaParserUSES-37))|(1<<(JavaParserPROVIDES-37))|(1<<(JavaParserWITH-37))|(1<<(JavaParserTRANSITIVE-37))|(1<<(JavaParserVAR-37))|(1<<(JavaParserYIELD-37))|(1<<(JavaParserRECORD-37))|(1<<(JavaParserSEALED-37))|(1<<(JavaParserPERMITS-37))|(1<<(JavaParserDECIMAL_LITERAL-37))|(1<<(JavaParserHEX_LITERAL-37)))) != 0) || (((_la-69)&-(0x1f+1)) == 0 && ((1<<uint((_la-69)))&((1<<(JavaParserOCT_LITERAL-69))|(1<<(JavaParserBINARY_LITERAL-69))|(1<<(JavaParserFLOAT_LITERAL-69))|(1<<(JavaParserHEX_FLOAT_LITERAL-69))|(1<<(JavaParserBOOL_LITERAL-69))|(1<<(JavaParserCHAR_LITERAL-69))|(1<<(JavaParserSTRING_LITERAL-69))|(1<<(JavaParserTEXT_BLOCK-69))|(1<<(JavaParserNULL_LITERAL-69))|(1<<(JavaParserLPAREN-69))|(1<<(JavaParserLT-69))|(1<<(JavaParserBANG-69))|(1<<(JavaParserTILDE-69))|(1<<(JavaParserINC-69)))) != 0) || (((_la-101)&-(0x1f+1)) == 0 && ((1<<uint((_la-101)))&((1<<(JavaParserDEC-101))|(1<<(JavaParserADD-101))|(1<<(JavaParserSUB-101))|(1<<(JavaParserAT-101))|(1<<(JavaParserIDENTIFIER-101)))) != 0) {
			{
				p.SetState(1326)
				p.ExpressionList()
			}

		}
		{
			p.SetState(1329)
			p.Match(JavaParserRPAREN)
		}

	case JavaParserSUPER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1330)
			p.Match(JavaParserSUPER)
		}
		{
			p.SetState(1331)
			p.Match(JavaParserLPAREN)
		}
		p.SetState(1333)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<JavaParserBOOLEAN)|(1<<JavaParserBYTE)|(1<<JavaParserCHAR)|(1<<JavaParserDOUBLE)|(1<<JavaParserFLOAT)|(1<<JavaParserINT)|(1<<JavaParserLONG)|(1<<JavaParserNEW))) != 0) || (((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(JavaParserSHORT-37))|(1<<(JavaParserSUPER-37))|(1<<(JavaParserSWITCH-37))|(1<<(JavaParserTHIS-37))|(1<<(JavaParserVOID-37))|(1<<(JavaParserMODULE-37))|(1<<(JavaParserOPEN-37))|(1<<(JavaParserREQUIRES-37))|(1<<(JavaParserEXPORTS-37))|(1<<(JavaParserOPENS-37))|(1<<(JavaParserTO-37))|(1<<(JavaParserUSES-37))|(1<<(JavaParserPROVIDES-37))|(1<<(JavaParserWITH-37))|(1<<(JavaParserTRANSITIVE-37))|(1<<(JavaParserVAR-37))|(1<<(JavaParserYIELD-37))|(1<<(JavaParserRECORD-37))|(1<<(JavaParserSEALED-37))|(1<<(JavaParserPERMITS-37))|(1<<(JavaParserDECIMAL_LITERAL-37))|(1<<(JavaParserHEX_LITERAL-37)))) != 0) || (((_la-69)&-(0x1f+1)) == 0 && ((1<<uint((_la-69)))&((1<<(JavaParserOCT_LITERAL-69))|(1<<(JavaParserBINARY_LITERAL-69))|(1<<(JavaParserFLOAT_LITERAL-69))|(1<<(JavaParserHEX_FLOAT_LITERAL-69))|(1<<(JavaParserBOOL_LITERAL-69))|(1<<(JavaParserCHAR_LITERAL-69))|(1<<(JavaParserSTRING_LITERAL-69))|(1<<(JavaParserTEXT_BLOCK-69))|(1<<(JavaParserNULL_LITERAL-69))|(1<<(JavaParserLPAREN-69))|(1<<(JavaParserLT-69))|(1<<(JavaParserBANG-69))|(1<<(JavaParserTILDE-69))|(1<<(JavaParserINC-69)))) != 0) || (((_la-101)&-(0x1f+1)) == 0 && ((1<<uint((_la-101)))&((1<<(JavaParserDEC-101))|(1<<(JavaParserADD-101))|(1<<(JavaParserSUB-101))|(1<<(JavaParserAT-101))|(1<<(JavaParserIDENTIFIER-101)))) != 0) {
			{
				p.SetState(1332)
				p.ExpressionList()
			}

		}
		{
			p.SetState(1335)
			p.Match(JavaParserRPAREN)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPrefix returns the prefix token.
	GetPrefix() antlr.Token

	// GetBop returns the bop token.
	GetBop() antlr.Token

	// GetPostfix returns the postfix token.
	GetPostfix() antlr.Token

	// SetPrefix sets the prefix token.
	SetPrefix(antlr.Token)

	// SetBop sets the bop token.
	SetBop(antlr.Token)

	// SetPostfix sets the postfix token.
	SetPostfix(antlr.Token)

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser  antlr.Parser
	prefix  antlr.Token
	bop     antlr.Token
	postfix antlr.Token
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) GetPrefix() antlr.Token { return s.prefix }

func (s *ExpressionContext) GetBop() antlr.Token { return s.bop }

func (s *ExpressionContext) GetPostfix() antlr.Token { return s.postfix }

func (s *ExpressionContext) SetPrefix(v antlr.Token) { s.prefix = v }

func (s *ExpressionContext) SetBop(v antlr.Token) { s.bop = v }

func (s *ExpressionContext) SetPostfix(v antlr.Token) { s.postfix = v }

func (s *ExpressionContext) Primary() IPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}

func (s *ExpressionContext) MethodCall() IMethodCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodCallContext)
}

func (s *ExpressionContext) NEW() antlr.TerminalNode {
	return s.GetToken(JavaParserNEW, 0)
}

func (s *ExpressionContext) Creator() ICreatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreatorContext)
}

func (s *ExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserLPAREN, 0)
}

func (s *ExpressionContext) AllTypeType() []ITypeTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeTypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeTypeContext); ok {
			tst[i] = t.(ITypeTypeContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionContext) TypeType(i int) ITypeTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *ExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserRPAREN, 0)
}

func (s *ExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ExpressionContext) AllBITAND() []antlr.TerminalNode {
	return s.GetTokens(JavaParserBITAND)
}

func (s *ExpressionContext) BITAND(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserBITAND, i)
}

func (s *ExpressionContext) ADD() antlr.TerminalNode {
	return s.GetToken(JavaParserADD, 0)
}

func (s *ExpressionContext) SUB() antlr.TerminalNode {
	return s.GetToken(JavaParserSUB, 0)
}

func (s *ExpressionContext) INC() antlr.TerminalNode {
	return s.GetToken(JavaParserINC, 0)
}

func (s *ExpressionContext) DEC() antlr.TerminalNode {
	return s.GetToken(JavaParserDEC, 0)
}

func (s *ExpressionContext) TILDE() antlr.TerminalNode {
	return s.GetToken(JavaParserTILDE, 0)
}

func (s *ExpressionContext) BANG() antlr.TerminalNode {
	return s.GetToken(JavaParserBANG, 0)
}

func (s *ExpressionContext) LambdaExpression() ILambdaExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaExpressionContext)
}

func (s *ExpressionContext) SwitchExpression() ISwitchExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchExpressionContext)
}

func (s *ExpressionContext) COLONCOLON() antlr.TerminalNode {
	return s.GetToken(JavaParserCOLONCOLON, 0)
}

func (s *ExpressionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExpressionContext) TypeArguments() ITypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *ExpressionContext) ClassType() IClassTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassTypeContext)
}

func (s *ExpressionContext) MUL() antlr.TerminalNode {
	return s.GetToken(JavaParserMUL, 0)
}

func (s *ExpressionContext) DIV() antlr.TerminalNode {
	return s.GetToken(JavaParserDIV, 0)
}

func (s *ExpressionContext) MOD() antlr.TerminalNode {
	return s.GetToken(JavaParserMOD, 0)
}

func (s *ExpressionContext) AllLT() []antlr.TerminalNode {
	return s.GetTokens(JavaParserLT)
}

func (s *ExpressionContext) LT(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserLT, i)
}

func (s *ExpressionContext) AllGT() []antlr.TerminalNode {
	return s.GetTokens(JavaParserGT)
}

func (s *ExpressionContext) GT(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserGT, i)
}

func (s *ExpressionContext) LE() antlr.TerminalNode {
	return s.GetToken(JavaParserLE, 0)
}

func (s *ExpressionContext) GE() antlr.TerminalNode {
	return s.GetToken(JavaParserGE, 0)
}

func (s *ExpressionContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(JavaParserEQUAL, 0)
}

func (s *ExpressionContext) NOTEQUAL() antlr.TerminalNode {
	return s.GetToken(JavaParserNOTEQUAL, 0)
}

func (s *ExpressionContext) CARET() antlr.TerminalNode {
	return s.GetToken(JavaParserCARET, 0)
}

func (s *ExpressionContext) BITOR() antlr.TerminalNode {
	return s.GetToken(JavaParserBITOR, 0)
}

func (s *ExpressionContext) AND() antlr.TerminalNode {
	return s.GetToken(JavaParserAND, 0)
}

func (s *ExpressionContext) OR() antlr.TerminalNode {
	return s.GetToken(JavaParserOR, 0)
}

func (s *ExpressionContext) COLON() antlr.TerminalNode {
	return s.GetToken(JavaParserCOLON, 0)
}

func (s *ExpressionContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(JavaParserQUESTION, 0)
}

func (s *ExpressionContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(JavaParserASSIGN, 0)
}

func (s *ExpressionContext) ADD_ASSIGN() antlr.TerminalNode {
	return s.GetToken(JavaParserADD_ASSIGN, 0)
}

func (s *ExpressionContext) SUB_ASSIGN() antlr.TerminalNode {
	return s.GetToken(JavaParserSUB_ASSIGN, 0)
}

func (s *ExpressionContext) MUL_ASSIGN() antlr.TerminalNode {
	return s.GetToken(JavaParserMUL_ASSIGN, 0)
}

func (s *ExpressionContext) DIV_ASSIGN() antlr.TerminalNode {
	return s.GetToken(JavaParserDIV_ASSIGN, 0)
}

func (s *ExpressionContext) AND_ASSIGN() antlr.TerminalNode {
	return s.GetToken(JavaParserAND_ASSIGN, 0)
}

func (s *ExpressionContext) OR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(JavaParserOR_ASSIGN, 0)
}

func (s *ExpressionContext) XOR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(JavaParserXOR_ASSIGN, 0)
}

func (s *ExpressionContext) RSHIFT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(JavaParserRSHIFT_ASSIGN, 0)
}

func (s *ExpressionContext) URSHIFT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(JavaParserURSHIFT_ASSIGN, 0)
}

func (s *ExpressionContext) LSHIFT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(JavaParserLSHIFT_ASSIGN, 0)
}

func (s *ExpressionContext) MOD_ASSIGN() antlr.TerminalNode {
	return s.GetToken(JavaParserMOD_ASSIGN, 0)
}

func (s *ExpressionContext) DOT() antlr.TerminalNode {
	return s.GetToken(JavaParserDOT, 0)
}

func (s *ExpressionContext) THIS() antlr.TerminalNode {
	return s.GetToken(JavaParserTHIS, 0)
}

func (s *ExpressionContext) InnerCreator() IInnerCreatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInnerCreatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInnerCreatorContext)
}

func (s *ExpressionContext) SUPER() antlr.TerminalNode {
	return s.GetToken(JavaParserSUPER, 0)
}

func (s *ExpressionContext) SuperSuffix() ISuperSuffixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISuperSuffixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISuperSuffixContext)
}

func (s *ExpressionContext) ExplicitGenericInvocation() IExplicitGenericInvocationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplicitGenericInvocationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplicitGenericInvocationContext)
}

func (s *ExpressionContext) NonWildcardTypeArguments() INonWildcardTypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonWildcardTypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonWildcardTypeArgumentsContext)
}

func (s *ExpressionContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(JavaParserLBRACK, 0)
}

func (s *ExpressionContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(JavaParserRBRACK, 0)
}

func (s *ExpressionContext) INSTANCEOF() antlr.TerminalNode {
	return s.GetToken(JavaParserINSTANCEOF, 0)
}

func (s *ExpressionContext) Pattern() IPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *JavaParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *JavaParser) expression(_p int) (localctx IExpressionContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 200
	p.EnterRecursionRule(localctx, 200, JavaParserRULE_expression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1383)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 165, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1339)
			p.Primary()
		}

	case 2:
		{
			p.SetState(1340)
			p.MethodCall()
		}

	case 3:
		{
			p.SetState(1341)
			p.Match(JavaParserNEW)
		}
		{
			p.SetState(1342)
			p.Creator()
		}

	case 4:
		{
			p.SetState(1343)
			p.Match(JavaParserLPAREN)
		}
		p.SetState(1347)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 160, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1344)
					p.Annotation()
				}

			}
			p.SetState(1349)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 160, p.GetParserRuleContext())
		}
		{
			p.SetState(1350)
			p.TypeType()
		}
		p.SetState(1355)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == JavaParserBITAND {
			{
				p.SetState(1351)
				p.Match(JavaParserBITAND)
			}
			{
				p.SetState(1352)
				p.TypeType()
			}

			p.SetState(1357)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1358)
			p.Match(JavaParserRPAREN)
		}
		{
			p.SetState(1359)
			p.expression(22)
		}

	case 5:
		{
			p.SetState(1361)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ExpressionContext).prefix = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(JavaParserINC-100))|(1<<(JavaParserDEC-100))|(1<<(JavaParserADD-100))|(1<<(JavaParserSUB-100)))) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ExpressionContext).prefix = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1362)
			p.expression(20)
		}

	case 6:
		{
			p.SetState(1363)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ExpressionContext).prefix = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == JavaParserBANG || _la == JavaParserTILDE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ExpressionContext).prefix = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1364)
			p.expression(19)
		}

	case 7:
		{
			p.SetState(1365)
			p.LambdaExpression()
		}

	case 8:
		{
			p.SetState(1366)
			p.SwitchExpression()
		}

	case 9:
		{
			p.SetState(1367)
			p.TypeType()
		}
		{
			p.SetState(1368)
			p.Match(JavaParserCOLONCOLON)
		}
		p.SetState(1374)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case JavaParserMODULE, JavaParserOPEN, JavaParserREQUIRES, JavaParserEXPORTS, JavaParserOPENS, JavaParserTO, JavaParserUSES, JavaParserPROVIDES, JavaParserWITH, JavaParserTRANSITIVE, JavaParserVAR, JavaParserYIELD, JavaParserRECORD, JavaParserSEALED, JavaParserPERMITS, JavaParserLT, JavaParserIDENTIFIER:
			p.SetState(1370)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == JavaParserLT {
				{
					p.SetState(1369)
					p.TypeArguments()
				}

			}
			{
				p.SetState(1372)
				p.Identifier()
			}

		case JavaParserNEW:
			{
				p.SetState(1373)
				p.Match(JavaParserNEW)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 10:
		{
			p.SetState(1376)
			p.ClassType()
		}
		{
			p.SetState(1377)
			p.Match(JavaParserCOLONCOLON)
		}
		p.SetState(1379)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JavaParserLT {
			{
				p.SetState(1378)
				p.TypeArguments()
			}

		}
		{
			p.SetState(1381)
			p.Match(JavaParserNEW)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1468)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 172, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1466)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 171, p.GetParserRuleContext()) {
			case 1:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, JavaParserRULE_expression)
				p.SetState(1385)

				if !(p.Precpred(p.GetParserRuleContext(), 18)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 18)", ""))
				}
				{
					p.SetState(1386)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExpressionContext).bop = _lt

					_la = p.GetTokenStream().LA(1)

					if !(((_la-104)&-(0x1f+1)) == 0 && ((1<<uint((_la-104)))&((1<<(JavaParserMUL-104))|(1<<(JavaParserDIV-104))|(1<<(JavaParserMOD-104)))) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExpressionContext).bop = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1387)
					p.expression(19)
				}

			case 2:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, JavaParserRULE_expression)
				p.SetState(1388)

				if !(p.Precpred(p.GetParserRuleContext(), 17)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 17)", ""))
				}
				{
					p.SetState(1389)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExpressionContext).bop = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == JavaParserADD || _la == JavaParserSUB) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExpressionContext).bop = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1390)
					p.expression(18)
				}

			case 3:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, JavaParserRULE_expression)
				p.SetState(1391)

				if !(p.Precpred(p.GetParserRuleContext(), 16)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 16)", ""))
				}
				p.SetState(1399)
				p.GetErrorHandler().Sync(p)
				switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 166, p.GetParserRuleContext()) {
				case 1:
					{
						p.SetState(1392)
						p.Match(JavaParserLT)
					}
					{
						p.SetState(1393)
						p.Match(JavaParserLT)
					}

				case 2:
					{
						p.SetState(1394)
						p.Match(JavaParserGT)
					}
					{
						p.SetState(1395)
						p.Match(JavaParserGT)
					}
					{
						p.SetState(1396)
						p.Match(JavaParserGT)
					}

				case 3:
					{
						p.SetState(1397)
						p.Match(JavaParserGT)
					}
					{
						p.SetState(1398)
						p.Match(JavaParserGT)
					}

				}
				{
					p.SetState(1401)
					p.expression(17)
				}

			case 4:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, JavaParserRULE_expression)
				p.SetState(1402)

				if !(p.Precpred(p.GetParserRuleContext(), 15)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 15)", ""))
				}
				{
					p.SetState(1403)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExpressionContext).bop = _lt

					_la = p.GetTokenStream().LA(1)

					if !(((_la-88)&-(0x1f+1)) == 0 && ((1<<uint((_la-88)))&((1<<(JavaParserGT-88))|(1<<(JavaParserLT-88))|(1<<(JavaParserLE-88))|(1<<(JavaParserGE-88)))) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExpressionContext).bop = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1404)
					p.expression(16)
				}

			case 5:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, JavaParserRULE_expression)
				p.SetState(1405)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
				}
				{
					p.SetState(1406)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExpressionContext).bop = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == JavaParserEQUAL || _la == JavaParserNOTEQUAL) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExpressionContext).bop = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1407)
					p.expression(14)
				}

			case 6:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, JavaParserRULE_expression)
				p.SetState(1408)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
				}
				{
					p.SetState(1409)

					var _m = p.Match(JavaParserBITAND)

					localctx.(*ExpressionContext).bop = _m
				}
				{
					p.SetState(1410)
					p.expression(13)
				}

			case 7:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, JavaParserRULE_expression)
				p.SetState(1411)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
				}
				{
					p.SetState(1412)

					var _m = p.Match(JavaParserCARET)

					localctx.(*ExpressionContext).bop = _m
				}
				{
					p.SetState(1413)
					p.expression(12)
				}

			case 8:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, JavaParserRULE_expression)
				p.SetState(1414)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
				}
				{
					p.SetState(1415)

					var _m = p.Match(JavaParserBITOR)

					localctx.(*ExpressionContext).bop = _m
				}
				{
					p.SetState(1416)
					p.expression(11)
				}

			case 9:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, JavaParserRULE_expression)
				p.SetState(1417)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
				}
				{
					p.SetState(1418)

					var _m = p.Match(JavaParserAND)

					localctx.(*ExpressionContext).bop = _m
				}
				{
					p.SetState(1419)
					p.expression(10)
				}

			case 10:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, JavaParserRULE_expression)
				p.SetState(1420)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
				}
				{
					p.SetState(1421)

					var _m = p.Match(JavaParserOR)

					localctx.(*ExpressionContext).bop = _m
				}
				{
					p.SetState(1422)
					p.expression(9)
				}

			case 11:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, JavaParserRULE_expression)
				p.SetState(1423)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
				}
				{
					p.SetState(1424)

					var _m = p.Match(JavaParserQUESTION)

					localctx.(*ExpressionContext).bop = _m
				}
				{
					p.SetState(1425)
					p.expression(0)
				}
				{
					p.SetState(1426)
					p.Match(JavaParserCOLON)
				}
				{
					p.SetState(1427)
					p.expression(7)
				}

			case 12:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, JavaParserRULE_expression)
				p.SetState(1429)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
				}
				{
					p.SetState(1430)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExpressionContext).bop = _lt

					_la = p.GetTokenStream().LA(1)

					if !((((_la-87)&-(0x1f+1)) == 0 && ((1<<uint((_la-87)))&((1<<(JavaParserASSIGN-87))|(1<<(JavaParserADD_ASSIGN-87))|(1<<(JavaParserSUB_ASSIGN-87))|(1<<(JavaParserMUL_ASSIGN-87))|(1<<(JavaParserDIV_ASSIGN-87))|(1<<(JavaParserAND_ASSIGN-87))|(1<<(JavaParserOR_ASSIGN-87))|(1<<(JavaParserXOR_ASSIGN-87))|(1<<(JavaParserMOD_ASSIGN-87))|(1<<(JavaParserLSHIFT_ASSIGN-87)))) != 0) || _la == JavaParserRSHIFT_ASSIGN || _la == JavaParserURSHIFT_ASSIGN) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExpressionContext).bop = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1431)
					p.expression(6)
				}

			case 13:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, JavaParserRULE_expression)
				p.SetState(1432)

				if !(p.Precpred(p.GetParserRuleContext(), 26)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 26)", ""))
				}
				{
					p.SetState(1433)

					var _m = p.Match(JavaParserDOT)

					localctx.(*ExpressionContext).bop = _m
				}
				p.SetState(1445)
				p.GetErrorHandler().Sync(p)
				switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 168, p.GetParserRuleContext()) {
				case 1:
					{
						p.SetState(1434)
						p.Identifier()
					}

				case 2:
					{
						p.SetState(1435)
						p.MethodCall()
					}

				case 3:
					{
						p.SetState(1436)
						p.Match(JavaParserTHIS)
					}

				case 4:
					{
						p.SetState(1437)
						p.Match(JavaParserNEW)
					}
					p.SetState(1439)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)

					if _la == JavaParserLT {
						{
							p.SetState(1438)
							p.NonWildcardTypeArguments()
						}

					}
					{
						p.SetState(1441)
						p.InnerCreator()
					}

				case 5:
					{
						p.SetState(1442)
						p.Match(JavaParserSUPER)
					}
					{
						p.SetState(1443)
						p.SuperSuffix()
					}

				case 6:
					{
						p.SetState(1444)
						p.ExplicitGenericInvocation()
					}

				}

			case 14:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, JavaParserRULE_expression)
				p.SetState(1447)

				if !(p.Precpred(p.GetParserRuleContext(), 25)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 25)", ""))
				}
				{
					p.SetState(1448)
					p.Match(JavaParserLBRACK)
				}
				{
					p.SetState(1449)
					p.expression(0)
				}
				{
					p.SetState(1450)
					p.Match(JavaParserRBRACK)
				}

			case 15:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, JavaParserRULE_expression)
				p.SetState(1452)

				if !(p.Precpred(p.GetParserRuleContext(), 21)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 21)", ""))
				}
				{
					p.SetState(1453)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExpressionContext).postfix = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == JavaParserINC || _la == JavaParserDEC) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExpressionContext).postfix = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			case 16:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, JavaParserRULE_expression)
				p.SetState(1454)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
				}
				{
					p.SetState(1455)

					var _m = p.Match(JavaParserINSTANCEOF)

					localctx.(*ExpressionContext).bop = _m
				}
				p.SetState(1458)
				p.GetErrorHandler().Sync(p)
				switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 169, p.GetParserRuleContext()) {
				case 1:
					{
						p.SetState(1456)
						p.TypeType()
					}

				case 2:
					{
						p.SetState(1457)
						p.Pattern()
					}

				}

			case 17:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, JavaParserRULE_expression)
				p.SetState(1460)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(1461)
					p.Match(JavaParserCOLONCOLON)
				}
				p.SetState(1463)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == JavaParserLT {
					{
						p.SetState(1462)
						p.TypeArguments()
					}

				}
				{
					p.SetState(1465)
					p.Identifier()
				}

			}

		}
		p.SetState(1470)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 172, p.GetParserRuleContext())
	}

	return localctx
}

// IPatternContext is an interface to support dynamic dispatch.
type IPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPatternContext differentiates from other interfaces.
	IsPatternContext()
}

type PatternContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatternContext() *PatternContext {
	var p = new(PatternContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_pattern
	return p
}

func (*PatternContext) IsPatternContext() {}

func NewPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternContext {
	var p = new(PatternContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_pattern

	return p
}

func (s *PatternContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternContext) TypeType() ITypeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *PatternContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PatternContext) AllVariableModifier() []IVariableModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableModifierContext); ok {
			len++
		}
	}

	tst := make([]IVariableModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableModifierContext); ok {
			tst[i] = t.(IVariableModifierContext)
			i++
		}
	}

	return tst
}

func (s *PatternContext) VariableModifier(i int) IVariableModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableModifierContext)
}

func (s *PatternContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *PatternContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *PatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterPattern(s)
	}
}

func (s *PatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitPattern(s)
	}
}

func (p *JavaParser) Pattern() (localctx IPatternContext) {
	this := p
	_ = this

	localctx = NewPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, JavaParserRULE_pattern)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1474)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 173, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1471)
				p.VariableModifier()
			}

		}
		p.SetState(1476)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 173, p.GetParserRuleContext())
	}
	{
		p.SetState(1477)
		p.TypeType()
	}
	p.SetState(1481)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 174, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1478)
				p.Annotation()
			}

		}
		p.SetState(1483)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 174, p.GetParserRuleContext())
	}
	{
		p.SetState(1484)
		p.Identifier()
	}

	return localctx
}

// ILambdaExpressionContext is an interface to support dynamic dispatch.
type ILambdaExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLambdaExpressionContext differentiates from other interfaces.
	IsLambdaExpressionContext()
}

type LambdaExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaExpressionContext() *LambdaExpressionContext {
	var p = new(LambdaExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_lambdaExpression
	return p
}

func (*LambdaExpressionContext) IsLambdaExpressionContext() {}

func NewLambdaExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaExpressionContext {
	var p = new(LambdaExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_lambdaExpression

	return p
}

func (s *LambdaExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaExpressionContext) LambdaParameters() ILambdaParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaParametersContext)
}

func (s *LambdaExpressionContext) ARROW() antlr.TerminalNode {
	return s.GetToken(JavaParserARROW, 0)
}

func (s *LambdaExpressionContext) LambdaBody() ILambdaBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaBodyContext)
}

func (s *LambdaExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterLambdaExpression(s)
	}
}

func (s *LambdaExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitLambdaExpression(s)
	}
}

func (p *JavaParser) LambdaExpression() (localctx ILambdaExpressionContext) {
	this := p
	_ = this

	localctx = NewLambdaExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, JavaParserRULE_lambdaExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1486)
		p.LambdaParameters()
	}
	{
		p.SetState(1487)
		p.Match(JavaParserARROW)
	}
	{
		p.SetState(1488)
		p.LambdaBody()
	}

	return localctx
}

// ILambdaParametersContext is an interface to support dynamic dispatch.
type ILambdaParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLambdaParametersContext differentiates from other interfaces.
	IsLambdaParametersContext()
}

type LambdaParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaParametersContext() *LambdaParametersContext {
	var p = new(LambdaParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_lambdaParameters
	return p
}

func (*LambdaParametersContext) IsLambdaParametersContext() {}

func NewLambdaParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaParametersContext {
	var p = new(LambdaParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_lambdaParameters

	return p
}

func (s *LambdaParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaParametersContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *LambdaParametersContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LambdaParametersContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserLPAREN, 0)
}

func (s *LambdaParametersContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserRPAREN, 0)
}

func (s *LambdaParametersContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *LambdaParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(JavaParserCOMMA)
}

func (s *LambdaParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserCOMMA, i)
}

func (s *LambdaParametersContext) LambdaLVTIList() ILambdaLVTIListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaLVTIListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaLVTIListContext)
}

func (s *LambdaParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterLambdaParameters(s)
	}
}

func (s *LambdaParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitLambdaParameters(s)
	}
}

func (p *JavaParser) LambdaParameters() (localctx ILambdaParametersContext) {
	this := p
	_ = this

	localctx = NewLambdaParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, JavaParserRULE_lambdaParameters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1512)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 178, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1490)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1491)
			p.Match(JavaParserLPAREN)
		}
		p.SetState(1493)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<JavaParserBOOLEAN)|(1<<JavaParserBYTE)|(1<<JavaParserCHAR)|(1<<JavaParserDOUBLE)|(1<<JavaParserFINAL)|(1<<JavaParserFLOAT)|(1<<JavaParserINT)|(1<<JavaParserLONG))) != 0) || (((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(JavaParserSHORT-37))|(1<<(JavaParserMODULE-37))|(1<<(JavaParserOPEN-37))|(1<<(JavaParserREQUIRES-37))|(1<<(JavaParserEXPORTS-37))|(1<<(JavaParserOPENS-37))|(1<<(JavaParserTO-37))|(1<<(JavaParserUSES-37))|(1<<(JavaParserPROVIDES-37))|(1<<(JavaParserWITH-37))|(1<<(JavaParserTRANSITIVE-37))|(1<<(JavaParserVAR-37))|(1<<(JavaParserYIELD-37))|(1<<(JavaParserRECORD-37))|(1<<(JavaParserSEALED-37))|(1<<(JavaParserPERMITS-37)))) != 0) || _la == JavaParserAT || _la == JavaParserIDENTIFIER {
			{
				p.SetState(1492)
				p.FormalParameterList()
			}

		}
		{
			p.SetState(1495)
			p.Match(JavaParserRPAREN)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1496)
			p.Match(JavaParserLPAREN)
		}
		{
			p.SetState(1497)
			p.Identifier()
		}
		p.SetState(1502)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == JavaParserCOMMA {
			{
				p.SetState(1498)
				p.Match(JavaParserCOMMA)
			}
			{
				p.SetState(1499)
				p.Identifier()
			}

			p.SetState(1504)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1505)
			p.Match(JavaParserRPAREN)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1507)
			p.Match(JavaParserLPAREN)
		}
		p.SetState(1509)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JavaParserFINAL || (((_la-51)&-(0x1f+1)) == 0 && ((1<<uint((_la-51)))&((1<<(JavaParserMODULE-51))|(1<<(JavaParserOPEN-51))|(1<<(JavaParserREQUIRES-51))|(1<<(JavaParserEXPORTS-51))|(1<<(JavaParserOPENS-51))|(1<<(JavaParserTO-51))|(1<<(JavaParserUSES-51))|(1<<(JavaParserPROVIDES-51))|(1<<(JavaParserWITH-51))|(1<<(JavaParserTRANSITIVE-51))|(1<<(JavaParserVAR-51))|(1<<(JavaParserYIELD-51))|(1<<(JavaParserRECORD-51))|(1<<(JavaParserSEALED-51))|(1<<(JavaParserPERMITS-51)))) != 0) || _la == JavaParserAT || _la == JavaParserIDENTIFIER {
			{
				p.SetState(1508)
				p.LambdaLVTIList()
			}

		}
		{
			p.SetState(1511)
			p.Match(JavaParserRPAREN)
		}

	}

	return localctx
}

// ILambdaBodyContext is an interface to support dynamic dispatch.
type ILambdaBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLambdaBodyContext differentiates from other interfaces.
	IsLambdaBodyContext()
}

type LambdaBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaBodyContext() *LambdaBodyContext {
	var p = new(LambdaBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_lambdaBody
	return p
}

func (*LambdaBodyContext) IsLambdaBodyContext() {}

func NewLambdaBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaBodyContext {
	var p = new(LambdaBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_lambdaBody

	return p
}

func (s *LambdaBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaBodyContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LambdaBodyContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *LambdaBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterLambdaBody(s)
	}
}

func (s *LambdaBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitLambdaBody(s)
	}
}

func (p *JavaParser) LambdaBody() (localctx ILambdaBodyContext) {
	this := p
	_ = this

	localctx = NewLambdaBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, JavaParserRULE_lambdaBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1516)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JavaParserBOOLEAN, JavaParserBYTE, JavaParserCHAR, JavaParserDOUBLE, JavaParserFLOAT, JavaParserINT, JavaParserLONG, JavaParserNEW, JavaParserSHORT, JavaParserSUPER, JavaParserSWITCH, JavaParserTHIS, JavaParserVOID, JavaParserMODULE, JavaParserOPEN, JavaParserREQUIRES, JavaParserEXPORTS, JavaParserOPENS, JavaParserTO, JavaParserUSES, JavaParserPROVIDES, JavaParserWITH, JavaParserTRANSITIVE, JavaParserVAR, JavaParserYIELD, JavaParserRECORD, JavaParserSEALED, JavaParserPERMITS, JavaParserDECIMAL_LITERAL, JavaParserHEX_LITERAL, JavaParserOCT_LITERAL, JavaParserBINARY_LITERAL, JavaParserFLOAT_LITERAL, JavaParserHEX_FLOAT_LITERAL, JavaParserBOOL_LITERAL, JavaParserCHAR_LITERAL, JavaParserSTRING_LITERAL, JavaParserTEXT_BLOCK, JavaParserNULL_LITERAL, JavaParserLPAREN, JavaParserLT, JavaParserBANG, JavaParserTILDE, JavaParserINC, JavaParserDEC, JavaParserADD, JavaParserSUB, JavaParserAT, JavaParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1514)
			p.expression(0)
		}

	case JavaParserLBRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1515)
			p.Block()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPrimaryContext is an interface to support dynamic dispatch.
type IPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryContext differentiates from other interfaces.
	IsPrimaryContext()
}

type PrimaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryContext() *PrimaryContext {
	var p = new(PrimaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_primary
	return p
}

func (*PrimaryContext) IsPrimaryContext() {}

func NewPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryContext {
	var p = new(PrimaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_primary

	return p
}

func (s *PrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserLPAREN, 0)
}

func (s *PrimaryContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PrimaryContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserRPAREN, 0)
}

func (s *PrimaryContext) THIS() antlr.TerminalNode {
	return s.GetToken(JavaParserTHIS, 0)
}

func (s *PrimaryContext) SUPER() antlr.TerminalNode {
	return s.GetToken(JavaParserSUPER, 0)
}

func (s *PrimaryContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *PrimaryContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PrimaryContext) TypeTypeOrVoid() ITypeTypeOrVoidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeOrVoidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeOrVoidContext)
}

func (s *PrimaryContext) DOT() antlr.TerminalNode {
	return s.GetToken(JavaParserDOT, 0)
}

func (s *PrimaryContext) CLASS() antlr.TerminalNode {
	return s.GetToken(JavaParserCLASS, 0)
}

func (s *PrimaryContext) NonWildcardTypeArguments() INonWildcardTypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonWildcardTypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonWildcardTypeArgumentsContext)
}

func (s *PrimaryContext) ExplicitGenericInvocationSuffix() IExplicitGenericInvocationSuffixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplicitGenericInvocationSuffixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplicitGenericInvocationSuffixContext)
}

func (s *PrimaryContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *PrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterPrimary(s)
	}
}

func (s *PrimaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitPrimary(s)
	}
}

func (p *JavaParser) Primary() (localctx IPrimaryContext) {
	this := p
	_ = this

	localctx = NewPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, JavaParserRULE_primary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1536)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 181, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1518)
			p.Match(JavaParserLPAREN)
		}
		{
			p.SetState(1519)
			p.expression(0)
		}
		{
			p.SetState(1520)
			p.Match(JavaParserRPAREN)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1522)
			p.Match(JavaParserTHIS)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1523)
			p.Match(JavaParserSUPER)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1524)
			p.Literal()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1525)
			p.Identifier()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1526)
			p.TypeTypeOrVoid()
		}
		{
			p.SetState(1527)
			p.Match(JavaParserDOT)
		}
		{
			p.SetState(1528)
			p.Match(JavaParserCLASS)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1530)
			p.NonWildcardTypeArguments()
		}
		p.SetState(1534)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case JavaParserSUPER, JavaParserMODULE, JavaParserOPEN, JavaParserREQUIRES, JavaParserEXPORTS, JavaParserOPENS, JavaParserTO, JavaParserUSES, JavaParserPROVIDES, JavaParserWITH, JavaParserTRANSITIVE, JavaParserVAR, JavaParserYIELD, JavaParserRECORD, JavaParserSEALED, JavaParserPERMITS, JavaParserIDENTIFIER:
			{
				p.SetState(1531)
				p.ExplicitGenericInvocationSuffix()
			}

		case JavaParserTHIS:
			{
				p.SetState(1532)
				p.Match(JavaParserTHIS)
			}
			{
				p.SetState(1533)
				p.Arguments()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	}

	return localctx
}

// ISwitchExpressionContext is an interface to support dynamic dispatch.
type ISwitchExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitchExpressionContext differentiates from other interfaces.
	IsSwitchExpressionContext()
}

type SwitchExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchExpressionContext() *SwitchExpressionContext {
	var p = new(SwitchExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_switchExpression
	return p
}

func (*SwitchExpressionContext) IsSwitchExpressionContext() {}

func NewSwitchExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchExpressionContext {
	var p = new(SwitchExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_switchExpression

	return p
}

func (s *SwitchExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchExpressionContext) SWITCH() antlr.TerminalNode {
	return s.GetToken(JavaParserSWITCH, 0)
}

func (s *SwitchExpressionContext) ParExpression() IParExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParExpressionContext)
}

func (s *SwitchExpressionContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(JavaParserLBRACE, 0)
}

func (s *SwitchExpressionContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(JavaParserRBRACE, 0)
}

func (s *SwitchExpressionContext) AllSwitchLabeledRule() []ISwitchLabeledRuleContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISwitchLabeledRuleContext); ok {
			len++
		}
	}

	tst := make([]ISwitchLabeledRuleContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISwitchLabeledRuleContext); ok {
			tst[i] = t.(ISwitchLabeledRuleContext)
			i++
		}
	}

	return tst
}

func (s *SwitchExpressionContext) SwitchLabeledRule(i int) ISwitchLabeledRuleContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchLabeledRuleContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchLabeledRuleContext)
}

func (s *SwitchExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterSwitchExpression(s)
	}
}

func (s *SwitchExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitSwitchExpression(s)
	}
}

func (p *JavaParser) SwitchExpression() (localctx ISwitchExpressionContext) {
	this := p
	_ = this

	localctx = NewSwitchExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, JavaParserRULE_switchExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1538)
		p.Match(JavaParserSWITCH)
	}
	{
		p.SetState(1539)
		p.ParExpression()
	}
	{
		p.SetState(1540)
		p.Match(JavaParserLBRACE)
	}
	p.SetState(1544)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == JavaParserCASE || _la == JavaParserDEFAULT {
		{
			p.SetState(1541)
			p.SwitchLabeledRule()
		}

		p.SetState(1546)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1547)
		p.Match(JavaParserRBRACE)
	}

	return localctx
}

// ISwitchLabeledRuleContext is an interface to support dynamic dispatch.
type ISwitchLabeledRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitchLabeledRuleContext differentiates from other interfaces.
	IsSwitchLabeledRuleContext()
}

type SwitchLabeledRuleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchLabeledRuleContext() *SwitchLabeledRuleContext {
	var p = new(SwitchLabeledRuleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_switchLabeledRule
	return p
}

func (*SwitchLabeledRuleContext) IsSwitchLabeledRuleContext() {}

func NewSwitchLabeledRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchLabeledRuleContext {
	var p = new(SwitchLabeledRuleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_switchLabeledRule

	return p
}

func (s *SwitchLabeledRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchLabeledRuleContext) CASE() antlr.TerminalNode {
	return s.GetToken(JavaParserCASE, 0)
}

func (s *SwitchLabeledRuleContext) SwitchRuleOutcome() ISwitchRuleOutcomeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchRuleOutcomeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchRuleOutcomeContext)
}

func (s *SwitchLabeledRuleContext) ARROW() antlr.TerminalNode {
	return s.GetToken(JavaParserARROW, 0)
}

func (s *SwitchLabeledRuleContext) COLON() antlr.TerminalNode {
	return s.GetToken(JavaParserCOLON, 0)
}

func (s *SwitchLabeledRuleContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *SwitchLabeledRuleContext) NULL_LITERAL() antlr.TerminalNode {
	return s.GetToken(JavaParserNULL_LITERAL, 0)
}

func (s *SwitchLabeledRuleContext) GuardedPattern() IGuardedPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGuardedPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGuardedPatternContext)
}

func (s *SwitchLabeledRuleContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(JavaParserDEFAULT, 0)
}

func (s *SwitchLabeledRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchLabeledRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchLabeledRuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterSwitchLabeledRule(s)
	}
}

func (s *SwitchLabeledRuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitSwitchLabeledRule(s)
	}
}

func (p *JavaParser) SwitchLabeledRule() (localctx ISwitchLabeledRuleContext) {
	this := p
	_ = this

	localctx = NewSwitchLabeledRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, JavaParserRULE_switchLabeledRule)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1560)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JavaParserCASE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1549)
			p.Match(JavaParserCASE)
		}
		p.SetState(1553)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 183, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1550)
				p.ExpressionList()
			}

		case 2:
			{
				p.SetState(1551)
				p.Match(JavaParserNULL_LITERAL)
			}

		case 3:
			{
				p.SetState(1552)
				p.guardedPattern(0)
			}

		}
		{
			p.SetState(1555)
			_la = p.GetTokenStream().LA(1)

			if !(_la == JavaParserCOLON || _la == JavaParserARROW) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1556)
			p.SwitchRuleOutcome()
		}

	case JavaParserDEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1557)
			p.Match(JavaParserDEFAULT)
		}
		{
			p.SetState(1558)
			_la = p.GetTokenStream().LA(1)

			if !(_la == JavaParserCOLON || _la == JavaParserARROW) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1559)
			p.SwitchRuleOutcome()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IGuardedPatternContext is an interface to support dynamic dispatch.
type IGuardedPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGuardedPatternContext differentiates from other interfaces.
	IsGuardedPatternContext()
}

type GuardedPatternContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGuardedPatternContext() *GuardedPatternContext {
	var p = new(GuardedPatternContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_guardedPattern
	return p
}

func (*GuardedPatternContext) IsGuardedPatternContext() {}

func NewGuardedPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GuardedPatternContext {
	var p = new(GuardedPatternContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_guardedPattern

	return p
}

func (s *GuardedPatternContext) GetParser() antlr.Parser { return s.parser }

func (s *GuardedPatternContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserLPAREN, 0)
}

func (s *GuardedPatternContext) GuardedPattern() IGuardedPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGuardedPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGuardedPatternContext)
}

func (s *GuardedPatternContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserRPAREN, 0)
}

func (s *GuardedPatternContext) TypeType() ITypeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *GuardedPatternContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *GuardedPatternContext) AllVariableModifier() []IVariableModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableModifierContext); ok {
			len++
		}
	}

	tst := make([]IVariableModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableModifierContext); ok {
			tst[i] = t.(IVariableModifierContext)
			i++
		}
	}

	return tst
}

func (s *GuardedPatternContext) VariableModifier(i int) IVariableModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableModifierContext)
}

func (s *GuardedPatternContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *GuardedPatternContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *GuardedPatternContext) AllAND() []antlr.TerminalNode {
	return s.GetTokens(JavaParserAND)
}

func (s *GuardedPatternContext) AND(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserAND, i)
}

func (s *GuardedPatternContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *GuardedPatternContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GuardedPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GuardedPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GuardedPatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterGuardedPattern(s)
	}
}

func (s *GuardedPatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitGuardedPattern(s)
	}
}

func (p *JavaParser) GuardedPattern() (localctx IGuardedPatternContext) {
	return p.guardedPattern(0)
}

func (p *JavaParser) guardedPattern(_p int) (localctx IGuardedPatternContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewGuardedPatternContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IGuardedPatternContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 216
	p.EnterRecursionRule(localctx, 216, JavaParserRULE_guardedPattern, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1588)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JavaParserLPAREN:
		{
			p.SetState(1563)
			p.Match(JavaParserLPAREN)
		}
		{
			p.SetState(1564)
			p.guardedPattern(0)
		}
		{
			p.SetState(1565)
			p.Match(JavaParserRPAREN)
		}

	case JavaParserBOOLEAN, JavaParserBYTE, JavaParserCHAR, JavaParserDOUBLE, JavaParserFINAL, JavaParserFLOAT, JavaParserINT, JavaParserLONG, JavaParserSHORT, JavaParserMODULE, JavaParserOPEN, JavaParserREQUIRES, JavaParserEXPORTS, JavaParserOPENS, JavaParserTO, JavaParserUSES, JavaParserPROVIDES, JavaParserWITH, JavaParserTRANSITIVE, JavaParserVAR, JavaParserYIELD, JavaParserRECORD, JavaParserSEALED, JavaParserPERMITS, JavaParserAT, JavaParserIDENTIFIER:
		p.SetState(1570)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 185, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1567)
					p.VariableModifier()
				}

			}
			p.SetState(1572)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 185, p.GetParserRuleContext())
		}
		{
			p.SetState(1573)
			p.TypeType()
		}
		p.SetState(1577)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 186, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1574)
					p.Annotation()
				}

			}
			p.SetState(1579)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 186, p.GetParserRuleContext())
		}
		{
			p.SetState(1580)
			p.Identifier()
		}
		p.SetState(1585)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 187, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1581)
					p.Match(JavaParserAND)
				}
				{
					p.SetState(1582)
					p.expression(0)
				}

			}
			p.SetState(1587)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 187, p.GetParserRuleContext())
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1595)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 189, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewGuardedPatternContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, JavaParserRULE_guardedPattern)
			p.SetState(1590)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(1591)
				p.Match(JavaParserAND)
			}
			{
				p.SetState(1592)
				p.expression(0)
			}

		}
		p.SetState(1597)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 189, p.GetParserRuleContext())
	}

	return localctx
}

// ISwitchRuleOutcomeContext is an interface to support dynamic dispatch.
type ISwitchRuleOutcomeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitchRuleOutcomeContext differentiates from other interfaces.
	IsSwitchRuleOutcomeContext()
}

type SwitchRuleOutcomeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchRuleOutcomeContext() *SwitchRuleOutcomeContext {
	var p = new(SwitchRuleOutcomeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_switchRuleOutcome
	return p
}

func (*SwitchRuleOutcomeContext) IsSwitchRuleOutcomeContext() {}

func NewSwitchRuleOutcomeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchRuleOutcomeContext {
	var p = new(SwitchRuleOutcomeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_switchRuleOutcome

	return p
}

func (s *SwitchRuleOutcomeContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchRuleOutcomeContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *SwitchRuleOutcomeContext) AllBlockStatement() []IBlockStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBlockStatementContext); ok {
			len++
		}
	}

	tst := make([]IBlockStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBlockStatementContext); ok {
			tst[i] = t.(IBlockStatementContext)
			i++
		}
	}

	return tst
}

func (s *SwitchRuleOutcomeContext) BlockStatement(i int) IBlockStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockStatementContext)
}

func (s *SwitchRuleOutcomeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchRuleOutcomeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchRuleOutcomeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterSwitchRuleOutcome(s)
	}
}

func (s *SwitchRuleOutcomeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitSwitchRuleOutcome(s)
	}
}

func (p *JavaParser) SwitchRuleOutcome() (localctx ISwitchRuleOutcomeContext) {
	this := p
	_ = this

	localctx = NewSwitchRuleOutcomeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, JavaParserRULE_switchRuleOutcome)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1605)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 191, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1598)
			p.Block()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1602)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<JavaParserABSTRACT)|(1<<JavaParserASSERT)|(1<<JavaParserBOOLEAN)|(1<<JavaParserBREAK)|(1<<JavaParserBYTE)|(1<<JavaParserCHAR)|(1<<JavaParserCLASS)|(1<<JavaParserCONTINUE)|(1<<JavaParserDO)|(1<<JavaParserDOUBLE)|(1<<JavaParserFINAL)|(1<<JavaParserFLOAT)|(1<<JavaParserFOR)|(1<<JavaParserIF)|(1<<JavaParserINT)|(1<<JavaParserINTERFACE)|(1<<JavaParserLONG)|(1<<JavaParserNEW))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(JavaParserPRIVATE-33))|(1<<(JavaParserPROTECTED-33))|(1<<(JavaParserPUBLIC-33))|(1<<(JavaParserRETURN-33))|(1<<(JavaParserSHORT-33))|(1<<(JavaParserSTATIC-33))|(1<<(JavaParserSTRICTFP-33))|(1<<(JavaParserSUPER-33))|(1<<(JavaParserSWITCH-33))|(1<<(JavaParserSYNCHRONIZED-33))|(1<<(JavaParserTHIS-33))|(1<<(JavaParserTHROW-33))|(1<<(JavaParserTRY-33))|(1<<(JavaParserVOID-33))|(1<<(JavaParserWHILE-33))|(1<<(JavaParserMODULE-33))|(1<<(JavaParserOPEN-33))|(1<<(JavaParserREQUIRES-33))|(1<<(JavaParserEXPORTS-33))|(1<<(JavaParserOPENS-33))|(1<<(JavaParserTO-33))|(1<<(JavaParserUSES-33))|(1<<(JavaParserPROVIDES-33))|(1<<(JavaParserWITH-33))|(1<<(JavaParserTRANSITIVE-33))|(1<<(JavaParserVAR-33))|(1<<(JavaParserYIELD-33))|(1<<(JavaParserRECORD-33))|(1<<(JavaParserSEALED-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(JavaParserPERMITS-65))|(1<<(JavaParserNON_SEALED-65))|(1<<(JavaParserDECIMAL_LITERAL-65))|(1<<(JavaParserHEX_LITERAL-65))|(1<<(JavaParserOCT_LITERAL-65))|(1<<(JavaParserBINARY_LITERAL-65))|(1<<(JavaParserFLOAT_LITERAL-65))|(1<<(JavaParserHEX_FLOAT_LITERAL-65))|(1<<(JavaParserBOOL_LITERAL-65))|(1<<(JavaParserCHAR_LITERAL-65))|(1<<(JavaParserSTRING_LITERAL-65))|(1<<(JavaParserTEXT_BLOCK-65))|(1<<(JavaParserNULL_LITERAL-65))|(1<<(JavaParserLPAREN-65))|(1<<(JavaParserLBRACE-65))|(1<<(JavaParserSEMI-65))|(1<<(JavaParserLT-65))|(1<<(JavaParserBANG-65))|(1<<(JavaParserTILDE-65)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(JavaParserINC-100))|(1<<(JavaParserDEC-100))|(1<<(JavaParserADD-100))|(1<<(JavaParserSUB-100))|(1<<(JavaParserAT-100))|(1<<(JavaParserIDENTIFIER-100)))) != 0) {
			{
				p.SetState(1599)
				p.BlockStatement()
			}

			p.SetState(1604)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IClassTypeContext is an interface to support dynamic dispatch.
type IClassTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassTypeContext differentiates from other interfaces.
	IsClassTypeContext()
}

type ClassTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassTypeContext() *ClassTypeContext {
	var p = new(ClassTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_classType
	return p
}

func (*ClassTypeContext) IsClassTypeContext() {}

func NewClassTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassTypeContext {
	var p = new(ClassTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_classType

	return p
}

func (s *ClassTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassTypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassTypeContext) ClassOrInterfaceType() IClassOrInterfaceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOrInterfaceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOrInterfaceTypeContext)
}

func (s *ClassTypeContext) DOT() antlr.TerminalNode {
	return s.GetToken(JavaParserDOT, 0)
}

func (s *ClassTypeContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *ClassTypeContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ClassTypeContext) TypeArguments() ITypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *ClassTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterClassType(s)
	}
}

func (s *ClassTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitClassType(s)
	}
}

func (p *JavaParser) ClassType() (localctx IClassTypeContext) {
	this := p
	_ = this

	localctx = NewClassTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, JavaParserRULE_classType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1610)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 192, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1607)
			p.ClassOrInterfaceType()
		}
		{
			p.SetState(1608)
			p.Match(JavaParserDOT)
		}

	}
	p.SetState(1615)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 193, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1612)
				p.Annotation()
			}

		}
		p.SetState(1617)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 193, p.GetParserRuleContext())
	}
	{
		p.SetState(1618)
		p.Identifier()
	}
	p.SetState(1620)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserLT {
		{
			p.SetState(1619)
			p.TypeArguments()
		}

	}

	return localctx
}

// ICreatorContext is an interface to support dynamic dispatch.
type ICreatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreatorContext differentiates from other interfaces.
	IsCreatorContext()
}

type CreatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreatorContext() *CreatorContext {
	var p = new(CreatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_creator
	return p
}

func (*CreatorContext) IsCreatorContext() {}

func NewCreatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreatorContext {
	var p = new(CreatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_creator

	return p
}

func (s *CreatorContext) GetParser() antlr.Parser { return s.parser }

func (s *CreatorContext) NonWildcardTypeArguments() INonWildcardTypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonWildcardTypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonWildcardTypeArgumentsContext)
}

func (s *CreatorContext) CreatedName() ICreatedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreatedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreatedNameContext)
}

func (s *CreatorContext) ClassCreatorRest() IClassCreatorRestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassCreatorRestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassCreatorRestContext)
}

func (s *CreatorContext) ArrayCreatorRest() IArrayCreatorRestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayCreatorRestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayCreatorRestContext)
}

func (s *CreatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterCreator(s)
	}
}

func (s *CreatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitCreator(s)
	}
}

func (p *JavaParser) Creator() (localctx ICreatorContext) {
	this := p
	_ = this

	localctx = NewCreatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, JavaParserRULE_creator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1631)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JavaParserLT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1622)
			p.NonWildcardTypeArguments()
		}
		{
			p.SetState(1623)
			p.CreatedName()
		}
		{
			p.SetState(1624)
			p.ClassCreatorRest()
		}

	case JavaParserBOOLEAN, JavaParserBYTE, JavaParserCHAR, JavaParserDOUBLE, JavaParserFLOAT, JavaParserINT, JavaParserLONG, JavaParserSHORT, JavaParserMODULE, JavaParserOPEN, JavaParserREQUIRES, JavaParserEXPORTS, JavaParserOPENS, JavaParserTO, JavaParserUSES, JavaParserPROVIDES, JavaParserWITH, JavaParserTRANSITIVE, JavaParserVAR, JavaParserYIELD, JavaParserRECORD, JavaParserSEALED, JavaParserPERMITS, JavaParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1626)
			p.CreatedName()
		}
		p.SetState(1629)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case JavaParserLBRACK:
			{
				p.SetState(1627)
				p.ArrayCreatorRest()
			}

		case JavaParserLPAREN:
			{
				p.SetState(1628)
				p.ClassCreatorRest()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICreatedNameContext is an interface to support dynamic dispatch.
type ICreatedNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreatedNameContext differentiates from other interfaces.
	IsCreatedNameContext()
}

type CreatedNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreatedNameContext() *CreatedNameContext {
	var p = new(CreatedNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_createdName
	return p
}

func (*CreatedNameContext) IsCreatedNameContext() {}

func NewCreatedNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreatedNameContext {
	var p = new(CreatedNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_createdName

	return p
}

func (s *CreatedNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CreatedNameContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *CreatedNameContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreatedNameContext) AllTypeArgumentsOrDiamond() []ITypeArgumentsOrDiamondContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeArgumentsOrDiamondContext); ok {
			len++
		}
	}

	tst := make([]ITypeArgumentsOrDiamondContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeArgumentsOrDiamondContext); ok {
			tst[i] = t.(ITypeArgumentsOrDiamondContext)
			i++
		}
	}

	return tst
}

func (s *CreatedNameContext) TypeArgumentsOrDiamond(i int) ITypeArgumentsOrDiamondContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsOrDiamondContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsOrDiamondContext)
}

func (s *CreatedNameContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(JavaParserDOT)
}

func (s *CreatedNameContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserDOT, i)
}

func (s *CreatedNameContext) PrimitiveType() IPrimitiveTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimitiveTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *CreatedNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreatedNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreatedNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterCreatedName(s)
	}
}

func (s *CreatedNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitCreatedName(s)
	}
}

func (p *JavaParser) CreatedName() (localctx ICreatedNameContext) {
	this := p
	_ = this

	localctx = NewCreatedNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, JavaParserRULE_createdName)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1648)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JavaParserMODULE, JavaParserOPEN, JavaParserREQUIRES, JavaParserEXPORTS, JavaParserOPENS, JavaParserTO, JavaParserUSES, JavaParserPROVIDES, JavaParserWITH, JavaParserTRANSITIVE, JavaParserVAR, JavaParserYIELD, JavaParserRECORD, JavaParserSEALED, JavaParserPERMITS, JavaParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1633)
			p.Identifier()
		}
		p.SetState(1635)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JavaParserLT {
			{
				p.SetState(1634)
				p.TypeArgumentsOrDiamond()
			}

		}
		p.SetState(1644)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == JavaParserDOT {
			{
				p.SetState(1637)
				p.Match(JavaParserDOT)
			}
			{
				p.SetState(1638)
				p.Identifier()
			}
			p.SetState(1640)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == JavaParserLT {
				{
					p.SetState(1639)
					p.TypeArgumentsOrDiamond()
				}

			}

			p.SetState(1646)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case JavaParserBOOLEAN, JavaParserBYTE, JavaParserCHAR, JavaParserDOUBLE, JavaParserFLOAT, JavaParserINT, JavaParserLONG, JavaParserSHORT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1647)
			p.PrimitiveType()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInnerCreatorContext is an interface to support dynamic dispatch.
type IInnerCreatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInnerCreatorContext differentiates from other interfaces.
	IsInnerCreatorContext()
}

type InnerCreatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInnerCreatorContext() *InnerCreatorContext {
	var p = new(InnerCreatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_innerCreator
	return p
}

func (*InnerCreatorContext) IsInnerCreatorContext() {}

func NewInnerCreatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InnerCreatorContext {
	var p = new(InnerCreatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_innerCreator

	return p
}

func (s *InnerCreatorContext) GetParser() antlr.Parser { return s.parser }

func (s *InnerCreatorContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InnerCreatorContext) ClassCreatorRest() IClassCreatorRestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassCreatorRestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassCreatorRestContext)
}

func (s *InnerCreatorContext) NonWildcardTypeArgumentsOrDiamond() INonWildcardTypeArgumentsOrDiamondContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonWildcardTypeArgumentsOrDiamondContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonWildcardTypeArgumentsOrDiamondContext)
}

func (s *InnerCreatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InnerCreatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InnerCreatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterInnerCreator(s)
	}
}

func (s *InnerCreatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitInnerCreator(s)
	}
}

func (p *JavaParser) InnerCreator() (localctx IInnerCreatorContext) {
	this := p
	_ = this

	localctx = NewInnerCreatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, JavaParserRULE_innerCreator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1650)
		p.Identifier()
	}
	p.SetState(1652)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserLT {
		{
			p.SetState(1651)
			p.NonWildcardTypeArgumentsOrDiamond()
		}

	}
	{
		p.SetState(1654)
		p.ClassCreatorRest()
	}

	return localctx
}

// IArrayCreatorRestContext is an interface to support dynamic dispatch.
type IArrayCreatorRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayCreatorRestContext differentiates from other interfaces.
	IsArrayCreatorRestContext()
}

type ArrayCreatorRestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayCreatorRestContext() *ArrayCreatorRestContext {
	var p = new(ArrayCreatorRestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_arrayCreatorRest
	return p
}

func (*ArrayCreatorRestContext) IsArrayCreatorRestContext() {}

func NewArrayCreatorRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayCreatorRestContext {
	var p = new(ArrayCreatorRestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_arrayCreatorRest

	return p
}

func (s *ArrayCreatorRestContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayCreatorRestContext) AllLBRACK() []antlr.TerminalNode {
	return s.GetTokens(JavaParserLBRACK)
}

func (s *ArrayCreatorRestContext) LBRACK(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserLBRACK, i)
}

func (s *ArrayCreatorRestContext) AllRBRACK() []antlr.TerminalNode {
	return s.GetTokens(JavaParserRBRACK)
}

func (s *ArrayCreatorRestContext) RBRACK(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserRBRACK, i)
}

func (s *ArrayCreatorRestContext) ArrayInitializer() IArrayInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayInitializerContext)
}

func (s *ArrayCreatorRestContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArrayCreatorRestContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayCreatorRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayCreatorRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayCreatorRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterArrayCreatorRest(s)
	}
}

func (s *ArrayCreatorRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitArrayCreatorRest(s)
	}
}

func (p *JavaParser) ArrayCreatorRest() (localctx IArrayCreatorRestContext) {
	this := p
	_ = this

	localctx = NewArrayCreatorRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, JavaParserRULE_arrayCreatorRest)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1656)
		p.Match(JavaParserLBRACK)
	}
	p.SetState(1684)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JavaParserRBRACK:
		{
			p.SetState(1657)
			p.Match(JavaParserRBRACK)
		}
		p.SetState(1662)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == JavaParserLBRACK {
			{
				p.SetState(1658)
				p.Match(JavaParserLBRACK)
			}
			{
				p.SetState(1659)
				p.Match(JavaParserRBRACK)
			}

			p.SetState(1664)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1665)
			p.ArrayInitializer()
		}

	case JavaParserBOOLEAN, JavaParserBYTE, JavaParserCHAR, JavaParserDOUBLE, JavaParserFLOAT, JavaParserINT, JavaParserLONG, JavaParserNEW, JavaParserSHORT, JavaParserSUPER, JavaParserSWITCH, JavaParserTHIS, JavaParserVOID, JavaParserMODULE, JavaParserOPEN, JavaParserREQUIRES, JavaParserEXPORTS, JavaParserOPENS, JavaParserTO, JavaParserUSES, JavaParserPROVIDES, JavaParserWITH, JavaParserTRANSITIVE, JavaParserVAR, JavaParserYIELD, JavaParserRECORD, JavaParserSEALED, JavaParserPERMITS, JavaParserDECIMAL_LITERAL, JavaParserHEX_LITERAL, JavaParserOCT_LITERAL, JavaParserBINARY_LITERAL, JavaParserFLOAT_LITERAL, JavaParserHEX_FLOAT_LITERAL, JavaParserBOOL_LITERAL, JavaParserCHAR_LITERAL, JavaParserSTRING_LITERAL, JavaParserTEXT_BLOCK, JavaParserNULL_LITERAL, JavaParserLPAREN, JavaParserLT, JavaParserBANG, JavaParserTILDE, JavaParserINC, JavaParserDEC, JavaParserADD, JavaParserSUB, JavaParserAT, JavaParserIDENTIFIER:
		{
			p.SetState(1666)
			p.expression(0)
		}
		{
			p.SetState(1667)
			p.Match(JavaParserRBRACK)
		}
		p.SetState(1674)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 203, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1668)
					p.Match(JavaParserLBRACK)
				}
				{
					p.SetState(1669)
					p.expression(0)
				}
				{
					p.SetState(1670)
					p.Match(JavaParserRBRACK)
				}

			}
			p.SetState(1676)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 203, p.GetParserRuleContext())
		}
		p.SetState(1681)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 204, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1677)
					p.Match(JavaParserLBRACK)
				}
				{
					p.SetState(1678)
					p.Match(JavaParserRBRACK)
				}

			}
			p.SetState(1683)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 204, p.GetParserRuleContext())
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IClassCreatorRestContext is an interface to support dynamic dispatch.
type IClassCreatorRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassCreatorRestContext differentiates from other interfaces.
	IsClassCreatorRestContext()
}

type ClassCreatorRestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassCreatorRestContext() *ClassCreatorRestContext {
	var p = new(ClassCreatorRestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_classCreatorRest
	return p
}

func (*ClassCreatorRestContext) IsClassCreatorRestContext() {}

func NewClassCreatorRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassCreatorRestContext {
	var p = new(ClassCreatorRestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_classCreatorRest

	return p
}

func (s *ClassCreatorRestContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassCreatorRestContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *ClassCreatorRestContext) ClassBody() IClassBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *ClassCreatorRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassCreatorRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassCreatorRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterClassCreatorRest(s)
	}
}

func (s *ClassCreatorRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitClassCreatorRest(s)
	}
}

func (p *JavaParser) ClassCreatorRest() (localctx IClassCreatorRestContext) {
	this := p
	_ = this

	localctx = NewClassCreatorRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, JavaParserRULE_classCreatorRest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1686)
		p.Arguments()
	}
	p.SetState(1688)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 206, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1687)
			p.ClassBody()
		}

	}

	return localctx
}

// IExplicitGenericInvocationContext is an interface to support dynamic dispatch.
type IExplicitGenericInvocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExplicitGenericInvocationContext differentiates from other interfaces.
	IsExplicitGenericInvocationContext()
}

type ExplicitGenericInvocationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplicitGenericInvocationContext() *ExplicitGenericInvocationContext {
	var p = new(ExplicitGenericInvocationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_explicitGenericInvocation
	return p
}

func (*ExplicitGenericInvocationContext) IsExplicitGenericInvocationContext() {}

func NewExplicitGenericInvocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplicitGenericInvocationContext {
	var p = new(ExplicitGenericInvocationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_explicitGenericInvocation

	return p
}

func (s *ExplicitGenericInvocationContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplicitGenericInvocationContext) NonWildcardTypeArguments() INonWildcardTypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonWildcardTypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonWildcardTypeArgumentsContext)
}

func (s *ExplicitGenericInvocationContext) ExplicitGenericInvocationSuffix() IExplicitGenericInvocationSuffixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplicitGenericInvocationSuffixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplicitGenericInvocationSuffixContext)
}

func (s *ExplicitGenericInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplicitGenericInvocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExplicitGenericInvocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterExplicitGenericInvocation(s)
	}
}

func (s *ExplicitGenericInvocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitExplicitGenericInvocation(s)
	}
}

func (p *JavaParser) ExplicitGenericInvocation() (localctx IExplicitGenericInvocationContext) {
	this := p
	_ = this

	localctx = NewExplicitGenericInvocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, JavaParserRULE_explicitGenericInvocation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1690)
		p.NonWildcardTypeArguments()
	}
	{
		p.SetState(1691)
		p.ExplicitGenericInvocationSuffix()
	}

	return localctx
}

// ITypeArgumentsOrDiamondContext is an interface to support dynamic dispatch.
type ITypeArgumentsOrDiamondContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeArgumentsOrDiamondContext differentiates from other interfaces.
	IsTypeArgumentsOrDiamondContext()
}

type TypeArgumentsOrDiamondContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeArgumentsOrDiamondContext() *TypeArgumentsOrDiamondContext {
	var p = new(TypeArgumentsOrDiamondContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_typeArgumentsOrDiamond
	return p
}

func (*TypeArgumentsOrDiamondContext) IsTypeArgumentsOrDiamondContext() {}

func NewTypeArgumentsOrDiamondContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeArgumentsOrDiamondContext {
	var p = new(TypeArgumentsOrDiamondContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_typeArgumentsOrDiamond

	return p
}

func (s *TypeArgumentsOrDiamondContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeArgumentsOrDiamondContext) LT() antlr.TerminalNode {
	return s.GetToken(JavaParserLT, 0)
}

func (s *TypeArgumentsOrDiamondContext) GT() antlr.TerminalNode {
	return s.GetToken(JavaParserGT, 0)
}

func (s *TypeArgumentsOrDiamondContext) TypeArguments() ITypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *TypeArgumentsOrDiamondContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeArgumentsOrDiamondContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeArgumentsOrDiamondContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterTypeArgumentsOrDiamond(s)
	}
}

func (s *TypeArgumentsOrDiamondContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitTypeArgumentsOrDiamond(s)
	}
}

func (p *JavaParser) TypeArgumentsOrDiamond() (localctx ITypeArgumentsOrDiamondContext) {
	this := p
	_ = this

	localctx = NewTypeArgumentsOrDiamondContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, JavaParserRULE_typeArgumentsOrDiamond)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1696)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 207, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1693)
			p.Match(JavaParserLT)
		}
		{
			p.SetState(1694)
			p.Match(JavaParserGT)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1695)
			p.TypeArguments()
		}

	}

	return localctx
}

// INonWildcardTypeArgumentsOrDiamondContext is an interface to support dynamic dispatch.
type INonWildcardTypeArgumentsOrDiamondContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNonWildcardTypeArgumentsOrDiamondContext differentiates from other interfaces.
	IsNonWildcardTypeArgumentsOrDiamondContext()
}

type NonWildcardTypeArgumentsOrDiamondContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonWildcardTypeArgumentsOrDiamondContext() *NonWildcardTypeArgumentsOrDiamondContext {
	var p = new(NonWildcardTypeArgumentsOrDiamondContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_nonWildcardTypeArgumentsOrDiamond
	return p
}

func (*NonWildcardTypeArgumentsOrDiamondContext) IsNonWildcardTypeArgumentsOrDiamondContext() {}

func NewNonWildcardTypeArgumentsOrDiamondContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonWildcardTypeArgumentsOrDiamondContext {
	var p = new(NonWildcardTypeArgumentsOrDiamondContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_nonWildcardTypeArgumentsOrDiamond

	return p
}

func (s *NonWildcardTypeArgumentsOrDiamondContext) GetParser() antlr.Parser { return s.parser }

func (s *NonWildcardTypeArgumentsOrDiamondContext) LT() antlr.TerminalNode {
	return s.GetToken(JavaParserLT, 0)
}

func (s *NonWildcardTypeArgumentsOrDiamondContext) GT() antlr.TerminalNode {
	return s.GetToken(JavaParserGT, 0)
}

func (s *NonWildcardTypeArgumentsOrDiamondContext) NonWildcardTypeArguments() INonWildcardTypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonWildcardTypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonWildcardTypeArgumentsContext)
}

func (s *NonWildcardTypeArgumentsOrDiamondContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonWildcardTypeArgumentsOrDiamondContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonWildcardTypeArgumentsOrDiamondContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterNonWildcardTypeArgumentsOrDiamond(s)
	}
}

func (s *NonWildcardTypeArgumentsOrDiamondContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitNonWildcardTypeArgumentsOrDiamond(s)
	}
}

func (p *JavaParser) NonWildcardTypeArgumentsOrDiamond() (localctx INonWildcardTypeArgumentsOrDiamondContext) {
	this := p
	_ = this

	localctx = NewNonWildcardTypeArgumentsOrDiamondContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, JavaParserRULE_nonWildcardTypeArgumentsOrDiamond)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1701)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 208, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1698)
			p.Match(JavaParserLT)
		}
		{
			p.SetState(1699)
			p.Match(JavaParserGT)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1700)
			p.NonWildcardTypeArguments()
		}

	}

	return localctx
}

// INonWildcardTypeArgumentsContext is an interface to support dynamic dispatch.
type INonWildcardTypeArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNonWildcardTypeArgumentsContext differentiates from other interfaces.
	IsNonWildcardTypeArgumentsContext()
}

type NonWildcardTypeArgumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonWildcardTypeArgumentsContext() *NonWildcardTypeArgumentsContext {
	var p = new(NonWildcardTypeArgumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_nonWildcardTypeArguments
	return p
}

func (*NonWildcardTypeArgumentsContext) IsNonWildcardTypeArgumentsContext() {}

func NewNonWildcardTypeArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonWildcardTypeArgumentsContext {
	var p = new(NonWildcardTypeArgumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_nonWildcardTypeArguments

	return p
}

func (s *NonWildcardTypeArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *NonWildcardTypeArgumentsContext) LT() antlr.TerminalNode {
	return s.GetToken(JavaParserLT, 0)
}

func (s *NonWildcardTypeArgumentsContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *NonWildcardTypeArgumentsContext) GT() antlr.TerminalNode {
	return s.GetToken(JavaParserGT, 0)
}

func (s *NonWildcardTypeArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonWildcardTypeArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonWildcardTypeArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterNonWildcardTypeArguments(s)
	}
}

func (s *NonWildcardTypeArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitNonWildcardTypeArguments(s)
	}
}

func (p *JavaParser) NonWildcardTypeArguments() (localctx INonWildcardTypeArgumentsContext) {
	this := p
	_ = this

	localctx = NewNonWildcardTypeArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, JavaParserRULE_nonWildcardTypeArguments)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1703)
		p.Match(JavaParserLT)
	}
	{
		p.SetState(1704)
		p.TypeList()
	}
	{
		p.SetState(1705)
		p.Match(JavaParserGT)
	}

	return localctx
}

// ITypeListContext is an interface to support dynamic dispatch.
type ITypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeListContext differentiates from other interfaces.
	IsTypeListContext()
}

type TypeListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeListContext() *TypeListContext {
	var p = new(TypeListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_typeList
	return p
}

func (*TypeListContext) IsTypeListContext() {}

func NewTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeListContext {
	var p = new(TypeListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_typeList

	return p
}

func (s *TypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeListContext) AllTypeType() []ITypeTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeTypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeTypeContext); ok {
			tst[i] = t.(ITypeTypeContext)
			i++
		}
	}

	return tst
}

func (s *TypeListContext) TypeType(i int) ITypeTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *TypeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(JavaParserCOMMA)
}

func (s *TypeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserCOMMA, i)
}

func (s *TypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterTypeList(s)
	}
}

func (s *TypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitTypeList(s)
	}
}

func (p *JavaParser) TypeList() (localctx ITypeListContext) {
	this := p
	_ = this

	localctx = NewTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, JavaParserRULE_typeList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1707)
		p.TypeType()
	}
	p.SetState(1712)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == JavaParserCOMMA {
		{
			p.SetState(1708)
			p.Match(JavaParserCOMMA)
		}
		{
			p.SetState(1709)
			p.TypeType()
		}

		p.SetState(1714)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITypeTypeContext is an interface to support dynamic dispatch.
type ITypeTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeTypeContext differentiates from other interfaces.
	IsTypeTypeContext()
}

type TypeTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeTypeContext() *TypeTypeContext {
	var p = new(TypeTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_typeType
	return p
}

func (*TypeTypeContext) IsTypeTypeContext() {}

func NewTypeTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeTypeContext {
	var p = new(TypeTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_typeType

	return p
}

func (s *TypeTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeTypeContext) ClassOrInterfaceType() IClassOrInterfaceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOrInterfaceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOrInterfaceTypeContext)
}

func (s *TypeTypeContext) PrimitiveType() IPrimitiveTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimitiveTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *TypeTypeContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *TypeTypeContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *TypeTypeContext) AllLBRACK() []antlr.TerminalNode {
	return s.GetTokens(JavaParserLBRACK)
}

func (s *TypeTypeContext) LBRACK(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserLBRACK, i)
}

func (s *TypeTypeContext) AllRBRACK() []antlr.TerminalNode {
	return s.GetTokens(JavaParserRBRACK)
}

func (s *TypeTypeContext) RBRACK(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserRBRACK, i)
}

func (s *TypeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterTypeType(s)
	}
}

func (s *TypeTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitTypeType(s)
	}
}

func (p *JavaParser) TypeType() (localctx ITypeTypeContext) {
	this := p
	_ = this

	localctx = NewTypeTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, JavaParserRULE_typeType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1718)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 210, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1715)
				p.Annotation()
			}

		}
		p.SetState(1720)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 210, p.GetParserRuleContext())
	}
	p.SetState(1723)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JavaParserMODULE, JavaParserOPEN, JavaParserREQUIRES, JavaParserEXPORTS, JavaParserOPENS, JavaParserTO, JavaParserUSES, JavaParserPROVIDES, JavaParserWITH, JavaParserTRANSITIVE, JavaParserVAR, JavaParserYIELD, JavaParserRECORD, JavaParserSEALED, JavaParserPERMITS, JavaParserIDENTIFIER:
		{
			p.SetState(1721)
			p.ClassOrInterfaceType()
		}

	case JavaParserBOOLEAN, JavaParserBYTE, JavaParserCHAR, JavaParserDOUBLE, JavaParserFLOAT, JavaParserINT, JavaParserLONG, JavaParserSHORT:
		{
			p.SetState(1722)
			p.PrimitiveType()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(1735)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 213, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1728)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for (((_la-51)&-(0x1f+1)) == 0 && ((1<<uint((_la-51)))&((1<<(JavaParserMODULE-51))|(1<<(JavaParserOPEN-51))|(1<<(JavaParserREQUIRES-51))|(1<<(JavaParserEXPORTS-51))|(1<<(JavaParserOPENS-51))|(1<<(JavaParserTO-51))|(1<<(JavaParserUSES-51))|(1<<(JavaParserPROVIDES-51))|(1<<(JavaParserWITH-51))|(1<<(JavaParserTRANSITIVE-51))|(1<<(JavaParserVAR-51))|(1<<(JavaParserYIELD-51))|(1<<(JavaParserRECORD-51))|(1<<(JavaParserSEALED-51))|(1<<(JavaParserPERMITS-51)))) != 0) || _la == JavaParserAT || _la == JavaParserIDENTIFIER {
				{
					p.SetState(1725)
					p.Annotation()
				}

				p.SetState(1730)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1731)
				p.Match(JavaParserLBRACK)
			}
			{
				p.SetState(1732)
				p.Match(JavaParserRBRACK)
			}

		}
		p.SetState(1737)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 213, p.GetParserRuleContext())
	}

	return localctx
}

// IPrimitiveTypeContext is an interface to support dynamic dispatch.
type IPrimitiveTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimitiveTypeContext differentiates from other interfaces.
	IsPrimitiveTypeContext()
}

type PrimitiveTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimitiveTypeContext() *PrimitiveTypeContext {
	var p = new(PrimitiveTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_primitiveType
	return p
}

func (*PrimitiveTypeContext) IsPrimitiveTypeContext() {}

func NewPrimitiveTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimitiveTypeContext {
	var p = new(PrimitiveTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_primitiveType

	return p
}

func (s *PrimitiveTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimitiveTypeContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(JavaParserBOOLEAN, 0)
}

func (s *PrimitiveTypeContext) CHAR() antlr.TerminalNode {
	return s.GetToken(JavaParserCHAR, 0)
}

func (s *PrimitiveTypeContext) BYTE() antlr.TerminalNode {
	return s.GetToken(JavaParserBYTE, 0)
}

func (s *PrimitiveTypeContext) SHORT() antlr.TerminalNode {
	return s.GetToken(JavaParserSHORT, 0)
}

func (s *PrimitiveTypeContext) INT() antlr.TerminalNode {
	return s.GetToken(JavaParserINT, 0)
}

func (s *PrimitiveTypeContext) LONG() antlr.TerminalNode {
	return s.GetToken(JavaParserLONG, 0)
}

func (s *PrimitiveTypeContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(JavaParserFLOAT, 0)
}

func (s *PrimitiveTypeContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(JavaParserDOUBLE, 0)
}

func (s *PrimitiveTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimitiveTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimitiveTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterPrimitiveType(s)
	}
}

func (s *PrimitiveTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitPrimitiveType(s)
	}
}

func (p *JavaParser) PrimitiveType() (localctx IPrimitiveTypeContext) {
	this := p
	_ = this

	localctx = NewPrimitiveTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, JavaParserRULE_primitiveType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1738)
		_la = p.GetTokenStream().LA(1)

		if !((((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<JavaParserBOOLEAN)|(1<<JavaParserBYTE)|(1<<JavaParserCHAR)|(1<<JavaParserDOUBLE)|(1<<JavaParserFLOAT)|(1<<JavaParserINT)|(1<<JavaParserLONG))) != 0) || _la == JavaParserSHORT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ITypeArgumentsContext is an interface to support dynamic dispatch.
type ITypeArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeArgumentsContext differentiates from other interfaces.
	IsTypeArgumentsContext()
}

type TypeArgumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeArgumentsContext() *TypeArgumentsContext {
	var p = new(TypeArgumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_typeArguments
	return p
}

func (*TypeArgumentsContext) IsTypeArgumentsContext() {}

func NewTypeArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeArgumentsContext {
	var p = new(TypeArgumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_typeArguments

	return p
}

func (s *TypeArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeArgumentsContext) LT() antlr.TerminalNode {
	return s.GetToken(JavaParserLT, 0)
}

func (s *TypeArgumentsContext) AllTypeArgument() []ITypeArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeArgumentContext); ok {
			len++
		}
	}

	tst := make([]ITypeArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeArgumentContext); ok {
			tst[i] = t.(ITypeArgumentContext)
			i++
		}
	}

	return tst
}

func (s *TypeArgumentsContext) TypeArgument(i int) ITypeArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentContext)
}

func (s *TypeArgumentsContext) GT() antlr.TerminalNode {
	return s.GetToken(JavaParserGT, 0)
}

func (s *TypeArgumentsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(JavaParserCOMMA)
}

func (s *TypeArgumentsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserCOMMA, i)
}

func (s *TypeArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterTypeArguments(s)
	}
}

func (s *TypeArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitTypeArguments(s)
	}
}

func (p *JavaParser) TypeArguments() (localctx ITypeArgumentsContext) {
	this := p
	_ = this

	localctx = NewTypeArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, JavaParserRULE_typeArguments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1740)
		p.Match(JavaParserLT)
	}
	{
		p.SetState(1741)
		p.TypeArgument()
	}
	p.SetState(1746)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == JavaParserCOMMA {
		{
			p.SetState(1742)
			p.Match(JavaParserCOMMA)
		}
		{
			p.SetState(1743)
			p.TypeArgument()
		}

		p.SetState(1748)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1749)
		p.Match(JavaParserGT)
	}

	return localctx
}

// ISuperSuffixContext is an interface to support dynamic dispatch.
type ISuperSuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSuperSuffixContext differentiates from other interfaces.
	IsSuperSuffixContext()
}

type SuperSuffixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySuperSuffixContext() *SuperSuffixContext {
	var p = new(SuperSuffixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_superSuffix
	return p
}

func (*SuperSuffixContext) IsSuperSuffixContext() {}

func NewSuperSuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SuperSuffixContext {
	var p = new(SuperSuffixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_superSuffix

	return p
}

func (s *SuperSuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *SuperSuffixContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *SuperSuffixContext) DOT() antlr.TerminalNode {
	return s.GetToken(JavaParserDOT, 0)
}

func (s *SuperSuffixContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SuperSuffixContext) TypeArguments() ITypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *SuperSuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SuperSuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SuperSuffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterSuperSuffix(s)
	}
}

func (s *SuperSuffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitSuperSuffix(s)
	}
}

func (p *JavaParser) SuperSuffix() (localctx ISuperSuffixContext) {
	this := p
	_ = this

	localctx = NewSuperSuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, JavaParserRULE_superSuffix)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1760)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JavaParserLPAREN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1751)
			p.Arguments()
		}

	case JavaParserDOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1752)
			p.Match(JavaParserDOT)
		}
		p.SetState(1754)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JavaParserLT {
			{
				p.SetState(1753)
				p.TypeArguments()
			}

		}
		{
			p.SetState(1756)
			p.Identifier()
		}
		p.SetState(1758)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 216, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1757)
				p.Arguments()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExplicitGenericInvocationSuffixContext is an interface to support dynamic dispatch.
type IExplicitGenericInvocationSuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExplicitGenericInvocationSuffixContext differentiates from other interfaces.
	IsExplicitGenericInvocationSuffixContext()
}

type ExplicitGenericInvocationSuffixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplicitGenericInvocationSuffixContext() *ExplicitGenericInvocationSuffixContext {
	var p = new(ExplicitGenericInvocationSuffixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_explicitGenericInvocationSuffix
	return p
}

func (*ExplicitGenericInvocationSuffixContext) IsExplicitGenericInvocationSuffixContext() {}

func NewExplicitGenericInvocationSuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplicitGenericInvocationSuffixContext {
	var p = new(ExplicitGenericInvocationSuffixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_explicitGenericInvocationSuffix

	return p
}

func (s *ExplicitGenericInvocationSuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplicitGenericInvocationSuffixContext) SUPER() antlr.TerminalNode {
	return s.GetToken(JavaParserSUPER, 0)
}

func (s *ExplicitGenericInvocationSuffixContext) SuperSuffix() ISuperSuffixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISuperSuffixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISuperSuffixContext)
}

func (s *ExplicitGenericInvocationSuffixContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExplicitGenericInvocationSuffixContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *ExplicitGenericInvocationSuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplicitGenericInvocationSuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExplicitGenericInvocationSuffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterExplicitGenericInvocationSuffix(s)
	}
}

func (s *ExplicitGenericInvocationSuffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitExplicitGenericInvocationSuffix(s)
	}
}

func (p *JavaParser) ExplicitGenericInvocationSuffix() (localctx IExplicitGenericInvocationSuffixContext) {
	this := p
	_ = this

	localctx = NewExplicitGenericInvocationSuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, JavaParserRULE_explicitGenericInvocationSuffix)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1767)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JavaParserSUPER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1762)
			p.Match(JavaParserSUPER)
		}
		{
			p.SetState(1763)
			p.SuperSuffix()
		}

	case JavaParserMODULE, JavaParserOPEN, JavaParserREQUIRES, JavaParserEXPORTS, JavaParserOPENS, JavaParserTO, JavaParserUSES, JavaParserPROVIDES, JavaParserWITH, JavaParserTRANSITIVE, JavaParserVAR, JavaParserYIELD, JavaParserRECORD, JavaParserSEALED, JavaParserPERMITS, JavaParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1764)
			p.Identifier()
		}
		{
			p.SetState(1765)
			p.Arguments()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArgumentsContext is an interface to support dynamic dispatch.
type IArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentsContext differentiates from other interfaces.
	IsArgumentsContext()
}

type ArgumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentsContext() *ArgumentsContext {
	var p = new(ArgumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaParserRULE_arguments
	return p
}

func (*ArgumentsContext) IsArgumentsContext() {}

func NewArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentsContext {
	var p = new(ArgumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_arguments

	return p
}

func (s *ArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserLPAREN, 0)
}

func (s *ArgumentsContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserRPAREN, 0)
}

func (s *ArgumentsContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterArguments(s)
	}
}

func (s *ArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitArguments(s)
	}
}

func (p *JavaParser) Arguments() (localctx IArgumentsContext) {
	this := p
	_ = this

	localctx = NewArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, JavaParserRULE_arguments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1769)
		p.Match(JavaParserLPAREN)
	}
	p.SetState(1771)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<JavaParserBOOLEAN)|(1<<JavaParserBYTE)|(1<<JavaParserCHAR)|(1<<JavaParserDOUBLE)|(1<<JavaParserFLOAT)|(1<<JavaParserINT)|(1<<JavaParserLONG)|(1<<JavaParserNEW))) != 0) || (((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(JavaParserSHORT-37))|(1<<(JavaParserSUPER-37))|(1<<(JavaParserSWITCH-37))|(1<<(JavaParserTHIS-37))|(1<<(JavaParserVOID-37))|(1<<(JavaParserMODULE-37))|(1<<(JavaParserOPEN-37))|(1<<(JavaParserREQUIRES-37))|(1<<(JavaParserEXPORTS-37))|(1<<(JavaParserOPENS-37))|(1<<(JavaParserTO-37))|(1<<(JavaParserUSES-37))|(1<<(JavaParserPROVIDES-37))|(1<<(JavaParserWITH-37))|(1<<(JavaParserTRANSITIVE-37))|(1<<(JavaParserVAR-37))|(1<<(JavaParserYIELD-37))|(1<<(JavaParserRECORD-37))|(1<<(JavaParserSEALED-37))|(1<<(JavaParserPERMITS-37))|(1<<(JavaParserDECIMAL_LITERAL-37))|(1<<(JavaParserHEX_LITERAL-37)))) != 0) || (((_la-69)&-(0x1f+1)) == 0 && ((1<<uint((_la-69)))&((1<<(JavaParserOCT_LITERAL-69))|(1<<(JavaParserBINARY_LITERAL-69))|(1<<(JavaParserFLOAT_LITERAL-69))|(1<<(JavaParserHEX_FLOAT_LITERAL-69))|(1<<(JavaParserBOOL_LITERAL-69))|(1<<(JavaParserCHAR_LITERAL-69))|(1<<(JavaParserSTRING_LITERAL-69))|(1<<(JavaParserTEXT_BLOCK-69))|(1<<(JavaParserNULL_LITERAL-69))|(1<<(JavaParserLPAREN-69))|(1<<(JavaParserLT-69))|(1<<(JavaParserBANG-69))|(1<<(JavaParserTILDE-69))|(1<<(JavaParserINC-69)))) != 0) || (((_la-101)&-(0x1f+1)) == 0 && ((1<<uint((_la-101)))&((1<<(JavaParserDEC-101))|(1<<(JavaParserADD-101))|(1<<(JavaParserSUB-101))|(1<<(JavaParserAT-101))|(1<<(JavaParserIDENTIFIER-101)))) != 0) {
		{
			p.SetState(1770)
			p.ExpressionList()
		}

	}
	{
		p.SetState(1773)
		p.Match(JavaParserRPAREN)
	}

	return localctx
}

func (p *JavaParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 100:
		var t *ExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionContext)
		}
		return p.Expression_Sempred(t, predIndex)

	case 108:
		var t *GuardedPatternContext = nil
		if localctx != nil {
			t = localctx.(*GuardedPatternContext)
		}
		return p.GuardedPattern_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *JavaParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 18)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 17)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 16)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 15)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 13)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 12)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 10)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 9)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 26)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 25)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 21)

	case 15:
		return p.Precpred(p.GetParserRuleContext(), 14)

	case 16:
		return p.Precpred(p.GetParserRuleContext(), 3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *JavaParser) GuardedPattern_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 17:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
